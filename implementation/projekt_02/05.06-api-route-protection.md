# Teilaufgabe 05.06: API Route Protection

## Ziel
Implementierung von API Route Protection mit Authentication, Authorization und CSRF Protection.

## Zeitschätzung
15 Minuten

## Vorbedingungen
- [ ] 05.01-05.05 abgeschlossen
- [ ] Auth Package funktioniert
- [ ] Next.js API Routes verstanden

## Implementierung

### Schritt 1: Erstelle API Auth Library

Erstelle `apps/web/src/lib/api-auth.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { 
  getAuthUser, 
  hasRole, 
  hasPermission,
  hasAllPermissions,
  hasAnyPermission,
  type AuthUser 
} from '@starter-kit/auth';

interface APIAuthOptions {
  requireAuth?: boolean;
  role?: 'admin' | 'moderator';
  permission?: string;
  permissions?: string[];
  requireAll?: boolean;
}

export async function withAPIAuth(
  handler: (req: NextRequest, user?: AuthUser) => Promise<NextResponse>,
  options: APIAuthOptions = {}
) {
  return async (req: NextRequest) => {
    try {
      const user = await getAuthUser();
      
      // Check authentication
      if (options.requireAuth !== false && !user) {
        return NextResponse.json(
          { error: 'Authentication required' },
          { status: 401 }
        );
      }
      
      // Check role
      if (options.role && user) {
        const hasRequiredRole = await hasRole(options.role);
        if (!hasRequiredRole) {
          return NextResponse.json(
            { error: 'Insufficient permissions' },
            { status: 403 }
          );
        }
      }
      
      // Check single permission
      if (options.permission && user) {
        const hasRequiredPermission = await hasPermission(options.permission);
        if (!hasRequiredPermission) {
          return NextResponse.json(
            { error: 'Missing required permission' },
            { status: 403 }
          );
        }
      }
      
      // Check multiple permissions
      if (options.permissions && options.permissions.length > 0 && user) {
        const hasPerms = options.requireAll
          ? await hasAllPermissions(options.permissions)
          : await hasAnyPermission(options.permissions);
        
        if (!hasPerms) {
          return NextResponse.json(
            { error: 'Missing required permissions' },
            { status: 403 }
          );
        }
      }
      
      return handler(req, user || undefined);
    } catch (error) {
      console.error('API Auth Error:', error);
      return NextResponse.json(
        { error: 'Internal server error' },
        { status: 500 }
      );
    }
  };
}

// CSRF Protection for mutations
export function withCSRFProtection(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest) => {
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(req.method || '')) {
      const origin = req.headers.get('origin');
      const host = req.headers.get('host');
      
      if (process.env.NODE_ENV === 'production') {
        if (!origin || !host || new URL(origin).host !== host) {
          return NextResponse.json(
            { error: 'CSRF validation failed' },
            { status: 403 }
          );
        }
      }
    }
    
    return handler(req);
  };
}

// Combined protection
export function protectAPI(
  handler: (req: NextRequest, user?: AuthUser) => Promise<NextResponse>,
  options: APIAuthOptions = {}
) {
  return withCSRFProtection(withAPIAuth(handler, options));
}
```

### Schritt 2: Erstelle Rate Limiting Helper

Erstelle `apps/web/src/lib/rate-limit.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';

interface RateLimitOptions {
  requests: number;
  window: number; // in seconds
  identifier?: (req: NextRequest) => string;
}

const rateLimitMap = new Map<string, { count: number; resetAt: number }>();

export function withRateLimit(
  handler: (req: NextRequest) => Promise<NextResponse>,
  options: RateLimitOptions = { requests: 10, window: 60 }
) {
  return async (req: NextRequest) => {
    const identifier = options.identifier 
      ? options.identifier(req)
      : req.headers.get('x-forwarded-for') || 'unknown';
    
    const now = Date.now();
    const windowMs = options.window * 1000;
    
    const record = rateLimitMap.get(identifier);
    
    if (!record || record.resetAt < now) {
      rateLimitMap.set(identifier, {
        count: 1,
        resetAt: now + windowMs
      });
    } else {
      if (record.count >= options.requests) {
        const retryAfter = Math.ceil((record.resetAt - now) / 1000);
        
        return NextResponse.json(
          { error: 'Too many requests' },
          { 
            status: 429,
            headers: {
              'Retry-After': retryAfter.toString(),
              'X-RateLimit-Limit': options.requests.toString(),
              'X-RateLimit-Remaining': '0',
              'X-RateLimit-Reset': new Date(record.resetAt).toISOString()
            }
          }
        );
      }
      
      record.count++;
    }
    
    const response = await handler(req);
    const currentRecord = rateLimitMap.get(identifier);
    
    if (currentRecord) {
      response.headers.set('X-RateLimit-Limit', options.requests.toString());
      response.headers.set('X-RateLimit-Remaining', 
        Math.max(0, options.requests - currentRecord.count).toString()
      );
      response.headers.set('X-RateLimit-Reset', 
        new Date(currentRecord.resetAt).toISOString()
      );
    }
    
    return response;
  };
}
```

### Schritt 3: API Route Examples

Erstelle `apps/web/src/app/api/protected/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { protectAPI } from '@/lib/api-auth';

// Basic protected route
export const GET = protectAPI(
  async (req: NextRequest, user) => {
    return NextResponse.json({
      message: 'Protected data',
      user: {
        id: user?.id,
        email: user?.email,
        role: user?.role
      }
    });
  }
);

// Admin only route
export const POST = protectAPI(
  async (req: NextRequest, user) => {
    const data = await req.json();
    
    // User is guaranteed to be admin here
    console.log('Admin action by:', user?.email);
    
    return NextResponse.json({
      success: true,
      data
    });
  },
  { role: 'admin' }
);
```

Erstelle `apps/web/src/app/api/public/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withRateLimit } from '@/lib/rate-limit';
import { getAuthUser } from '@starter-kit/auth';

// Public route with rate limiting
export const GET = withRateLimit(
  async (req: NextRequest) => {
    const user = await getAuthUser(); // Optional auth
    
    return NextResponse.json({
      message: 'Public endpoint',
      authenticated: !!user,
      timestamp: new Date().toISOString()
    });
  },
  { requests: 5, window: 60 } // 5 requests per minute
);
```

Erstelle `apps/web/src/app/api/admin/users/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { protectAPI } from '@/lib/api-auth';
import { PERMISSIONS } from '@starter-kit/auth';

export const GET = protectAPI(
  async (req: NextRequest, user) => {
    // Fetch users from database
    // This is just an example
    return NextResponse.json({
      users: [],
      requestedBy: user?.email
    });
  },
  { 
    permission: PERMISSIONS.USER_VIEW 
  }
);

export const POST = protectAPI(
  async (req: NextRequest, user) => {
    const data = await req.json();
    
    // Create user logic here
    
    return NextResponse.json({
      success: true,
      createdBy: user?.email,
      data
    });
  },
  { 
    permissions: [PERMISSIONS.USER_CREATE, PERMISSIONS.ADMIN_ACCESS],
    requireAll: true 
  }
);
```

### Schritt 4: Error Handler Wrapper

Erstelle `apps/web/src/lib/api-error.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';

export class APIError extends Error {
  constructor(
    message: string,
    public status: number = 500,
    public code?: string
  ) {
    super(message);
    this.name = 'APIError';
  }
}

export function withErrorHandler(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest) => {
    try {
      return await handler(req);
    } catch (error) {
      console.error('API Error:', error);
      
      if (error instanceof APIError) {
        return NextResponse.json(
          { 
            error: error.message,
            code: error.code 
          },
          { status: error.status }
        );
      }
      
      return NextResponse.json(
        { error: 'Internal server error' },
        { status: 500 }
      );
    }
  };
}

// Usage
export function createAPIHandler(
  handler: (req: NextRequest, user?: any) => Promise<NextResponse>,
  options: any = {}
) {
  return withErrorHandler(
    protectAPI(handler, options)
  );
}
```

## Verifizierung

### Test 1: Unprotected Access
```bash
curl http://localhost:3004/api/protected
# Sollte 401 Unauthorized zurückgeben
```

### Test 2: Protected with Auth
```bash
# Mit Authentication Cookie/Header
curl http://localhost:3004/api/protected \
  -H "Cookie: __session=..."
# Sollte user data zurückgeben
```

### Test 3: Admin Route
```bash
# Als normaler User
curl -X POST http://localhost:3004/api/protected
# Sollte 403 Forbidden zurückgeben

# Als Admin
# Sollte success: true zurückgeben
```

### Test 4: Rate Limiting
```bash
# Mehrfach aufrufen
for i in {1..10}; do
  curl http://localhost:3004/api/public
done
# Nach 5 Requests sollte 429 Too Many Requests kommen
```

### Test 5: CSRF Protection
```bash
# POST ohne Origin Header
curl -X POST http://localhost:3004/api/protected \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}'
# In Production sollte CSRF validation failed kommen
```

## Erfolgskriterien
- [ ] API Auth Wrapper funktioniert
- [ ] CSRF Protection aktiv
- [ ] Rate Limiting implementiert
- [ ] Role-based API Protection
- [ ] Permission-based API Protection
- [ ] Error Handling funktioniert
- [ ] TypeScript Types korrekt

## Troubleshooting

### Problem: User ist immer undefined
**Lösung:**
1. Prüfe ob Cookie/Session vorhanden
2. Verifiziere Clerk Middleware
3. Check Auth Package Implementation

### Problem: CSRF blockiert legitimate Requests
**Lösung:**
1. Füge Origin Header hinzu
2. Prüfe Host Configuration
3. Deaktiviere in Development

### Problem: Rate Limit Memory Leak
**Lösung:**
1. Implementiere Cleanup Mechanism
2. Nutze Redis für Production
3. Limitiere Map Size

## Nächster Schritt
Nach erfolgreicher API Protection → [05.07-unauthorized-page.md](./05.07-unauthorized-page.md)