# Arbeitspaket 08.10: Testing und Verifizierung

## Ziel
Umfassende Tests und Verifizierung aller Error Handling Komponenten, um sicherzustellen, dass das System robust und benutzerfreundlich funktioniert.

## Kontext
- **Komponenten**: Alle Error Handling Module aus 08.01 - 08.09
- **Ziel**: Vollst√§ndige Test Coverage und Verifizierung

## Test Suite

### Test 1: oRPC Error Types (08.01)

#### Test Setup
```typescript
// test/errors/orpc-errors.test.ts
import { describe, it, expect } from 'vitest';
import { baseRouter, logError } from '@starter-kit/api/errors';
import { ORPCError } from '@orpc/server';

describe('oRPC Error Setup', () => {
  it('should create base router with error types', () => {
    const router = baseRouter
      .procedure('test')
      .handler(async ({ errors }) => {
        // Check all error types are available
        expect(errors.VALIDATION_ERROR).toBeDefined();
        expect(errors.UNAUTHORIZED).toBeDefined();
        expect(errors.NOT_FOUND).toBeDefined();
        expect(errors.RATE_LIMIT_EXCEEDED).toBeDefined();
      });
  });

  it('should log errors with correct severity', () => {
    const consoleSpy = vi.spyOn(console, 'error');
    
    // Server error (500)
    logError(new ORPCError('INTERNAL_ERROR', { message: 'Test' }));
    expect(consoleSpy).toHaveBeenCalledWith(
      expect.stringContaining('üî¥ Server Error')
    );
    
    // Client error (404)
    const consoleWarnSpy = vi.spyOn(console, 'warn');
    logError(new ORPCError('NOT_FOUND', { message: 'Test' }));
    expect(consoleWarnSpy).toHaveBeenCalledWith(
      expect.stringContaining('üü° Client Error')
    );
  });
});
```

### Test 2: Prisma Error Handler (08.02)

```typescript
// test/errors/prisma-handler.test.ts
import { describe, it, expect } from 'vitest';
import { handlePrismaError, isPrismaError } from '@starter-kit/api/errors/prisma-handler';
import { Prisma } from '@prisma/client';

describe('Prisma Error Handler', () => {
  it('should handle unique constraint violation', () => {
    const error = new Prisma.PrismaClientKnownRequestError(
      'Unique constraint failed',
      { code: 'P2002', meta: { target: 'email' } }
    );

    expect(() => handlePrismaError(error)).toThrow(
      expect.objectContaining({
        code: 'DUPLICATE_RESOURCE',
        data: { field: 'email' }
      })
    );
  });

  it('should handle not found error', () => {
    const error = new Prisma.PrismaClientKnownRequestError(
      'Record not found',
      { code: 'P2025' }
    );

    expect(() => handlePrismaError(error)).toThrow(
      expect.objectContaining({
        code: 'NOT_FOUND'
      })
    );
  });

  it('should identify Prisma errors correctly', () => {
    const error = new Prisma.PrismaClientKnownRequestError(
      'Test',
      { code: 'P2002' }
    );
    
    expect(isPrismaError(error, 'P2002')).toBe(true);
    expect(isPrismaError(error, 'P2025')).toBe(false);
  });
});
```

### Test 3: Component Error Boundary (08.05)

```typescript
// test/components/error-boundary.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { ErrorBoundary } from '@/components/error-boundary';

const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
  if (shouldThrow) {
    throw new Error('Test error');
  }
  return <div>No error</div>;
};

describe('ErrorBoundary', () => {
  it('should catch and display errors', () => {
    const onError = vi.fn();
    
    render(
      <ErrorBoundary onError={onError}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );
    
    expect(screen.queryByText('No error')).not.toBeInTheDocument();
    expect(screen.getByText(/Fehler/)).toBeInTheDocument();
    expect(onError).toHaveBeenCalled();
  });

  it('should reset on reset keys change', () => {
    const { rerender } = render(
      <ErrorBoundary resetKeys={[1]}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );
    
    expect(screen.getByText(/Fehler/)).toBeInTheDocument();
    
    // Change reset key
    rerender(
      <ErrorBoundary resetKeys={[2]}>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );
    
    expect(screen.queryByText(/Fehler/)).not.toBeInTheDocument();
    expect(screen.getByText('No error')).toBeInTheDocument();
  });

  it('should auto-recover from chunk errors', async () => {
    vi.useFakeTimers();
    
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );
    
    // Trigger chunk error
    const error = new Error('Loading chunk 123 failed');
    
    // Wait for auto-recovery
    vi.advanceTimersByTime(1000);
    
    vi.useRealTimers();
  });
});
```

### Test 4: Toast Integration (08.06 + 08.07)

```typescript
// test/hooks/use-error-toast.test.ts
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useErrorToast } from '@/hooks/use-error-toast';

describe('useErrorToast', () => {
  it('should show error toast for oRPC errors', () => {
    const { result } = renderHook(() => useErrorToast());
    
    const error = {
      code: 'VALIDATION_ERROR',
      message: 'Test validation',
      data: { field: 'email' }
    };
    
    act(() => {
      result.current.showError(error);
    });
    
    // Check toast was shown with correct message
    expect(document.querySelector('[role="alert"]')).toBeInTheDocument();
  });

  it('should handle promise with toast', async () => {
    const { result } = renderHook(() => useErrorToast());
    
    const promise = new Promise((resolve) => 
      setTimeout(() => resolve('done'), 100)
    );
    
    await act(async () => {
      await result.current.withToast(promise, {
        loading: 'Loading...',
        success: 'Success!'
      });
    });
    
    // Check success toast
    expect(document.querySelector('[role="alert"]')).toBeInTheDocument();
  });
});
```

### Test 5: API Client (08.08)

```typescript
// test/lib/api-client.test.ts
import { describe, it, expect, vi } from 'vitest';
import { safeApiClient } from '@/lib/api-client';

describe('API Client', () => {
  it('should return error tuple for failed requests', async () => {
    // Mock failed request
    vi.mocked(fetch).mockRejectedValueOnce(new Error('Network error'));
    
    const [error, data, isDefined] = await safeApiClient.user.get({
      id: 'test-id'
    });
    
    expect(error).toBeDefined();
    expect(data).toBeUndefined();
    expect(isDefined).toBe(false);
  });

  it('should return data for successful requests', async () => {
    // Mock successful request
    vi.mocked(fetch).mockResolvedValueOnce({
      ok: true,
      json: async () => ({ id: 'test-id', name: 'Test User' })
    });
    
    const [error, data] = await safeApiClient.user.get({
      id: 'test-id'
    });
    
    expect(error).toBeNull();
    expect(data).toEqual({ id: 'test-id', name: 'Test User' });
  });
});
```

### Integration Test Suite

```typescript
// test/integration/error-handling.test.ts
import { describe, it, expect } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('Error Handling Integration', () => {
  it('should handle full error flow from API to UI', async () => {
    const user = userEvent.setup();
    
    // Render component that triggers API error
    render(<TestComponent />);
    
    // Trigger action that causes error
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    // Wait for error toast
    await waitFor(() => {
      expect(screen.getByText(/Fehler/)).toBeInTheDocument();
    });
    
    // Check error boundary didn't crash app
    expect(screen.getByRole('main')).toBeInTheDocument();
  });

  it('should recover from errors correctly', async () => {
    const user = userEvent.setup();
    
    // Trigger error
    render(<ErrorComponent />);
    
    // Click retry
    await user.click(screen.getByRole('button', { name: /retry/i }));
    
    // Should recover
    await waitFor(() => {
      expect(screen.queryByText(/Fehler/)).not.toBeInTheDocument();
    });
  });
});
```

## Manual Testing Checklist

### 1. Error Boundaries
- [ ] Component throws error ‚Üí Shows error UI
- [ ] Click retry ‚Üí Component reloads
- [ ] Navigate away and back ‚Üí Error clears
- [ ] Multiple errors ‚Üí Only shows latest
- [ ] Chunk load error ‚Üí Auto-recovers

### 2. Toast Notifications
- [ ] API error ‚Üí Shows error toast
- [ ] Success action ‚Üí Shows success toast
- [ ] Multiple toasts ‚Üí Stack correctly
- [ ] Toast dismiss ‚Üí Works properly
- [ ] Promise toast ‚Üí Shows loading ‚Üí success/error

### 3. API Errors
- [ ] 401 Unauthorized ‚Üí Redirects to login
- [ ] 403 Forbidden ‚Üí Shows permission error
- [ ] 404 Not Found ‚Üí Shows not found message
- [ ] 429 Rate Limited ‚Üí Shows retry timer
- [ ] 500 Server Error ‚Üí Shows server error

### 4. Form Validation
- [ ] Invalid input ‚Üí Shows field error
- [ ] Submit with errors ‚Üí Shows validation toast
- [ ] Fix errors ‚Üí Errors clear
- [ ] Server validation ‚Üí Shows server errors

### 5. Global Error Page
- [ ] Unhandled error ‚Üí Shows global error page
- [ ] Click home ‚Üí Returns to home
- [ ] Click retry ‚Üí Attempts recovery
- [ ] Development ‚Üí Shows stack trace
- [ ] Production ‚Üí Hides technical details

## Performance Testing

```typescript
// test/performance/error-handling.perf.ts
import { describe, it, expect } from 'vitest';

describe('Error Handling Performance', () => {
  it('should handle 100 errors without memory leak', () => {
    const initialMemory = performance.memory.usedJSHeapSize;
    
    // Trigger 100 errors
    for (let i = 0; i < 100; i++) {
      try {
        throw new Error(`Error ${i}`);
      } catch (e) {
        handleError(e);
      }
    }
    
    // Force garbage collection if available
    if (global.gc) global.gc();
    
    const finalMemory = performance.memory.usedJSHeapSize;
    const memoryIncrease = finalMemory - initialMemory;
    
    // Should not leak more than 1MB
    expect(memoryIncrease).toBeLessThan(1024 * 1024);
  });

  it('should show toast within 100ms', async () => {
    const start = performance.now();
    
    showErrorToast(new Error('Test'));
    
    const end = performance.now();
    expect(end - start).toBeLessThan(100);
  });
});
```

## Monitoring Setup

```typescript
// apps/web/src/lib/monitoring.ts
export function setupErrorMonitoring() {
  // Count errors by type
  const errorCounts = new Map<string, number>();
  
  // Monitor error frequency
  window.addEventListener('error', (event) => {
    const key = event.error?.name || 'unknown';
    errorCounts.set(key, (errorCounts.get(key) || 0) + 1);
    
    // Alert if too many errors
    if (errorCounts.get(key)! > 10) {
      console.warn(`High error frequency: ${key}`);
      // Send alert to monitoring service
    }
  });
  
  // Report metrics every minute
  setInterval(() => {
    if (errorCounts.size > 0) {
      console.log('Error metrics:', Object.fromEntries(errorCounts));
      // Send to analytics
      errorCounts.clear();
    }
  }, 60000);
}
```

## Erfolgskriterien
- [ ] Alle Unit Tests bestehen
- [ ] Integration Tests erfolgreich
- [ ] Manual Testing Checklist abgeschlossen
- [ ] Performance Tests bestehen
- [ ] Keine Memory Leaks
- [ ] Error Recovery funktioniert
- [ ] User Experience getestet

## Potentielle Probleme

### Problem: Tests schlagen fehl in CI/CD
**L√∂sung**: Mock externe Dependencies, use test database

### Problem: Flaky Tests
**L√∂sung**: Proper waitFor, avoid timing dependencies

### Problem: Memory Leaks in Tests
**L√∂sung**: Cleanup in afterEach, clear all timers

## Zeitsch√§tzung
- Unit Tests schreiben: 10 Minuten
- Integration Tests: 5 Minuten  
- Manual Testing: 5 Minuten
- Total: 20 Minuten