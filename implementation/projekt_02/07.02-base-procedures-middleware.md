# Arbeitspaket 07.02: Base Procedures und Middleware

## Ziel
Implementierung von Base Procedures mit Authentication, Authorization und Rate Limiting Middleware für alle API Endpoints.

## Kontext
- Aufbauend auf Context (07.01)
- Wiederverwendbare Middleware-Komponenten
- Rate Limiting mit Upstash Redis (optional)
- Type-safe Procedure Chains

## Implementierung

### Schritt 1: Base Procedures
Erstelle `packages/api/src/procedures/base.ts`:

```typescript
import { os } from '@orpc/server';
import { createContext, type Context } from '../context';
import { createError } from '../errors/app-error';

// Base procedure with context
export const publicProcedure = os.context(createContext);

// Authenticated procedure
export const authedProcedure = publicProcedure
  .use(async ({ context, next }) => {
    if (!context.userId) {
      throw createError.unauthorized();
    }
    return next();
  });

// Admin procedure
export const adminProcedure = authedProcedure
  .use(async ({ context, next }) => {
    if (!context.isAdmin) {
      throw createError.forbidden('Admin access required');
    }
    return next();
  });

// Moderator procedure
export const moderatorProcedure = authedProcedure
  .use(async ({ context, next }) => {
    const isModerator = context.user?.publicMetadata?.role === 'moderator';
    const isAdmin = context.isAdmin;
    
    if (!isModerator && !isAdmin) {
      throw createError.forbidden('Moderator access required');
    }
    return next();
  });
```

### Schritt 2: Rate Limiting Middleware
Erweitere `packages/api/src/procedures/base.ts`:

```typescript
import { Redis } from '@upstash/redis';
import { Ratelimit } from '@upstash/ratelimit';

// Initialize Redis and Rate Limiter (optional)
const redis = process.env.UPSTASH_REDIS_REST_URL 
  ? new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    })
  : null;

// Rate limiting configurations
const rateLimiters = {
  // Default: 10 requests per 10 seconds
  default: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(10, '10 s'),
    analytics: true,
  }) : null,
  
  // Strict: 5 requests per minute
  strict: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(5, '1 m'),
    analytics: true,
  }) : null,
  
  // Relaxed: 30 requests per 10 seconds
  relaxed: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(30, '10 s'),
    analytics: true,
  }) : null,
};

// Rate limiting middleware factory
export function withRateLimit(
  options: {
    key?: (context: Context) => string;
    limit?: 'default' | 'strict' | 'relaxed';
  } = {}
) {
  const { 
    key = (ctx) => ctx.userId || ctx.ip || 'anonymous',
    limit = 'default' 
  } = options;
  
  return async ({ context, next }: { context: Context, next: () => any }) => {
    const rateLimiter = rateLimiters[limit];
    
    if (!rateLimiter) {
      return next(); // Skip if rate limiting not configured
    }
    
    const identifier = key(context);
    const { success, limit: maxLimit, reset, remaining } = 
      await rateLimiter.limit(identifier);
    
    if (!success) {
      throw createError.rateLimit(reset, maxLimit);
    }
    
    return next();
  };
}
```

### Schritt 3: Ownership Validation Middleware
Erweitere `packages/api/src/procedures/base.ts`:

```typescript
// Ownership validation middleware
export function withOwnership<T extends { authorId?: string; userId?: string; ownerId?: string }>(
  options: {
    getResource: (input: any, context: Context) => Promise<T | null>;
    ownerField?: keyof T;
    allowAdmin?: boolean;
  }
) {
  const { 
    getResource, 
    ownerField = 'authorId' as keyof T,
    allowAdmin = true 
  } = options;
  
  return async ({ input, context, next }: { 
    input: any; 
    context: Context; 
    next: () => any 
  }) => {
    const resource = await getResource(input, context);
    
    if (!resource) {
      throw createError.notFound();
    }
    
    const ownerId = resource[ownerField] as string | undefined;
    const isOwner = ownerId === context.userId;
    const canAccess = isOwner || (allowAdmin && context.isAdmin);
    
    if (!canAccess) {
      throw createError.forbidden('You do not have permission to access this resource');
    }
    
    // Add resource to context for use in handler
    (context as any).resource = resource;
    
    return next();
  };
}
```

### Schritt 4: Caching Middleware
Erweitere `packages/api/src/procedures/base.ts`:

```typescript
// Simple in-memory cache for development
const memoryCache = new Map<string, { data: any; expires: number }>();

// Caching middleware
export function withCache(options: {
  key: (input: any, context: Context) => string;
  ttl?: number; // Time to live in seconds
} = { key: () => 'default', ttl: 60 }) {
  const { key, ttl = 60 } = options;
  
  return async ({ input, context, next }: {
    input: any;
    context: Context;
    next: () => any;
  }) => {
    const cacheKey = key(input, context);
    
    // Check cache
    const cached = memoryCache.get(cacheKey);
    if (cached && cached.expires > Date.now()) {
      return cached.data;
    }
    
    // Execute handler
    const result = await next();
    
    // Store in cache
    memoryCache.set(cacheKey, {
      data: result,
      expires: Date.now() + (ttl * 1000),
    });
    
    // Clean up old entries (simple strategy)
    if (memoryCache.size > 1000) {
      const now = Date.now();
      for (const [key, value] of memoryCache.entries()) {
        if (value.expires < now) {
          memoryCache.delete(key);
        }
      }
    }
    
    return result;
  };
}
```

### Schritt 5: Logging Middleware
Erweitere `packages/api/src/procedures/base.ts`:

```typescript
// Request logging middleware
export function withLogging(options: {
  level?: 'info' | 'debug' | 'error';
  includeInput?: boolean;
  includeOutput?: boolean;
} = {}) {
  const { 
    level = 'info', 
    includeInput = false, 
    includeOutput = false 
  } = options;
  
  return async ({ input, context, next, meta }: {
    input: any;
    context: Context;
    next: () => any;
    meta?: { path?: string };
  }) => {
    const start = Date.now();
    const requestId = crypto.randomUUID();
    
    // Log request
    console.log(`[${level.toUpperCase()}] API Request`, {
      requestId,
      path: meta?.path,
      userId: context.userId,
      ip: context.ip,
      ...(includeInput && { input }),
    });
    
    try {
      const result = await next();
      
      // Log successful response
      console.log(`[${level.toUpperCase()}] API Response`, {
        requestId,
        duration: Date.now() - start,
        status: 'success',
        ...(includeOutput && { output: result }),
      });
      
      return result;
    } catch (error) {
      // Log error
      console.error(`[ERROR] API Error`, {
        requestId,
        duration: Date.now() - start,
        status: 'error',
        error: error instanceof Error ? {
          message: error.message,
          stack: error.stack,
        } : error,
      });
      
      throw error;
    }
  };
}
```

### Schritt 6: Validation Middleware
Erstelle `packages/api/src/procedures/validation.ts`:

```typescript
import { z } from 'zod';
import { createError } from '../errors/app-error';

// Input validation middleware
export function validateInput<T extends z.ZodType>(schema: T) {
  return async ({ input, next }: {
    input: unknown;
    next: (validatedInput: z.infer<T>) => any;
  }) => {
    try {
      const validated = schema.parse(input);
      return next(validated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw createError.validation(error.errors);
      }
      throw error;
    }
  };
}

// Output validation middleware (for development)
export function validateOutput<T extends z.ZodType>(schema: T) {
  return async ({ next }: { next: () => any }) => {
    const result = await next();
    
    if (process.env.NODE_ENV === 'development') {
      try {
        schema.parse(result);
      } catch (error) {
        console.error('Output validation failed:', error);
      }
    }
    
    return result;
  };
}
```

## Verifizierung

### Test 1: Authentication Middleware
```typescript
// Should throw unauthorized error
const procedure = authedProcedure.handler(() => 'success');
await procedure({ context: { userId: null } }); // Error

// Should succeed
await procedure({ context: { userId: '123' } }); // 'success'
```

### Test 2: Rate Limiting
```typescript
const limited = publicProcedure
  .use(withRateLimit({ limit: 'strict' }))
  .handler(() => 'ok');

// Make multiple requests
for (let i = 0; i < 10; i++) {
  try {
    await limited({ context });
  } catch (error) {
    console.log('Rate limited at request', i + 1);
  }
}
```

### Test 3: Ownership Check
```typescript
const updatePost = authedProcedure
  .use(withOwnership({
    getResource: async (input, ctx) => 
      ctx.db.post.findUnique({ where: { id: input.id } }),
    ownerField: 'authorId',
  }))
  .handler(({ context }) => {
    // context.resource is available here
    return 'Updated';
  });
```

## Erfolgskriterien
- [ ] Public, Authenticated und Admin Procedures
- [ ] Rate Limiting funktioniert (optional ohne Redis)
- [ ] Ownership Validation implementiert
- [ ] Caching Middleware verfügbar
- [ ] Logging System aktiv
- [ ] Input/Output Validation

## Potentielle Probleme

### Problem: Upstash Redis nicht konfiguriert
**Lösung**: Rate Limiting wird automatisch übersprungen wenn Redis nicht konfiguriert ist

### Problem: TypeScript Inference Fehler
**Lösung**: Explicit typing bei Middleware chains:
```typescript
type MyContext = Context & { resource?: Post };
```

## Nächste Schritte
- Weiter mit 07.03: User Procedures