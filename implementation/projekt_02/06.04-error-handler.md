# Sub-Task 06.04: Error Handler implementieren

## Ziel
Zentrales Error Handling für konsistente API Error Responses.

## Package
`@starter-kit/api`

## Datei
`packages/api/src/error-handler.ts`

## Implementation

```typescript
import { ORPCError } from '@orpc/server';
import { z } from 'zod';

export function handleAPIError(error: unknown): ORPCError {
  // Already an ORPCError
  if (error instanceof ORPCError) {
    return error;
  }
  
  // Zod validation error
  if (error instanceof z.ZodError) {
    return new ORPCError('BAD_REQUEST', {
      status: 400,
      message: 'Validation failed',
      data: error.flatten(),
    });
  }
  
  // Prisma errors
  if (error && typeof error === 'object' && 'code' in error) {
    const prismaError = error as any;
    
    if (prismaError.code === 'P2002') {
      return new ORPCError('CONFLICT', {
        status: 409,
        message: 'Resource already exists',
        data: { field: prismaError.meta?.target },
      });
    }
    
    if (prismaError.code === 'P2025') {
      return new ORPCError('NOT_FOUND', {
        status: 404,
        message: 'Resource not found',
      });
    }
  }
  
  // Default error
  if (error instanceof Error) {
    return new ORPCError('INTERNAL_SERVER_ERROR', {
      status: 500,
      message: process.env.NODE_ENV === 'production' 
        ? 'Internal server error' 
        : error.message,
    });
  }
  
  return new ORPCError('INTERNAL_SERVER_ERROR', {
    status: 500,
    message: 'An unknown error occurred',
  });
}
```

## Erweiterte Version mit mehr Error Types

```typescript
import { ORPCError } from '@orpc/server';
import { z } from 'zod';
import { Prisma } from '@prisma/client';

// Custom error codes
export const ErrorCodes = {
  // Validation
  VALIDATION_FAILED: 'VALIDATION_FAILED',
  INVALID_INPUT: 'INVALID_INPUT',
  
  // Authentication
  UNAUTHORIZED: 'UNAUTHORIZED',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  
  // Authorization
  FORBIDDEN: 'FORBIDDEN',
  INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',
  
  // Resources
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  ALREADY_EXISTS: 'ALREADY_EXISTS',
  
  // Rate Limiting
  TOO_MANY_REQUESTS: 'TOO_MANY_REQUESTS',
  
  // Server
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
} as const;

export class APIError extends ORPCError {
  constructor(
    code: keyof typeof ErrorCodes,
    message: string,
    status: number = 500,
    data?: any
  ) {
    super(code, {
      status,
      message,
      data,
    });
  }
}

export function handleAPIError(error: unknown): ORPCError {
  // Already an ORPCError
  if (error instanceof ORPCError) {
    return error;
  }
  
  // Zod validation error
  if (error instanceof z.ZodError) {
    const formatted = error.flatten();
    return new APIError(
      'VALIDATION_FAILED',
      'Input validation failed',
      422,
      {
        fieldErrors: formatted.fieldErrors,
        formErrors: formatted.formErrors,
      }
    );
  }
  
  // Prisma errors
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        const field = error.meta?.target as string[] | undefined;
        return new APIError(
          'ALREADY_EXISTS',
          `${field?.[0] || 'Resource'} already exists`,
          409,
          { field: field?.[0] }
        );
        
      case 'P2025':
        return new APIError(
          'NOT_FOUND',
          'Resource not found',
          404
        );
        
      case 'P2003':
        return new APIError(
          'INVALID_INPUT',
          'Foreign key constraint failed',
          400,
          { field: error.meta?.field_name }
        );
        
      case 'P2014':
        return new APIError(
          'INVALID_INPUT',
          'Relation violation',
          400
        );
        
      default:
        return new APIError(
          'INTERNAL_ERROR',
          'Database operation failed',
          500,
          process.env.NODE_ENV !== 'production' ? { code: error.code } : undefined
        );
    }
  }
  
  // Prisma validation error
  if (error instanceof Prisma.PrismaClientValidationError) {
    return new APIError(
      'INVALID_INPUT',
      'Invalid database query',
      400
    );
  }
  
  // Rate limit error
  if (error instanceof Error && error.message.includes('rate limit')) {
    return new APIError(
      'TOO_MANY_REQUESTS',
      'Too many requests, please try again later',
      429
    );
  }
  
  // Generic Error
  if (error instanceof Error) {
    // Check for specific error patterns
    if (error.message.includes('Unauthorized')) {
      return new APIError('UNAUTHORIZED', error.message, 401);
    }
    
    if (error.message.includes('Forbidden')) {
      return new APIError('FORBIDDEN', error.message, 403);
    }
    
    return new APIError(
      'INTERNAL_ERROR',
      process.env.NODE_ENV === 'production' 
        ? 'An error occurred' 
        : error.message,
      500,
      process.env.NODE_ENV !== 'production' ? { stack: error.stack } : undefined
    );
  }
  
  // Unknown error
  return new APIError(
    'INTERNAL_ERROR',
    'An unknown error occurred',
    500
  );
}

// Error logger
export function logError(error: unknown, context?: any): void {
  if (process.env.NODE_ENV === 'production') {
    // Log to external service (Sentry, DataDog, etc.)
    console.error({
      error: error instanceof Error ? error.message : error,
      stack: error instanceof Error ? error.stack : undefined,
      context,
      timestamp: new Date().toISOString(),
    });
  } else {
    // Development logging
    console.error('API Error:', error);
    if (context) {
      console.error('Context:', context);
    }
  }
}
```

## Usage in Router

```typescript
// In router.ts
import { handleAPIError, logError } from './error-handler';

const safeHandler = (handler: Function) => {
  return async (...args: any[]) => {
    try {
      return await handler(...args);
    } catch (error) {
      logError(error, { handler: handler.name, args });
      throw handleAPIError(error);
    }
  };
};

// Usage
.handler(safeHandler(async ({ input, context }) => {
  // Your logic here
}))
```

## Error Response Format

### Validation Error (422)
```json
{
  "code": "VALIDATION_FAILED",
  "message": "Input validation failed",
  "data": {
    "fieldErrors": {
      "email": ["Invalid email format"],
      "password": ["Must be at least 8 characters"]
    }
  }
}
```

### Conflict Error (409)
```json
{
  "code": "ALREADY_EXISTS",
  "message": "Email already exists",
  "data": {
    "field": "email"
  }
}
```

### Not Found (404)
```json
{
  "code": "NOT_FOUND",
  "message": "Resource not found"
}
```

### Internal Error (500)
```json
{
  "code": "INTERNAL_ERROR",
  "message": "An error occurred"
}
```

## Prisma Error Codes Reference

| Code | Description | HTTP Status |
|------|-------------|-------------|
| P2000 | Value too long | 400 |
| P2002 | Unique constraint | 409 |
| P2003 | Foreign key constraint | 400 |
| P2025 | Record not found | 404 |
| P2014 | Relation violation | 400 |

## Frontend Error Handling

```typescript
// Frontend usage
try {
  const result = await api.user.create(data);
} catch (error) {
  if (error.code === 'VALIDATION_FAILED') {
    // Show field errors
    setFieldErrors(error.data.fieldErrors);
  } else if (error.code === 'ALREADY_EXISTS') {
    // Show duplicate error
    toast.error(`${error.data.field} already exists`);
  } else {
    // Generic error
    toast.error(error.message);
  }
}
```

## Erfolgskriterien
- [ ] Alle Error Types abgedeckt
- [ ] Prisma Errors gemapped
- [ ] Zod Errors formatiert
- [ ] Production vs Development Mode
- [ ] Logging implementiert
- [ ] Konsistente Error Codes

## Geschätzte Zeit
15 Minuten