# Sub-Task 06.05: Client Usage Example mit Type Utilities

## Ziel
Type-safe API Client Implementation für Frontend mit vollständiger Type Inference.

## Package
`apps/web`

## Datei
`apps/web/src/lib/api-client.ts`

## Basic Implementation

```typescript
import { createORPCClient } from '@orpc/client';
import type { AppRouter } from '@starter-kit/api';
import type { InferRouterInputs, InferRouterOutputs } from '@orpc/server';

// Type utilities for better inference
export type RouterInputs = InferRouterInputs<AppRouter>;
export type RouterOutputs = InferRouterOutputs<AppRouter>;

// Specific types
export type CreateUserInput = RouterInputs['user']['create'];
export type CreateUserOutput = RouterOutputs['user']['create'];
export type UserListInput = RouterInputs['user']['list'];
export type UserListOutput = RouterOutputs['user']['list'];

export const api = createORPCClient<AppRouter>({
  baseURL: '/api',
  headers: () => ({
    'Content-Type': 'application/json',
  }),
});

// Usage with full type safety
export async function createUser(data: CreateUserInput) {
  try {
    const result = await api.user.create(data);
    // result is fully typed as CreateUserOutput
    return result.data;
  } catch (error) {
    // Handle validation errors
    if (error instanceof Error && 'data' in error) {
      console.error('Validation failed:', error.data);
    }
    throw error;
  }
}
```

## Advanced Client mit Auth und Error Handling

```typescript
import { createORPCClient } from '@orpc/client';
import type { AppRouter } from '@starter-kit/api';
import type { InferRouterInputs, InferRouterOutputs } from '@orpc/server';
import { getAuth } from '@clerk/nextjs';
import toast from 'react-hot-toast';

// Type utilities
export type RouterInputs = InferRouterInputs<AppRouter>;
export type RouterOutputs = InferRouterOutputs<AppRouter>;

// Specific type exports for components
export type User = RouterOutputs['user']['me']['data'];
export type CreateUserInput = RouterInputs['user']['create'];
export type UpdateUserInput = RouterInputs['user']['update'];
export type UserListFilters = RouterInputs['user']['list'];

// Error type
interface APIError extends Error {
  code?: string;
  status?: number;
  data?: any;
}

// Create client with auth headers
export const api = createORPCClient<AppRouter>({
  baseURL: process.env.NEXT_PUBLIC_API_URL || '/api',
  headers: async () => {
    const token = await getAuth()?.getToken();
    return {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
    };
  },
  // Global error handler
  onError: (error: APIError) => {
    // Log errors in development
    if (process.env.NODE_ENV === 'development') {
      console.error('API Error:', error);
    }
    
    // Handle specific error codes
    switch (error.code) {
      case 'UNAUTHORIZED':
        window.location.href = '/login';
        break;
      case 'FORBIDDEN':
        toast.error('You do not have permission to perform this action');
        break;
      case 'TOO_MANY_REQUESTS':
        toast.error('Too many requests. Please try again later.');
        break;
      default:
        // Don't throw, let individual handlers decide
        break;
    }
  },
});

// Typed API functions with error handling
export const userAPI = {
  async getCurrentUser() {
    try {
      const result = await api.user.me();
      return result.data;
    } catch (error) {
      const apiError = error as APIError;
      if (apiError.code === 'NOT_FOUND') {
        return null;
      }
      throw error;
    }
  },

  async createUser(data: CreateUserInput) {
    try {
      const result = await api.user.create(data);
      toast.success('User created successfully');
      return result.data;
    } catch (error) {
      const apiError = error as APIError;
      if (apiError.code === 'VALIDATION_FAILED') {
        // Return validation errors for form handling
        return { error: apiError.data };
      }
      if (apiError.code === 'ALREADY_EXISTS') {
        toast.error(`Email already registered`);
        return { error: { email: ['Email already exists'] } };
      }
      toast.error('Failed to create user');
      throw error;
    }
  },

  async updateUser(data: UpdateUserInput) {
    try {
      const result = await api.user.update(data);
      toast.success('Profile updated');
      return result.data;
    } catch (error) {
      toast.error('Failed to update profile');
      throw error;
    }
  },

  async listUsers(filters: UserListFilters) {
    try {
      const result = await api.user.list(filters);
      return result.data;
    } catch (error) {
      console.error('Failed to fetch users:', error);
      return { users: [], total: 0, page: 1, totalPages: 0 };
    }
  },

  async deleteUser(id: string) {
    try {
      await api.user.delete({ id });
      toast.success('User deleted');
      return true;
    } catch (error) {
      toast.error('Failed to delete user');
      return false;
    }
  },
};
```

## React Hook Usage

```typescript
// hooks/use-api.ts
import { useState, useEffect } from 'react';
import { api, type RouterOutputs } from '@/lib/api-client';

type UseAPIOptions<T> = {
  enabled?: boolean;
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
};

export function useAPI<T>(
  fetcher: () => Promise<T>,
  options: UseAPIOptions<T> = {}
) {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [loading, setLoading] = useState(false);
  
  const { enabled = true, onSuccess, onError } = options;
  
  useEffect(() => {
    if (!enabled) return;
    
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const result = await fetcher();
        setData(result);
        onSuccess?.(result);
      } catch (err) {
        const error = err as Error;
        setError(error);
        onError?.(error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [enabled]);
  
  const refetch = async () => {
    setLoading(true);
    try {
      const result = await fetcher();
      setData(result);
      return result;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  };
  
  return { data, error, loading, refetch };
}

// Usage in component
export function UserProfile() {
  const { data: user, loading, error, refetch } = useAPI(
    () => userAPI.getCurrentUser(),
    {
      onError: (error) => {
        console.error('Failed to load profile:', error);
      },
    }
  );
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return <div>No user found</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  );
}
```

## React Query Integration

```typescript
// lib/react-query.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { userAPI, type CreateUserInput, type UpdateUserInput } from '@/lib/api-client';

// Query keys
export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: any) => [...userKeys.lists(), filters] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
  current: () => [...userKeys.all, 'current'] as const,
};

// Queries
export function useCurrentUser() {
  return useQuery({
    queryKey: userKeys.current(),
    queryFn: userAPI.getCurrentUser,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useUsers(filters: any) {
  return useQuery({
    queryKey: userKeys.list(filters),
    queryFn: () => userAPI.listUsers(filters),
  });
}

// Mutations
export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: CreateUserInput) => userAPI.createUser(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: UpdateUserInput) => userAPI.updateUser(data),
    onSuccess: (data) => {
      queryClient.setQueryData(userKeys.current(), data);
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}

export function useDeleteUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id: string) => userAPI.deleteUser(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

## Form Integration Example

```typescript
// components/user-form.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { createUserSchema } from '@starter-kit/api/schemas/user';
import { useCreateUser } from '@/lib/react-query';
import type { CreateUserInput } from '@/lib/api-client';

export function UserForm() {
  const createUser = useCreateUser();
  
  const form = useForm<CreateUserInput>({
    resolver: zodResolver(createUserSchema),
    defaultValues: {
      email: '',
      name: '',
      password: '',
    },
  });
  
  const onSubmit = async (data: CreateUserInput) => {
    const result = await createUser.mutateAsync(data);
    
    if ('error' in result) {
      // Handle validation errors
      Object.entries(result.error).forEach(([field, errors]) => {
        form.setError(field as any, {
          type: 'server',
          message: errors[0],
        });
      });
      return;
    }
    
    // Success
    form.reset();
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <input {...form.register('email')} placeholder="Email" />
      {form.formState.errors.email && (
        <span>{form.formState.errors.email.message}</span>
      )}
      
      <input {...form.register('name')} placeholder="Name" />
      {form.formState.errors.name && (
        <span>{form.formState.errors.name.message}</span>
      )}
      
      <input {...form.register('password')} type="password" placeholder="Password" />
      {form.formState.errors.password && (
        <span>{form.formState.errors.password.message}</span>
      )}
      
      <button type="submit" disabled={createUser.isPending}>
        {createUser.isPending ? 'Creating...' : 'Create User'}
      </button>
    </form>
  );
}
```

## Erfolgskriterien
- [ ] Type-safe API Client erstellt
- [ ] Type Utilities exportiert
- [ ] Error Handling implementiert
- [ ] Auth Headers integriert
- [ ] React Hooks bereitgestellt
- [ ] React Query Integration
- [ ] Form Integration Example

## Geschätzte Zeit
15 Minuten