# Arbeitspaket 08.05: Component Error Boundary mit React 19

## Ziel
Implementierung einer wiederverwendbaren Error Boundary Component fÃ¼r lokalisierte Fehlerbehandlung in React Components mit React 19 Features.

## Kontext
- **Framework**: React 19 mit neuen Error Features
- **Zweck**: Isolierte Fehlerbehandlung pro Component
- **Features**: Owner Stack Traces, Error Info Enhancement

## Implementierung

### Schritt 1: Base Error Boundary Component
Erstelle `apps/web/src/components/error-boundary.tsx`:

```typescript
'use client';

import React, { Component, ReactNode, ErrorInfo } from 'react';
import { Button } from '@starter-kit/ui';
import { AlertCircle, RefreshCw, ChevronDown, ChevronUp } from 'lucide-react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
  isDetailsOpen: boolean;
  errorCount: number;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: (error: Error, reset: () => void) => ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
  isolate?: boolean; // If true, error doesn't propagate
  showDetails?: boolean; // Show error details in production
  resetKeys?: Array<string | number>; // Reset when these change
  resetOnPropsChange?: boolean;
  fallbackComponent?: React.ComponentType<{
    error: Error;
    reset: () => void;
    errorInfo?: ErrorInfo;
  }>;
  level?: 'page' | 'section' | 'component'; // Error boundary level
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  private resetTimeoutId: number | null = null;
  private previousResetKeys: Array<string | number> = [];

  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      isDetailsOpen: false,
      errorCount: 0,
    };
    this.previousResetKeys = props.resetKeys || [];
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error,
      errorCount: (state) => (state?.errorCount || 0) + 1,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const { onError, isolate = false } = this.props;
    
    // Enhanced logging with React 19 features
    console.group(`ðŸ”´ ErrorBoundary (${this.props.level || 'component'})`);
    console.error('Error:', error);
    console.error('Component Stack:', errorInfo.componentStack);
    
    // React 19: Capture owner stack for better debugging
    if ('captureOwnerStack' in React) {
      try {
        const ownerStack = (React as any).captureOwnerStack?.();
        if (ownerStack) {
          console.log('Owner Stack:', ownerStack);
        }
      } catch (e) {
        // Silently fail if not available
      }
    }
    
    console.groupEnd();

    // Call error handler
    onError?.(error, errorInfo);
    
    // Store error info
    this.setState({ errorInfo });

    // Auto-recovery for certain errors
    this.attemptAutoRecovery(error);
    
    // Re-throw if not isolated
    if (!isolate && this.state.errorCount > 3) {
      throw error;
    }
  }

  componentDidUpdate(prevProps: ErrorBoundaryProps) {
    const { resetKeys, resetOnPropsChange } = this.props;
    const { hasError } = this.state;
    
    // Reset on prop changes if enabled
    if (resetOnPropsChange && hasError && prevProps.children !== this.props.children) {
      this.reset();
    }
    
    // Reset when resetKeys change
    if (resetKeys && hasError) {
      const hasResetKeyChanged = resetKeys.some(
        (key, idx) => key !== this.previousResetKeys[idx]
      );
      
      if (hasResetKeyChanged) {
        this.reset();
        this.previousResetKeys = resetKeys;
      }
    }
  }

  componentWillUnmount() {
    if (this.resetTimeoutId) {
      clearTimeout(this.resetTimeoutId);
    }
  }

  attemptAutoRecovery = (error: Error) => {
    // Auto-recover from chunk load errors
    const isChunkError = error.message.includes('Loading chunk') || 
                        error.message.includes('ChunkLoadError');
    
    if (isChunkError && this.state.errorCount <= 2) {
      console.log('ðŸ”„ Auto-recovering from chunk load error...');
      this.resetTimeoutId = window.setTimeout(() => {
        this.reset();
      }, 1000);
    }
  };

  reset = () => {
    if (this.resetTimeoutId) {
      clearTimeout(this.resetTimeoutId);
      this.resetTimeoutId = null;
    }
    
    this.setState({
      hasError: false,
      error: undefined,
      errorInfo: undefined,
      isDetailsOpen: false,
      errorCount: 0,
    });
  };

  toggleDetails = () => {
    this.setState(prev => ({ isDetailsOpen: !prev.isDetailsOpen }));
  };

  render() {
    const { hasError, error, errorInfo, isDetailsOpen } = this.state;
    const { 
      children, 
      fallback, 
      fallbackComponent: FallbackComponent,
      level = 'component',
      showDetails = process.env.NODE_ENV === 'development'
    } = this.props;

    if (hasError && error) {
      // Use custom fallback component if provided
      if (FallbackComponent) {
        return <FallbackComponent error={error} reset={this.reset} errorInfo={errorInfo} />;
      }
      
      // Use custom fallback function if provided
      if (fallback) {
        return fallback(error, this.reset);
      }

      // Default error UI based on level
      return (
        <div className={`error-boundary-fallback error-level-${level}`}>
          {level === 'page' ? (
            <PageErrorFallback 
              error={error} 
              reset={this.reset}
              showDetails={showDetails}
              errorInfo={errorInfo}
              isDetailsOpen={isDetailsOpen}
              onToggleDetails={this.toggleDetails}
            />
          ) : level === 'section' ? (
            <SectionErrorFallback 
              error={error} 
              reset={this.reset}
              showDetails={showDetails}
              errorInfo={errorInfo}
              isDetailsOpen={isDetailsOpen}
              onToggleDetails={this.toggleDetails}
            />
          ) : (
            <ComponentErrorFallback 
              error={error} 
              reset={this.reset}
              showDetails={showDetails}
              errorInfo={errorInfo}
              isDetailsOpen={isDetailsOpen}
              onToggleDetails={this.toggleDetails}
            />
          )}
        </div>
      );
    }

    return children;
  }
}
```

### Schritt 2: Fallback Components
Erweitere `apps/web/src/components/error-boundary.tsx`:

```typescript
// Page-level error fallback
function PageErrorFallback({ 
  error, 
  reset, 
  showDetails, 
  errorInfo,
  isDetailsOpen,
  onToggleDetails 
}: any) {
  return (
    <div className="min-h-[400px] flex items-center justify-center p-8">
      <div className="max-w-md w-full">
        <div className="bg-red-50 border border-red-200 rounded-lg p-6">
          <div className="flex items-start">
            <AlertCircle className="w-6 h-6 text-red-600 mt-0.5" />
            <div className="ml-3 flex-1">
              <h3 className="text-lg font-semibold text-red-800">
                Seitenfehler
              </h3>
              <p className="mt-2 text-sm text-red-700">
                Diese Seite konnte nicht geladen werden.
              </p>
              
              {showDetails && (
                <button
                  onClick={onToggleDetails}
                  className="mt-3 text-sm text-red-600 hover:text-red-700 flex items-center gap-1"
                >
                  {isDetailsOpen ? <ChevronUp size={14} /> : <ChevronDown size={14} />}
                  {isDetailsOpen ? 'Details ausblenden' : 'Details anzeigen'}
                </button>
              )}
              
              {showDetails && isDetailsOpen && (
                <ErrorDetails error={error} errorInfo={errorInfo} />
              )}
              
              <div className="mt-4 flex gap-2">
                <Button onClick={reset} size="sm">
                  <RefreshCw className="w-4 h-4 mr-1" />
                  Neu laden
                </Button>
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={() => window.location.href = '/'}
                >
                  Zur Startseite
                </Button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// Section-level error fallback
function SectionErrorFallback({ 
  error, 
  reset, 
  showDetails,
  errorInfo,
  isDetailsOpen,
  onToggleDetails
}: any) {
  return (
    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
      <div className="flex items-start">
        <AlertCircle className="w-5 h-5 text-yellow-600 mt-0.5" />
        <div className="ml-3 flex-1">
          <h4 className="text-sm font-semibold text-yellow-800">
            Bereich konnte nicht geladen werden
          </h4>
          <p className="mt-1 text-sm text-yellow-700">
            {error.message}
          </p>
          
          {showDetails && isDetailsOpen && (
            <ErrorDetails error={error} errorInfo={errorInfo} compact />
          )}
          
          <button
            onClick={reset}
            className="mt-2 text-sm text-yellow-600 hover:text-yellow-700 font-medium"
          >
            Bereich neu laden
          </button>
        </div>
      </div>
    </div>
  );
}

// Component-level error fallback
function ComponentErrorFallback({ 
  error, 
  reset, 
  showDetails,
  errorInfo,
  isDetailsOpen,
  onToggleDetails
}: any) {
  return (
    <div className="inline-flex items-center gap-2 px-3 py-2 bg-red-50 border border-red-200 rounded text-sm">
      <AlertCircle className="w-4 h-4 text-red-500" />
      <span className="text-red-700">Fehler</span>
      <button
        onClick={reset}
        className="text-red-600 hover:text-red-700 underline"
      >
        Retry
      </button>
    </div>
  );
}

// Error details component
function ErrorDetails({ error, errorInfo, compact = false }: any) {
  return (
    <div className={`${compact ? 'mt-2' : 'mt-3'} ${compact ? 'text-xs' : 'text-sm'}`}>
      <div className="bg-gray-900 text-gray-100 rounded p-3 font-mono overflow-auto max-h-48">
        <div className="text-red-400">Error: {error.message}</div>
        {error.stack && (
          <details className="mt-2">
            <summary className="cursor-pointer text-gray-400 hover:text-gray-200">
              Stack Trace
            </summary>
            <pre className="mt-2 text-gray-300 text-xs whitespace-pre-wrap">
              {error.stack}
            </pre>
          </details>
        )}
        {errorInfo?.componentStack && (
          <details className="mt-2">
            <summary className="cursor-pointer text-gray-400 hover:text-gray-200">
              Component Stack
            </summary>
            <pre className="mt-2 text-gray-300 text-xs whitespace-pre-wrap">
              {errorInfo.componentStack}
            </pre>
          </details>
        )}
      </div>
    </div>
  );
}
```

### Schritt 3: Error Boundary Hook
Erstelle `apps/web/src/hooks/use-error-boundary.ts`:

```typescript
'use client';

import { useCallback, useState } from 'react';

export function useErrorBoundary() {
  const [error, setError] = useState<Error | null>(null);

  const resetError = useCallback(() => {
    setError(null);
  }, []);

  const captureError = useCallback((error: Error) => {
    setError(error);
  }, []);

  // Throw error to nearest error boundary
  if (error) {
    throw error;
  }

  return { resetError, captureError };
}

// Async error boundary hook
export function useAsyncError() {
  const [, setError] = useState();
  
  return useCallback((error: Error) => {
    setError(() => {
      throw error;
    });
  }, []);
}
```

## Verwendung

### Beispiel 1: Page-Level Error Boundary
```tsx
<ErrorBoundary level="page">
  <YourPageComponent />
</ErrorBoundary>
```

### Beispiel 2: Mit Custom Fallback
```tsx
<ErrorBoundary 
  fallback={(error, reset) => (
    <div>
      <p>Fehler: {error.message}</p>
      <button onClick={reset}>Retry</button>
    </div>
  )}
>
  <YourComponent />
</ErrorBoundary>
```

### Beispiel 3: Mit Reset Keys
```tsx
<ErrorBoundary resetKeys={[userId, dataVersion]}>
  <UserProfile userId={userId} />
</ErrorBoundary>
```

### Beispiel 4: Mit Hook
```tsx
function MyComponent() {
  const { captureError } = useErrorBoundary();
  
  const handleAsync = async () => {
    try {
      await riskyOperation();
    } catch (error) {
      captureError(error as Error);
    }
  };
}
```

## Verifizierung

### Test 1: Component Error
```tsx
function TestComponent() {
  throw new Error('Test error');
}

<ErrorBoundary level="component">
  <TestComponent />
</ErrorBoundary>
// Sollte inline error UI zeigen
```

### Test 2: Auto-Recovery
```tsx
// Simuliere ChunkLoadError
throw new Error('Loading chunk 123 failed');
// Sollte automatisch nach 1 Sekunde recovern
```

### Test 3: Reset Keys
```tsx
const [key, setKey] = useState(0);
<ErrorBoundary resetKeys={[key]}>
  <BrokenComponent />
</ErrorBoundary>
// setKey(1) sollte Error Boundary resetten
```

## Erfolgskriterien
- [ ] Error Boundary Component mit React 19 Features
- [ ] Verschiedene Error Levels (page, section, component)
- [ ] Auto-Recovery fÃ¼r bekannte Fehler
- [ ] Reset Keys FunktionalitÃ¤t
- [ ] Error Details Toggle
- [ ] Hook Integration

## Potentielle Probleme

### Problem: Error Boundary fÃ¤ngt async Errors nicht
**LÃ¶sung**: useAsyncError Hook verwenden

### Problem: Infinite Error Loop
**LÃ¶sung**: Error Count tracking und Propagation nach 3 Versuchen

## ZeitschÃ¤tzung
- Error Boundary Component: 15 Minuten
- Fallback Components: 5 Minuten
- Total: 20 Minuten