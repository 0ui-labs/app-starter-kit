# Teilaufgabe 05.04: Auth Package Enhancement

## Ziel
Erweiterung des Auth Packages mit Helper Functions, Permission System und Session Management.

## Zeitschätzung
20 Minuten

## Vorbedingungen
- [ ] 05.01-05.03 abgeschlossen
- [ ] @starter-kit/auth Package existiert
- [ ] Clerk Server SDK verfügbar

## Implementierung

### Schritt 1: Update Auth Package

Update `packages/auth/index.ts`:

```typescript
import { auth, currentUser, clerkClient } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { cache } from 'react';
import type { Roles, Permission } from '@/types/globals';

// Types
export interface AuthUser {
  id: string;
  email: string;
  name?: string;
  image?: string;
  role: Roles;
  permissions: Permission[];
  metadata?: Record<string, any>;
}

export interface Session {
  user: AuthUser;
  expires: Date;
  isActive: boolean;
}

// Cached user fetching
export const getAuthUser = cache(async (): Promise<AuthUser | null> => {
  const user = await currentUser();
  
  if (!user) {
    return null;
  }
  
  const role = (user.publicMetadata?.role as Roles) || 'user';
  const permissions = (user.publicMetadata?.permissions as Permission[]) || [];
  
  return {
    id: user.id,
    email: user.emailAddresses[0]?.emailAddress || '',
    name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || undefined,
    image: user.imageUrl,
    role,
    permissions,
    metadata: user.publicMetadata,
  };
});

// Get session
export const getSession = cache(async (): Promise<Session | null> => {
  const { sessionId, sessionClaims } = await auth();
  const user = await getAuthUser();
  
  if (!sessionId || !user) {
    return null;
  }
  
  return {
    user,
    expires: new Date(sessionClaims?.exp ? sessionClaims.exp * 1000 : Date.now()),
    isActive: true,
  };
});

// Auth guards
export async function requireAuth(redirectTo?: string) {
  const user = await getAuthUser();
  
  if (!user) {
    redirect(redirectTo || '/sign-in');
  }
  
  return user;
}

export async function requireRole(
  role: 'admin' | 'moderator',
  redirectTo?: string
) {
  const user = await requireAuth(redirectTo);
  
  if (role === 'admin' && user.role !== 'admin') {
    redirect('/unauthorized');
  }
  
  if (role === 'moderator' && !['admin', 'moderator'].includes(user.role)) {
    redirect('/unauthorized');
  }
  
  return user;
}

export async function requirePermission(
  permission: string,
  redirectTo?: string
) {
  const user = await requireAuth(redirectTo);
  
  if (!user.permissions.includes(permission) && user.role !== 'admin') {
    redirect('/unauthorized');
  }
  
  return user;
}

// Check functions (don't redirect)
export async function hasRole(role: 'admin' | 'moderator'): Promise<boolean> {
  const user = await getAuthUser();
  
  if (!user) return false;
  
  if (role === 'admin') return user.role === 'admin';
  if (role === 'moderator') return ['admin', 'moderator'].includes(user.role);
  
  return false;
}

export async function hasPermission(permission: string): Promise<boolean> {
  const user = await getAuthUser();
  
  if (!user) return false;
  
  return user.permissions.includes(permission) || user.role === 'admin';
}

export async function hasAnyPermission(permissions: string[]): Promise<boolean> {
  const user = await getAuthUser();
  
  if (!user) return false;
  if (user.role === 'admin') return true;
  
  return permissions.some(p => user.permissions.includes(p));
}

export async function hasAllPermissions(permissions: string[]): Promise<boolean> {
  const user = await getAuthUser();
  
  if (!user) return false;
  if (user.role === 'admin') return true;
  
  return permissions.every(p => user.permissions.includes(p));
}

// Permission constants
export const PERMISSIONS = {
  // User management
  USER_VIEW: 'user:view',
  USER_CREATE: 'user:create',
  USER_UPDATE: 'user:update',
  USER_DELETE: 'user:delete',
  
  // Post management
  POST_VIEW: 'post:view',
  POST_CREATE: 'post:create',
  POST_UPDATE: 'post:update',
  POST_DELETE: 'post:delete',
  POST_PUBLISH: 'post:publish',
  
  // Comment management
  COMMENT_VIEW: 'comment:view',
  COMMENT_CREATE: 'comment:create',
  COMMENT_UPDATE: 'comment:update',
  COMMENT_DELETE: 'comment:delete',
  COMMENT_MODERATE: 'comment:moderate',
  
  // Admin
  ADMIN_ACCESS: 'admin:access',
  ADMIN_SETTINGS: 'admin:settings',
  ADMIN_ANALYTICS: 'admin:analytics',
} as const;

// Re-export Clerk functions
export { auth, currentUser, clerkClient };

// Re-export types
export type { Roles, Permission };
```

### Schritt 2: Update Package Dependencies

Update `packages/auth/package.json`:
```json
{
  "name": "@starter-kit/auth",
  "version": "1.0.0",
  "main": "index.ts",
  "dependencies": {
    "@clerk/nextjs": "^5.7.1",
    "next": "15.0.3"
  }
}
```

### Schritt 3: Erstelle Test Datei

Erstelle `packages/auth/__tests__/auth.test.ts`:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { getAuthUser, hasRole, hasPermission, PERMISSIONS } from '../index';

// Mock Clerk
vi.mock('@clerk/nextjs/server', () => ({
  currentUser: vi.fn(),
  auth: vi.fn(),
  clerkClient: vi.fn(),
}));

describe('Auth Package', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('getAuthUser', () => {
    it('should return null when no user', async () => {
      const { currentUser } = await import('@clerk/nextjs/server');
      vi.mocked(currentUser).mockResolvedValueOnce(null);
      
      const user = await getAuthUser();
      expect(user).toBeNull();
    });
    
    it('should map user data correctly', async () => {
      const { currentUser } = await import('@clerk/nextjs/server');
      vi.mocked(currentUser).mockResolvedValueOnce({
        id: 'user_123',
        emailAddresses: [{ emailAddress: 'test@example.com' }],
        firstName: 'John',
        lastName: 'Doe',
        imageUrl: 'https://example.com/avatar.jpg',
        publicMetadata: {
          role: 'admin',
          permissions: ['post:create'],
        },
      } as any);
      
      const user = await getAuthUser();
      expect(user).toEqual({
        id: 'user_123',
        email: 'test@example.com',
        name: 'John Doe',
        image: 'https://example.com/avatar.jpg',
        role: 'admin',
        permissions: ['post:create'],
        metadata: {
          role: 'admin',
          permissions: ['post:create'],
        },
      });
    });
  });

  describe('Permission Constants', () => {
    it('should export all permission constants', () => {
      expect(PERMISSIONS.USER_VIEW).toBe('user:view');
      expect(PERMISSIONS.POST_CREATE).toBe('post:create');
      expect(PERMISSIONS.ADMIN_ACCESS).toBe('admin:access');
    });
  });
});
```

## Verifizierung

### Test 1: Import Test
```typescript
// In einer App-Datei
import { getAuthUser, PERMISSIONS } from '@starter-kit/auth';

// Sollte ohne Fehler importieren
```

### Test 2: Function Test
```typescript
// In einer Server Component
import { requireAuth, hasRole } from '@starter-kit/auth';

export default async function TestPage() {
  const user = await requireAuth();
  const isAdmin = await hasRole('admin');
  
  return <div>User: {user.email}, Admin: {isAdmin.toString()}</div>;
}
```

### Test 3: Permission Check
```typescript
import { hasPermission, PERMISSIONS } from '@starter-kit/auth';

const canCreatePost = await hasPermission(PERMISSIONS.POST_CREATE);
// Sollte true/false basierend auf User Permissions zurückgeben
```

### Test 4: Unit Tests
```bash
cd packages/auth
npm test
```

## Erfolgskriterien
- [ ] Auth Package exportiert alle Functions
- [ ] Type Safety funktioniert
- [ ] Caching über `cache()` implementiert
- [ ] Guards redirecten korrekt
- [ ] Check Functions geben Boolean zurück
- [ ] Permission Constants verfügbar
- [ ] Tests laufen erfolgreich

## Troubleshooting

### Problem: Cannot find module '@/types/globals'
**Lösung:**
1. Verwende relative Imports oder
2. Kopiere Types ins Auth Package:
```typescript
// packages/auth/types.ts
export type Roles = 'user' | 'moderator' | 'admin';
export type Permission = string;
```

### Problem: redirect() funktioniert nicht
**Lösung:**
1. Importiere von 'next/navigation'
2. Nutze nur in Server Components
3. Alternative: Return Response mit redirect

### Problem: Cache funktioniert nicht
**Lösung:**
1. Importiere `cache` von 'react'
2. Stelle sicher dass Next.js 15 verwendet wird
3. Cache funktioniert nur in Server Components

## Best Practices
- Nutze `cache()` für wiederholte DB/API Calls
- Guards sollten redirecten, Checks sollten Boolean returnen
- Admins haben automatisch alle Permissions
- Default Role sollte 'user' sein
- Halte Permission Namen konsistent (resource:action)

## Nächster Schritt
Nach erfolgreichem Auth Package Enhancement → [05.05-protected-page-wrapper.md](./05.05-protected-page-wrapper.md)