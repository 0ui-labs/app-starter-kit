# Arbeitspaket 07.08: Testing und Verifikation

## Ziel
Umfassende Test-Suite für API Procedures mit Unit Tests, Integration Tests und E2E Tests.

## Kontext
- Vitest für Unit Tests
- Playwright für E2E Tests
- Mock Data Generation
- CI/CD Integration

## Implementierung

### Schritt 1: Test Setup
Erstelle `packages/api/vitest.config.ts`:

```typescript
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'test/',
        '*.config.ts',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

### Schritt 2: Test Setup File
Erstelle `packages/api/test/setup.ts`:

```typescript
import { beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import { PrismaClient } from '@starter-kit/db';

// Test database client
export const testDb = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL || 'file:./test.db',
    },
  },
});

// Mock environment variables
beforeAll(async () => {
  process.env.NODE_ENV = 'test';
  process.env.DATABASE_URL = 'file:./test.db';
  
  // Reset database
  await testDb.$executeRaw`PRAGMA foreign_keys = OFF`;
  await testDb.$executeRaw`DELETE FROM users`;
  await testDb.$executeRaw`DELETE FROM posts`;
  await testDb.$executeRaw`DELETE FROM comments`;
  await testDb.$executeRaw`DELETE FROM tags`;
  await testDb.$executeRaw`PRAGMA foreign_keys = ON`;
});

// Clean up after each test
afterEach(async () => {
  await testDb.$transaction([
    testDb.comment.deleteMany(),
    testDb.post.deleteMany(),
    testDb.userProfile.deleteMany(),
    testDb.user.deleteMany(),
    testDb.tag.deleteMany(),
  ]);
});

// Close connection after all tests
afterAll(async () => {
  await testDb.$disconnect();
});

/**
 * Mock context factory
 */
export function createMockContext(overrides: Partial<any> = {}) {
  return {
    db: testDb,
    userId: null,
    user: null,
    isAdmin: false,
    ip: '127.0.0.1',
    userAgent: 'test-agent',
    req: null,
    ...overrides,
  };
}

/**
 * Create test user
 */
export async function createTestUser(data: Partial<any> = {}) {
  return testDb.user.create({
    data: {
      clerkId: `test_${Date.now()}`,
      email: `test${Date.now()}@example.com`,
      name: 'Test User',
      role: 'USER',
      status: 'ACTIVE',
      ...data,
      profile: {
        create: {},
      },
    },
    include: { profile: true },
  });
}

/**
 * Create test post
 */
export async function createTestPost(authorId: string, data: Partial<any> = {}) {
  return testDb.post.create({
    data: {
      title: 'Test Post',
      slug: `test-post-${Date.now()}`,
      content: 'Test content',
      excerpt: 'Test excerpt',
      published: false,
      authorId,
      ...data,
    },
  });
}
```

### Schritt 3: Unit Tests - User Procedures
Erstelle `packages/api/test/procedures/user.test.ts`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { userProcedures } from '@/procedures/user';
import { createMockContext, createTestUser } from '../setup';
import { AppError, ErrorCode } from '@/errors/app-error';

describe('User Procedures', () => {
  describe('me', () => {
    it('should return current user', async () => {
      const user = await createTestUser();
      const context = createMockContext({ 
        userId: user.clerkId,
        user: { id: user.clerkId },
      });
      
      const result = await userProcedures.me.handler({ context });
      
      expect(result.success).toBe(true);
      expect(result.data.id).toBe(user.id);
      expect(result.data.email).toBe(user.email);
    });
    
    it('should create user on first login', async () => {
      const context = createMockContext({
        userId: 'new_clerk_id',
        user: {
          id: 'new_clerk_id',
          emailAddresses: [{ emailAddress: 'new@example.com' }],
          firstName: 'New',
          lastName: 'User',
        },
      });
      
      const result = await userProcedures.me.handler({ context });
      
      expect(result.success).toBe(true);
      expect(result.data.clerkId).toBe('new_clerk_id');
      expect(result.data.email).toBe('new@example.com');
    });
    
    it('should throw error when not authenticated', async () => {
      const context = createMockContext();
      
      await expect(
        userProcedures.me.handler({ context })
      ).rejects.toThrow(AppError);
    });
  });
  
  describe('updateProfile', () => {
    it('should update user profile', async () => {
      const user = await createTestUser();
      const context = createMockContext({ userId: user.clerkId });
      
      const input = {
        name: 'Updated Name',
        bio: 'Updated bio',
        website: 'https://example.com',
      };
      
      const result = await userProcedures.updateProfile.handler({
        input,
        context,
      });
      
      expect(result.success).toBe(true);
      expect(result.data.name).toBe('Updated Name');
      expect(result.data.profile?.bio).toBe('Updated bio');
    });
    
    it('should validate input', async () => {
      const user = await createTestUser();
      const context = createMockContext({ userId: user.clerkId });
      
      const input = {
        website: 'not-a-url', // Invalid URL
      };
      
      await expect(
        userProcedures.updateProfile.handler({ input, context })
      ).rejects.toThrow();
    });
  });
  
  describe('list (admin)', () => {
    it('should list users for admin', async () => {
      await createTestUser({ name: 'User 1' });
      await createTestUser({ name: 'User 2' });
      
      const context = createMockContext({ 
        userId: 'admin',
        isAdmin: true,
      });
      
      const input = { page: 1, limit: 10 };
      const result = await userProcedures.list.handler({ input, context });
      
      expect(result.success).toBe(true);
      expect(result.data.items).toHaveLength(2);
      expect(result.data.total).toBe(2);
    });
    
    it('should filter by search', async () => {
      await createTestUser({ name: 'John Doe' });
      await createTestUser({ name: 'Jane Smith' });
      
      const context = createMockContext({ 
        userId: 'admin',
        isAdmin: true,
      });
      
      const input = { 
        page: 1, 
        limit: 10,
        search: 'John',
      };
      
      const result = await userProcedures.list.handler({ input, context });
      
      expect(result.data.items).toHaveLength(1);
      expect(result.data.items[0].name).toBe('John Doe');
    });
    
    it('should reject non-admin users', async () => {
      const context = createMockContext({ 
        userId: 'user',
        isAdmin: false,
      });
      
      await expect(
        userProcedures.list.handler({ 
          input: { page: 1, limit: 10 }, 
          context,
        })
      ).rejects.toThrow(AppError);
    });
  });
});
```

### Schritt 4: Integration Tests - Post Procedures
Erstelle `packages/api/test/procedures/post.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { postProcedures } from '@/procedures/post';
import { createMockContext, createTestUser, createTestPost } from '../setup';

describe('Post Procedures', () => {
  describe('create', () => {
    it('should create a new post', async () => {
      const user = await createTestUser();
      const context = createMockContext({ userId: user.clerkId });
      
      const input = {
        title: 'New Post',
        content: 'This is the content',
        tags: ['test', 'vitest'],
        published: true,
      };
      
      const result = await postProcedures.create.handler({ input, context });
      
      expect(result.success).toBe(true);
      expect(result.data.title).toBe('New Post');
      expect(result.data.published).toBe(true);
      expect(result.data.tags).toHaveLength(2);
    });
    
    it('should generate unique slug', async () => {
      const user = await createTestUser();
      const context = createMockContext({ userId: user.clerkId });
      
      const input = {
        title: 'Duplicate Title',
        content: 'Content 1',
      };
      
      const result1 = await postProcedures.create.handler({ 
        input, 
        context,
      });
      
      const result2 = await postProcedures.create.handler({ 
        input, 
        context,
      });
      
      expect(result1.data.slug).not.toBe(result2.data.slug);
    });
  });
  
  describe('getBySlug', () => {
    it('should get published post', async () => {
      const user = await createTestUser();
      const post = await createTestPost(user.id, { 
        published: true,
        title: 'Published Post',
      });
      
      const context = createMockContext();
      const input = { slug: post.slug, incrementViews: true };
      
      const result = await postProcedures.getBySlug.handler({ 
        input, 
        context,
      });
      
      expect(result.success).toBe(true);
      expect(result.data.title).toBe('Published Post');
    });
    
    it('should allow author to see unpublished post', async () => {
      const user = await createTestUser();
      const post = await createTestPost(user.id, { 
        published: false,
      });
      
      const context = createMockContext({ userId: user.clerkId });
      const input = { slug: post.slug };
      
      const result = await postProcedures.getBySlug.handler({ 
        input, 
        context,
      });
      
      expect(result.success).toBe(true);
    });
    
    it('should not show unpublished post to others', async () => {
      const author = await createTestUser();
      const post = await createTestPost(author.id, { 
        published: false,
      });
      
      const otherUser = await createTestUser();
      const context = createMockContext({ userId: otherUser.clerkId });
      
      await expect(
        postProcedures.getBySlug.handler({ 
          input: { slug: post.slug }, 
          context,
        })
      ).rejects.toThrow();
    });
  });
  
  describe('update', () => {
    it('should update own post', async () => {
      const user = await createTestUser();
      const post = await createTestPost(user.id);
      
      const context = createMockContext({ userId: user.clerkId });
      const input = {
        id: post.id,
        title: 'Updated Title',
        published: true,
      };
      
      const result = await postProcedures.update.handler({ 
        input, 
        context,
      });
      
      expect(result.data.title).toBe('Updated Title');
      expect(result.data.published).toBe(true);
      expect(result.data.publishedAt).not.toBeNull();
    });
    
    it('should not update others post', async () => {
      const author = await createTestUser();
      const post = await createTestPost(author.id);
      
      const otherUser = await createTestUser();
      const context = createMockContext({ userId: otherUser.clerkId });
      
      await expect(
        postProcedures.update.handler({
          input: { id: post.id, title: 'Hacked' },
          context,
        })
      ).rejects.toThrow();
    });
  });
});
```

### Schritt 5: E2E Tests
Erstelle `test/e2e/api.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';

test.describe('API E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    // Sign in before each test
    await page.goto('/sign-in');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    await page.waitForURL('/dashboard');
  });
  
  test('should create and view post', async ({ page, request }) => {
    // Create post via API
    const response = await request.post('/api/rpc', {
      data: {
        path: 'post.create',
        input: {
          title: 'E2E Test Post',
          content: 'This is an E2E test',
          published: true,
        },
      },
    });
    
    const result = await response.json();
    expect(result.success).toBe(true);
    
    // View post on page
    await page.goto(`/posts/${result.data.slug}`);
    await expect(page.locator('h1')).toContainText('E2E Test Post');
  });
  
  test('should handle rate limiting', async ({ request }) => {
    // Make many requests quickly
    const promises = Array.from({ length: 150 }, () =>
      request.post('/api/rpc', {
        data: { path: 'health' },
      })
    );
    
    const responses = await Promise.all(promises);
    const rateLimited = responses.some(r => r.status() === 429);
    
    expect(rateLimited).toBe(true);
  });
  
  test('should update user profile', async ({ page, request }) => {
    // Update via API
    const response = await request.post('/api/rpc', {
      data: {
        path: 'user.updateProfile',
        input: {
          name: 'Updated E2E User',
          bio: 'E2E test bio',
        },
      },
    });
    
    expect(response.ok()).toBe(true);
    
    // Verify on profile page
    await page.goto('/profile');
    await expect(page.locator('[data-testid="user-name"]'))
      .toContainText('Updated E2E User');
  });
});
```

### Schritt 6: Test Utilities
Erstelle `packages/api/test/utils/factories.ts`:

```typescript
import { faker } from '@faker-js/faker';

/**
 * User factory
 */
export function createUserFactory(overrides = {}) {
  return {
    clerkId: faker.string.uuid(),
    email: faker.internet.email(),
    name: faker.person.fullName(),
    image: faker.image.avatar(),
    role: 'USER',
    status: 'ACTIVE',
    ...overrides,
  };
}

/**
 * Post factory
 */
export function createPostFactory(overrides = {}) {
  return {
    title: faker.lorem.sentence(),
    content: faker.lorem.paragraphs(3),
    excerpt: faker.lorem.paragraph(),
    published: faker.datatype.boolean(),
    tags: faker.lorem.words(3).split(' '),
    ...overrides,
  };
}

/**
 * Comment factory
 */
export function createCommentFactory(overrides = {}) {
  return {
    content: faker.lorem.paragraph(),
    ...overrides,
  };
}

/**
 * Batch factory
 */
export function createBatch<T>(
  factory: (index: number) => T,
  count: number
): T[] {
  return Array.from({ length: count }, (_, i) => factory(i));
}
```

### Schritt 7: Performance Tests
Erstelle `packages/api/test/performance/load.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { performance } from 'perf_hooks';
import { router } from '@/router';
import { createMockContext, createTestUser } from '../setup';

describe('Performance Tests', () => {
  it('should handle 100 concurrent requests', async () => {
    const user = await createTestUser();
    const context = createMockContext({ userId: user.clerkId });
    
    const start = performance.now();
    
    const promises = Array.from({ length: 100 }, () =>
      router.user.me.handler({ context })
    );
    
    const results = await Promise.all(promises);
    const duration = performance.now() - start;
    
    expect(results).toHaveLength(100);
    expect(results.every(r => r.success)).toBe(true);
    expect(duration).toBeLessThan(5000); // Should complete in 5 seconds
  });
  
  it('should handle large dataset queries', async () => {
    // Create 100 posts
    const user = await createTestUser();
    
    for (let i = 0; i < 100; i++) {
      await createTestPost(user.id, {
        title: `Post ${i}`,
        published: true,
      });
    }
    
    const context = createMockContext();
    const start = performance.now();
    
    const result = await router.post.list.handler({
      input: { page: 1, limit: 50 },
      context,
    });
    
    const duration = performance.now() - start;
    
    expect(result.data.items).toHaveLength(50);
    expect(duration).toBeLessThan(1000); // Should complete in 1 second
  });
});
```

### Schritt 8: Test Scripts
Update `package.json`:

```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:perf": "vitest run test/performance",
    "test:ci": "vitest run --coverage && playwright test"
  }
}
```

## Verifizierung

### Test 1: Run Unit Tests
```bash
cd packages/api
npm test

# Should run all tests and pass
```

### Test 2: Coverage Report
```bash
npm run test:coverage

# Should generate coverage report
# Aim for >80% coverage
```

### Test 3: E2E Tests
```bash
npm run test:e2e

# Should run Playwright tests
```

### Test 4: Performance Tests
```bash
npm run test:perf

# Should complete within thresholds
```

## Erfolgskriterien
- [ ] Unit Tests >80% Coverage
- [ ] Integration Tests funktionieren
- [ ] E2E Tests laufen durch
- [ ] Performance Tests bestehen
- [ ] Mock Data Generation verfügbar
- [ ] CI/CD Integration ready

## CI/CD Integration

### GitHub Actions Workflow
Erstelle `.github/workflows/api-tests.yml`:

```yaml
name: API Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm run test:ci
        env:
          DATABASE_URL: file:./test.db
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./packages/api/coverage/coverage-final.json
```

## Zusammenfassung

Die API Procedures sind jetzt vollständig implementiert mit:
- ✅ Context & Error Handling (07.01)
- ✅ Base Procedures & Middleware (07.02)
- ✅ User Management (07.03)
- ✅ Post/Blog System (07.04)
- ✅ Router Assembly (07.05)
- ✅ Client SDK (07.06)
- ✅ API Route Handler (07.07)
- ✅ Testing & Verifikation (07.08)

Das System bietet:
- Type-safe End-to-End API
- Authentication & Authorization
- Rate Limiting & Caching
- Comprehensive Test Coverage
- Production-ready Error Handling
- Monitoring & Logging Integration