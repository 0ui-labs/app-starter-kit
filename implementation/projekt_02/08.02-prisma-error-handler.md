# Arbeitspaket 08.02: Prisma Error Handler für oRPC

## Ziel
Implementierung eines spezialisierten Error Handlers, der Prisma-Datenbankfehler in benutzerfreundliche oRPC Errors übersetzt.

## Kontext
- **Database ORM**: Prisma
- **Error Framework**: oRPC Error System aus 08.01
- **Ziel**: Technische DB-Fehler in verständliche Meldungen übersetzen

## Implementierung

### Schritt 1: Prisma Error Handler
Erstelle `packages/api/src/errors/prisma-handler.ts`:

```typescript
import { Prisma } from '@starter-kit/db';
import { ORPCError } from '@orpc/server';

export function handlePrismaError(error: unknown): never {
  // Prisma Known Request Errors
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        // Unique constraint violation
        throw new ORPCError('DUPLICATE_RESOURCE', {
          message: 'Ein Eintrag mit diesen Daten existiert bereits',
          data: { field: error.meta?.target as string }
        });
        
      case 'P2025':
        // Record not found
        throw new ORPCError('NOT_FOUND', {
          message: 'Die angeforderte Ressource wurde nicht gefunden'
        });
        
      case 'P2003':
        // Foreign key constraint violation
        throw new ORPCError('VALIDATION_ERROR', {
          message: 'Referenzierte Daten existieren nicht',
          data: { field: error.meta?.field_name as string }
        });
        
      case 'P2011':
        // Null constraint violation
        throw new ORPCError('VALIDATION_ERROR', {
          message: 'Pflichtfeld fehlt',
          data: { field: error.meta?.constraint as string }
        });
        
      case 'P2014':
        // Relation violation
        throw new ORPCError('VALIDATION_ERROR', {
          message: 'Die Beziehung verletzt Einschränkungen',
          data: { field: error.meta?.relation_name as string }
        });
        
      default:
        throw new ORPCError('DATABASE_ERROR', {
          message: 'Datenbankfehler aufgetreten',
          data: { code: error.code }
        });
    }
  }
  
  // Prisma Validation Errors
  if (error instanceof Prisma.PrismaClientValidationError) {
    throw new ORPCError('VALIDATION_ERROR', {
      message: 'Ungültige Datenbankabfrage'
    });
  }
  
  // Prisma Initialization Errors
  if (error instanceof Prisma.PrismaClientInitializationError) {
    throw new ORPCError('DATABASE_ERROR', {
      message: 'Datenbankverbindung fehlgeschlagen'
    });
  }
  
  // Prisma Rust Panic Errors
  if (error instanceof Prisma.PrismaClientRustPanicError) {
    throw new ORPCError('INTERNAL_ERROR', {
      message: 'Kritischer Datenbankfehler'
    });
  }
  
  // Re-throw if already an ORPCError
  if (error instanceof ORPCError) {
    throw error;
  }
  
  // Generic Error
  throw new ORPCError('INTERNAL_ERROR', {
    message: error instanceof Error ? error.message : 'Ein unbekannter Fehler ist aufgetreten'
  });
}
```

### Schritt 2: Helper für spezifische Fehlertypen
Erweitere `packages/api/src/errors/prisma-handler.ts`:

```typescript
// Helper to check if error is a specific Prisma error
export function isPrismaError(error: unknown, code: string): boolean {
  return error instanceof Prisma.PrismaClientKnownRequestError && error.code === code;
}

// Helper to extract field name from Prisma error
export function getPrismaErrorField(error: unknown): string | undefined {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    return (error.meta?.target as string) || 
           (error.meta?.field_name as string) || 
           (error.meta?.constraint as string);
  }
  return undefined;
}

// Helper for handling unique constraint violations with custom messages
export function handleUniqueConstraint(
  error: unknown,
  fieldMessages: Record<string, string>
): never {
  if (isPrismaError(error, 'P2002')) {
    const field = getPrismaErrorField(error);
    const message = field && fieldMessages[field] 
      ? fieldMessages[field]
      : 'Dieser Wert existiert bereits';
    
    throw new ORPCError('DUPLICATE_RESOURCE', {
      message,
      data: { field }
    });
  }
  
  // If not a unique constraint error, pass through to general handler
  handlePrismaError(error);
}
```

### Schritt 3: Transactional Error Handler
Erweitere `packages/api/src/errors/prisma-handler.ts`:

```typescript
// Wrapper for Prisma transactions with automatic error handling
export async function withPrismaTransaction<T>(
  fn: (tx: any) => Promise<T>,
  db: any
): Promise<T> {
  try {
    return await db.$transaction(fn);
  } catch (error) {
    handlePrismaError(error);
  }
}
```

## Verwendung

### Beispiel 1: In API Procedure
```typescript
import { handlePrismaError } from './errors/prisma-handler';

export const createUser = baseRouter
  .procedure('user.create')
  .input(z.object({
    email: z.string().email(),
    name: z.string(),
  }))
  .handler(async ({ input }) => {
    try {
      return await db.user.create({ data: input });
    } catch (error) {
      handlePrismaError(error);
    }
  });
```

### Beispiel 2: Mit Custom Messages
```typescript
import { handleUniqueConstraint } from './errors/prisma-handler';

try {
  await db.user.create({ data: input });
} catch (error) {
  handleUniqueConstraint(error, {
    email: 'Diese E-Mail-Adresse ist bereits registriert',
    username: 'Dieser Benutzername ist bereits vergeben'
  });
}
```

## Verifizierung

### Test 1: Unique Constraint
```typescript
// Erstelle zwei User mit gleicher Email
await db.user.create({ data: { email: 'test@test.com' } });
await db.user.create({ data: { email: 'test@test.com' } });
// Sollte DUPLICATE_RESOURCE Error werfen
```

### Test 2: Not Found
```typescript
await db.user.update({
  where: { id: 'non-existent' },
  data: { name: 'Test' }
});
// Sollte NOT_FOUND Error werfen
```

### Test 3: Foreign Key Constraint
```typescript
await db.post.create({
  data: { 
    title: 'Test',
    authorId: 'non-existent-user'
  }
});
// Sollte VALIDATION_ERROR werfen
```

## Erfolgskriterien
- [ ] Alle Prisma Error Codes abgedeckt
- [ ] Benutzerfreundliche deutsche Meldungen
- [ ] Helper Functions für häufige Fälle
- [ ] Transactional Error Handling
- [ ] Field-spezifische Fehlermeldungen

## Potentielle Probleme

### Problem: Prisma Meta Informationen fehlen
**Lösung**: Fallback auf generische Meldungen wenn meta undefined

### Problem: Error Code Changes in Prisma Updates
**Lösung**: Default case für unbekannte Codes

## Zeitschätzung
- Haupthandler: 10 Minuten
- Helper Functions: 5 Minuten
- Total: 15 Minuten