# Sub-Task 12.10: Error Handling Patterns

## Ziel
Implementierung robuster Error Handling Patterns für alle Provider.

## Umfang
- Error Types Definition
- Provider-spezifisches Error Mapping
- Retry Strategies
- Fallback Triggers
- User-friendly Error Messages

## Error Types

### AIError Interface
```typescript
interface AIError extends Error {
  provider: AIProvider;
  statusCode?: number;
  response?: any;
  retryable: boolean;
  type?: 'rate_limit' | 'invalid_request' | 
         'authentication' | 'server_error' | 'timeout';
}
```

## Provider-spezifische Error Handling

### OpenAI Errors
```typescript
if (error instanceof OpenAI.APIError) {
  // 429: Rate Limit -> retryable
  // 401: Auth Error -> not retryable
  // 500+: Server Error -> retryable
  // 400: Bad Request -> not retryable
}
```

### Anthropic Errors
```typescript
if (error.status) {
  // Similar mapping wie OpenAI
  // Anthropic-spezifische Error Codes
}
```

### Google Errors
```typescript
// Message-basierte Error Detection
if (message.includes('429')) // Rate limit
if (message.includes('401')) // Auth error
```

## Retry Strategies

### Exponential Backoff
```typescript
async function retryWithBackoff(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (!error.retryable) throw error;
      await sleep(Math.pow(2, i) * 1000);
    }
  }
}
```

### Rate Limit Handling
```typescript
catch (error) {
  if (error.type === 'rate_limit') {
    // Wait und retry
    // Oder Fallback zu anderem Provider
  }
}
```

## Fallback Decision Logic

### Wann Fallback triggern?
1. Rate Limit Errors -> Ja
2. Server Errors (5xx) -> Ja
3. Timeout Errors -> Ja
4. Auth Errors -> Nein
5. Invalid Request -> Nein

### Fallback Chain
```typescript
for (const provider of providers) {
  try {
    return await provider.complete(options);
  } catch (error) {
    if (!shouldFallback(error)) throw error;
    lastError = error;
  }
}
throw lastError;
```

## User-Friendly Error Messages

### Error Message Mapping
```typescript
const getUserMessage = (error: AIError): string => {
  switch(error.type) {
    case 'rate_limit':
      return 'Too many requests. Please try again later.';
    case 'authentication':
      return 'Invalid API key. Please check your configuration.';
    case 'server_error':
      return 'Service temporarily unavailable.';
    default:
      return 'An error occurred. Please try again.';
  }
};
```

## Error Recovery Patterns

### Graceful Degradation
```typescript
try {
  // Try with advanced model
  return await ai.complete({ 
    model: 'gpt-4o', 
    ...options 
  });
} catch {
  // Fallback to simpler model
  return await ai.complete({ 
    model: 'gpt-3.5-turbo', 
    ...options 
  });
}
```

### Context Reduction
```typescript
catch (error) {
  if (error.message.includes('context length')) {
    // Reduce message context
    const truncated = AIAdapter.truncateMessages(
      messages, 
      maxTokens / 2
    );
    return await ai.complete({ 
      messages: truncated 
    });
  }
}
```

## Monitoring & Logging

### Error Tracking
```typescript
const logError = (error: AIError) => {
  console.error({
    provider: error.provider,
    type: error.type,
    statusCode: error.statusCode,
    timestamp: new Date().toISOString()
  });
};
```

## Verifizierung
- [ ] Alle Error Types definiert
- [ ] Provider Mapping vollständig
- [ ] Retry Logic implementiert
- [ ] Fallback Entscheidungen klar
- [ ] User Messages hilfreich

## Zeitschätzung
- 15 Minuten