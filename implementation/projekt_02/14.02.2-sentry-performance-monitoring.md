# Sub-Task 14.02.2: Sentry Performance Monitoring

## Ziel
Implementierung von Performance Monitoring mit Sentry fÃ¼r Next.js 15 App Router. Tracking von Web Vitals, API Routes Performance, Server Components Rendering und Database Queries.

## Voraussetzungen
- Sentry Base Setup abgeschlossen (14.02.1)
- Next.js 15 App mit App Router
- Sentry Performance Monitoring Add-on aktiviert

## Umfang
- Web Vitals Tracking (LCP, FID, CLS, TTFB, INP)
- Custom Performance Transactions
- API Route Performance Monitoring
- Database Query Tracking
- Server Component Performance
- Client Component Hydration Tracking
- Custom Spans und Measurements

## Implementierung

### 1. Performance Configuration Update

`apps/web/sentry.client.config.ts` (Erweiterung):
```typescript
import * as Sentry from '@sentry/nextjs';
import { browserTracingIntegration } from '@sentry/nextjs';

Sentry.init({
  // ... existing config
  
  // Performance Monitoring
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  
  // Profiles sample rate (requires tracing)
  profilesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  
  integrations: [
    // ... existing integrations
    
    // Browser Tracing with custom options
    browserTracingIntegration({
      // Track long tasks
      enableLongTask: true,
      
      // Track interactions
      enableInteractions: true,
      
      // Track INP (Interaction to Next Paint)
      enableInp: true,
      
      // Custom routing instrumentation for App Router
      routingInstrumentation: Sentry.nextRouterInstrumentation,
      
      // Track slow navigation
      beforeNavigate: (context) => {
        return {
          ...context,
          tags: {
            ...context.tags,
            'routing.instrumentation': 'next-app-router',
          },
        };
      },
      
      // Idle timeout
      idleTimeout: 5000,
      
      // Max transaction duration
      finalTimeout: 30000,
    }),
  ],
  
  // Custom tracing options
  tracePropagationTargets: [
    'localhost',
    /^https:\/\/yourapp\.com\/api/,
  ],
  
  // Track specific interactions
  beforeSendTransaction(transaction) {
    // Add custom data to transactions
    if (transaction.transaction?.includes('/api/')) {
      transaction.tags = {
        ...transaction.tags,
        'transaction.type': 'api',
      };
    }
    
    // Sample expensive transactions less frequently
    if (transaction.transaction === '/api/expensive-operation') {
      // Only send 1% of these transactions
      if (Math.random() > 0.01) {
        return null;
      }
    }
    
    return transaction;
  },
});
```

### 2. Web Vitals Tracking

`apps/web/src/app/layout.tsx`:
```typescript
import { WebVitalsReporter } from '@/components/monitoring/web-vitals-reporter';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="de">
      <body>
        <WebVitalsReporter />
        {children}
      </body>
    </html>
  );
}
```

`apps/web/src/components/monitoring/web-vitals-reporter.tsx`:
```typescript
'use client';

import { useEffect } from 'react';
import { onCLS, onFID, onLCP, onTTFB, onINP, onFCP, Metric } from 'web-vitals';
import * as Sentry from '@sentry/nextjs';

function sendToSentry(metric: Metric) {
  const transaction = Sentry.getCurrentScope().getTransaction();
  
  if (!transaction) {
    // Create a new transaction for web vitals
    const webVitalTransaction = Sentry.startTransaction({
      name: 'web-vitals',
      op: 'web-vitals',
      tags: {
        'web-vital.name': metric.name,
        'web-vital.id': metric.id,
      },
    });
    
    webVitalTransaction.setMeasurement(
      metric.name,
      metric.value,
      metric.name === 'CLS' ? '' : 'millisecond'
    );
    
    webVitalTransaction.finish();
  } else {
    // Add to existing transaction
    transaction.setMeasurement(
      metric.name,
      metric.value,
      metric.name === 'CLS' ? '' : 'millisecond'
    );
  }
  
  // Also send as custom event for detailed tracking
  Sentry.addBreadcrumb({
    category: 'web-vitals',
    message: `${metric.name}: ${metric.value}`,
    level: 'info',
    data: {
      value: metric.value,
      rating: metric.rating,
      delta: metric.delta,
      id: metric.id,
      navigationType: metric.navigationType,
    },
  });
  
  // Log poor performance
  if (metric.rating === 'poor') {
    Sentry.captureMessage(
      `Poor ${metric.name} performance: ${metric.value}`,
      'warning'
    );
  }
}

export function WebVitalsReporter() {
  useEffect(() => {
    // Core Web Vitals
    onCLS(sendToSentry);
    onFID(sendToSentry);
    onLCP(sendToSentry);
    
    // Additional metrics
    onTTFB(sendToSentry);
    onINP(sendToSentry);
    onFCP(sendToSentry);
  }, []);
  
  return null;
}
```

### 3. API Route Performance Monitoring

`apps/web/src/lib/monitoring/performance.ts`:
```typescript
import * as Sentry from '@sentry/nextjs';
import { NextRequest } from 'next/server';

/**
 * Wrap API route handler with performance monitoring
 */
export function withPerformance<T extends (...args: any[]) => any>(
  handler: T,
  options?: {
    op?: string;
    description?: string;
    tags?: Record<string, string>;
  }
): T {
  return (async (...args: Parameters<T>) => {
    const transaction = Sentry.startTransaction({
      op: options?.op || 'api.request',
      name: options?.description || handler.name || 'api-handler',
      tags: options?.tags,
    });
    
    Sentry.getCurrentScope().setSpan(transaction);
    
    try {
      const result = await handler(...args);
      transaction.setStatus('ok');
      return result;
    } catch (error) {
      transaction.setStatus('internal_error');
      throw error;
    } finally {
      transaction.finish();
    }
  }) as T;
}

/**
 * Create a custom span for specific operations
 */
export async function withSpan<T>(
  operation: string,
  description: string,
  callback: () => Promise<T>,
  data?: Record<string, any>
): Promise<T> {
  const transaction = Sentry.getCurrentScope().getTransaction();
  const span = transaction?.startChild({
    op: operation,
    description,
    data,
  });
  
  try {
    const result = await callback();
    span?.setStatus('ok');
    return result;
  } catch (error) {
    span?.setStatus('internal_error');
    throw error;
  } finally {
    span?.finish();
  }
}

/**
 * Measure function execution time
 */
export function measurePerformance(name: string, value: number, unit: string = 'millisecond') {
  const transaction = Sentry.getCurrentScope().getTransaction();
  transaction?.setMeasurement(name, value, unit);
}
```

### 4. Database Query Tracking

`apps/web/src/lib/monitoring/db-instrumentation.ts`:
```typescript
import * as Sentry from '@sentry/nextjs';
import { PrismaClient } from '@starter-kit/db';

/**
 * Instrument Prisma client for performance monitoring
 */
export function instrumentPrisma(prisma: PrismaClient) {
  prisma.$use(async (params, next) => {
    const transaction = Sentry.getCurrentScope().getTransaction();
    
    const span = transaction?.startChild({
      op: 'db.query',
      description: `${params.model}.${params.action}`,
      data: {
        'db.system': 'postgresql',
        'db.operation': params.action,
        'db.model': params.model,
      },
    });
    
    const startTime = Date.now();
    
    try {
      const result = await next(params);
      
      const duration = Date.now() - startTime;
      span?.setData('db.duration', duration);
      
      // Log slow queries
      if (duration > 1000) {
        Sentry.addBreadcrumb({
          category: 'db',
          message: `Slow query: ${params.model}.${params.action} took ${duration}ms`,
          level: 'warning',
          data: {
            model: params.model,
            action: params.action,
            duration,
          },
        });
      }
      
      span?.setStatus('ok');
      return result;
    } catch (error) {
      span?.setStatus('internal_error');
      throw error;
    } finally {
      span?.finish();
    }
  });
  
  return prisma;
}
```

### 5. Server Component Performance

`apps/web/src/lib/monitoring/server-component-performance.ts`:
```typescript
import * as Sentry from '@sentry/nextjs';
import { cache } from 'react';

/**
 * Wrap server component data fetching with performance monitoring
 */
export function withServerComponentPerformance<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  name: string
): T {
  return cache(async (...args: Parameters<T>) => {
    const transaction = Sentry.startTransaction({
      op: 'server.component',
      name: `ServerComponent: ${name}`,
    });
    
    Sentry.getCurrentScope().setSpan(transaction);
    
    try {
      const startTime = Date.now();
      const result = await fn(...args);
      
      transaction.setMeasurement(
        'server.component.duration',
        Date.now() - startTime,
        'millisecond'
      );
      
      transaction.setStatus('ok');
      return result;
    } catch (error) {
      transaction.setStatus('internal_error');
      throw error;
    } finally {
      transaction.finish();
    }
  }) as T;
}

/**
 * Track server component rendering
 */
export async function trackServerRender<T>(
  componentName: string,
  renderFn: () => Promise<T>
): Promise<T> {
  return withSpan(
    'server.render',
    `Render ${componentName}`,
    renderFn,
    { component: componentName }
  );
}
```

### 6. Client Component Hydration Tracking

`apps/web/src/hooks/use-hydration-performance.ts`:
```typescript
'use client';

import { useEffect, useRef } from 'react';
import * as Sentry from '@sentry/nextjs';

export function useHydrationPerformance(componentName: string) {
  const hydrationStartRef = useRef<number>();
  const isHydratedRef = useRef(false);
  
  useEffect(() => {
    if (!isHydratedRef.current) {
      hydrationStartRef.current = performance.now();
    }
  }, []);
  
  useEffect(() => {
    if (!isHydratedRef.current && hydrationStartRef.current) {
      const hydrationTime = performance.now() - hydrationStartRef.current;
      
      const transaction = Sentry.getCurrentScope().getTransaction();
      transaction?.setMeasurement(
        `hydration.${componentName}`,
        hydrationTime,
        'millisecond'
      );
      
      // Log slow hydration
      if (hydrationTime > 500) {
        Sentry.addBreadcrumb({
          category: 'hydration',
          message: `Slow hydration for ${componentName}: ${hydrationTime}ms`,
          level: 'warning',
          data: {
            component: componentName,
            duration: hydrationTime,
          },
        });
      }
      
      isHydratedRef.current = true;
    }
  });
}
```

### 7. Custom Performance Monitoring Hook

`apps/web/src/hooks/use-performance-monitoring.ts`:
```typescript
'use client';

import { useEffect, useRef } from 'react';
import { usePathname } from 'next/navigation';
import * as Sentry from '@sentry/nextjs';

interface PerformanceMetrics {
  navigationStart: number;
  firstPaint?: number;
  firstContentfulPaint?: number;
  domInteractive?: number;
  domComplete?: number;
  loadComplete?: number;
}

export function usePerformanceMonitoring() {
  const pathname = usePathname();
  const metricsRef = useRef<PerformanceMetrics>();
  
  useEffect(() => {
    const startTime = performance.now();
    metricsRef.current = { navigationStart: startTime };
    
    const transaction = Sentry.startTransaction({
      op: 'navigation',
      name: pathname,
      tags: {
        'navigation.type': 'client-side',
      },
    });
    
    // Track First Paint
    const paintObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name === 'first-paint') {
          metricsRef.current!.firstPaint = entry.startTime;
          transaction.setMeasurement('first-paint', entry.startTime, 'millisecond');
        } else if (entry.name === 'first-contentful-paint') {
          metricsRef.current!.firstContentfulPaint = entry.startTime;
          transaction.setMeasurement('first-contentful-paint', entry.startTime, 'millisecond');
        }
      }
    });
    
    paintObserver.observe({ type: 'paint', buffered: true });
    
    // Track DOM events
    const handleDOMContentLoaded = () => {
      const time = performance.now() - startTime;
      metricsRef.current!.domInteractive = time;
      transaction.setMeasurement('dom-interactive', time, 'millisecond');
    };
    
    const handleLoad = () => {
      const time = performance.now() - startTime;
      metricsRef.current!.loadComplete = time;
      transaction.setMeasurement('load-complete', time, 'millisecond');
      transaction.finish();
    };
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', handleDOMContentLoaded);
    } else {
      handleDOMContentLoaded();
    }
    
    if (document.readyState !== 'complete') {
      window.addEventListener('load', handleLoad);
    } else {
      handleLoad();
    }
    
    return () => {
      paintObserver.disconnect();
      document.removeEventListener('DOMContentLoaded', handleDOMContentLoaded);
      window.removeEventListener('load', handleLoad);
    };
  }, [pathname]);
  
  return metricsRef.current;
}
```

### 8. API Route Example with Performance

`apps/web/src/app/api/posts/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withPerformance, withSpan, measurePerformance } from '@/lib/monitoring/performance';
import { prisma } from '@starter-kit/db';
import * as Sentry from '@sentry/nextjs';

export const GET = withPerformance(
  async (request: NextRequest) => {
    const searchParams = request.nextUrl.searchParams;
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    
    // Track query parameters
    Sentry.getCurrentScope().setContext('query', {
      page,
      limit,
    });
    
    // Fetch posts with performance tracking
    const posts = await withSpan(
      'db.query',
      'Fetch posts with pagination',
      async () => {
        const startTime = Date.now();
        
        const [items, count] = await Promise.all([
          prisma.post.findMany({
            skip: (page - 1) * limit,
            take: limit,
            include: {
              author: true,
              tags: true,
            },
          }),
          prisma.post.count(),
        ]);
        
        // Measure query time
        measurePerformance('posts.query.duration', Date.now() - startTime);
        measurePerformance('posts.count', count, 'none');
        
        return { items, count };
      }
    );
    
    // Process data with performance tracking
    const processedPosts = await withSpan(
      'data.processing',
      'Process posts data',
      async () => {
        return posts.items.map(post => ({
          ...post,
          excerpt: post.content.substring(0, 200),
        }));
      }
    );
    
    return NextResponse.json({
      posts: processedPosts,
      total: posts.count,
      page,
      limit,
    });
  },
  {
    op: 'api.posts.list',
    description: 'GET /api/posts',
    tags: {
      'api.version': 'v1',
    },
  }
);
```

### 9. Performance Dashboard Component

`apps/web/src/components/monitoring/performance-dashboard.tsx`:
```typescript
'use client';

import { useState, useEffect } from 'react';
import * as Sentry from '@sentry/nextjs';

interface PerformanceData {
  transactions: number;
  averageResponseTime: number;
  errorRate: number;
  slowTransactions: string[];
}

export function PerformanceDashboard() {
  const [data, setData] = useState<PerformanceData | null>(null);
  
  useEffect(() => {
    // This would typically fetch from your monitoring API
    // For demo, we'll use Sentry's client-side data
    const scope = Sentry.getCurrentScope();
    const client = Sentry.getClient();
    
    if (client) {
      // Get performance metrics from Sentry
      // This is a simplified example
      setData({
        transactions: 0,
        averageResponseTime: 0,
        errorRate: 0,
        slowTransactions: [],
      });
    }
  }, []);
  
  if (!data) return null;
  
  return (
    <div className="p-4 bg-gray-100 rounded-lg">
      <h3 className="text-lg font-semibold mb-4">Performance Metrics</h3>
      <div className="grid grid-cols-2 gap-4">
        <div>
          <p className="text-sm text-gray-600">Transactions</p>
          <p className="text-2xl font-bold">{data.transactions}</p>
        </div>
        <div>
          <p className="text-sm text-gray-600">Avg Response Time</p>
          <p className="text-2xl font-bold">{data.averageResponseTime}ms</p>
        </div>
        <div>
          <p className="text-sm text-gray-600">Error Rate</p>
          <p className="text-2xl font-bold">{data.errorRate}%</p>
        </div>
        <div>
          <p className="text-sm text-gray-600">Slow Transactions</p>
          <p className="text-2xl font-bold">{data.slowTransactions.length}</p>
        </div>
      </div>
    </div>
  );
}
```

## Testing Performance Monitoring

### Test Component

```typescript
// app/test-performance/page.tsx
'use client';

import { useState } from 'react';
import { usePerformanceMonitoring } from '@/hooks/use-performance-monitoring';
import { useHydrationPerformance } from '@/hooks/use-hydration-performance';
import * as Sentry from '@sentry/nextjs';

export default function TestPerformance() {
  usePerformanceMonitoring();
  useHydrationPerformance('TestPerformance');
  
  const [loading, setLoading] = useState(false);
  
  const testSlowOperation = async () => {
    setLoading(true);
    
    const transaction = Sentry.startTransaction({
      op: 'test.slow-operation',
      name: 'Test Slow Operation',
    });
    
    try {
      // Simulate slow operation
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      transaction.setMeasurement('operation.duration', 2000, 'millisecond');
      transaction.setStatus('ok');
    } catch (error) {
      transaction.setStatus('internal_error');
    } finally {
      transaction.finish();
      setLoading(false);
    }
  };
  
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-4">Performance Monitoring Test</h1>
      
      <button
        onClick={testSlowOperation}
        disabled={loading}
        className="px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
      >
        {loading ? 'Processing...' : 'Test Slow Operation'}
      </button>
      
      <div className="mt-8">
        <h2 className="text-lg font-semibold mb-2">Instructions:</h2>
        <ol className="list-decimal list-inside space-y-2">
          <li>Open Sentry Dashboard</li>
          <li>Navigate to Performance section</li>
          <li>Click the button above</li>
          <li>Check for the "Test Slow Operation" transaction</li>
          <li>Verify Web Vitals are being tracked</li>
        </ol>
      </div>
    </div>
  );
}
```

## Erfolgskriterien
- [ ] Web Vitals werden getrackt (LCP, FID, CLS, etc.)
- [ ] API Route Performance wird gemessen
- [ ] Database Queries werden getrackt
- [ ] Server Component Performance sichtbar
- [ ] Client Hydration wird gemessen
- [ ] Custom Transactions funktionieren
- [ ] Slow Operations werden geloggt
- [ ] Performance Daten in Sentry Dashboard sichtbar
- [ ] Sampling Rates korrekt konfiguriert

## ZeitschÃ¤tzung
- **Total: 30 Minuten**
  - Web Vitals Setup: 5 Min
  - Performance Utilities: 8 Min
  - Database Instrumentation: 5 Min
  - Component Tracking: 7 Min
  - Testing und Verifikation: 5 Min

## NÃ¤chster Schritt
Nach Performance Monitoring â [14.02.3 Session Replay](./14.02.3-sentry-session-replay.md)