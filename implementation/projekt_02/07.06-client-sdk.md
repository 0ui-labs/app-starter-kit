# Arbeitspaket 07.06: Client SDK

## Ziel
Implementierung eines Type-safe Client SDK für Frontend-Integration mit React Hooks und Optimistic Updates.

## Kontext
- oRPC Client Setup
- React Query Integration
- Type-safe API Calls
- Error Handling
- Caching Strategy

## Implementierung

### Schritt 1: Base Client Setup
Erstelle `packages/api/src/client.ts`:

```typescript
import { createORPCClient, FetchTransport } from '@orpc/client';
import type { AppRouter } from './router';

/**
 * Client configuration options
 */
export interface ClientConfig {
  baseURL?: string;
  headers?: HeadersInit | (() => HeadersInit | Promise<HeadersInit>);
  onError?: (error: any) => void;
  onRequest?: (url: string, options: RequestInit) => void;
  onResponse?: (response: Response) => void;
}

/**
 * Create API client instance
 */
export function createAPIClient(config: ClientConfig = {}) {
  const {
    baseURL = '/api/rpc',
    headers,
    onError,
    onRequest,
    onResponse,
  } = config;

  const transport = new FetchTransport({
    url: baseURL,
    headers: typeof headers === 'function' ? headers : () => headers || {},
    fetch: async (url, options) => {
      // Pre-request hook
      onRequest?.(url.toString(), options as RequestInit);
      
      try {
        const response = await fetch(url, options);
        
        // Post-response hook
        onResponse?.(response);
        
        if (!response.ok) {
          const error = await response.json().catch(() => ({
            message: `HTTP ${response.status}: ${response.statusText}`,
          }));
          
          onError?.(error);
          throw error;
        }
        
        return response;
      } catch (error) {
        onError?.(error);
        throw error;
      }
    },
  });

  return createORPCClient<AppRouter>(transport);
}

/**
 * Type-safe API client type
 */
export type APIClient = ReturnType<typeof createAPIClient>;
```

### Schritt 2: React Hooks
Erstelle `packages/api/src/hooks.tsx`:

```typescript
import { 
  useQuery, 
  useMutation, 
  useQueryClient,
  type UseQueryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';
import { createContext, useContext, type ReactNode } from 'react';
import { createAPIClient, type APIClient, type ClientConfig } from './client';
import type { AppRouter, RouterOutput, RouterInput } from './router';

/**
 * API Context
 */
const APIContext = createContext<APIClient | null>(null);

/**
 * API Provider Component
 */
export function APIProvider({ 
  children,
  config,
}: { 
  children: ReactNode;
  config?: ClientConfig;
}) {
  const client = createAPIClient(config);
  
  return (
    <APIContext.Provider value={client}>
      {children}
    </APIContext.Provider>
  );
}

/**
 * Use API client hook
 */
export function useAPI() {
  const client = useContext(APIContext);
  
  if (!client) {
    throw new Error('useAPI must be used within APIProvider');
  }
  
  return client;
}

/**
 * Generic query hook
 */
export function useAPIQuery<TPath extends string>(
  path: TPath,
  input?: RouterInput<AppRouter, TPath>,
  options?: Omit<
    UseQueryOptions<RouterOutput<AppRouter, TPath>>,
    'queryKey' | 'queryFn'
  >
) {
  const api = useAPI();
  
  return useQuery({
    queryKey: [path, input],
    queryFn: async () => {
      // Dynamic path resolution
      const pathParts = path.split('.');
      let current: any = api;
      
      for (const part of pathParts) {
        current = current[part];
      }
      
      return current(input);
    },
    ...options,
  });
}

/**
 * Generic mutation hook
 */
export function useAPIMutation<TPath extends string>(
  path: TPath,
  options?: UseMutationOptions<
    RouterOutput<AppRouter, TPath>,
    Error,
    RouterInput<AppRouter, TPath>
  >
) {
  const api = useAPI();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (input: RouterInput<AppRouter, TPath>) => {
      // Dynamic path resolution
      const pathParts = path.split('.');
      let current: any = api;
      
      for (const part of pathParts) {
        current = current[part];
      }
      
      return current(input);
    },
    onSuccess: (data, variables, context) => {
      // Invalidate related queries
      const pathParts = path.split('.');
      const resource = pathParts[0];
      
      // Invalidate list queries
      queryClient.invalidateQueries({ queryKey: [`${resource}.list`] });
      
      // Call original onSuccess
      options?.onSuccess?.(data, variables, context);
    },
    ...options,
  });
}

/**
 * Specific hooks for better DX
 */

// User hooks
export const useCurrentUser = (options?: UseQueryOptions) =>
  useAPIQuery('user.me', undefined, options);

export const useUpdateProfile = (options?: UseMutationOptions) =>
  useAPIMutation('user.updateProfile', options);

export const useUsers = (
  input: RouterInput<AppRouter, 'user.list'>,
  options?: UseQueryOptions
) => useAPIQuery('user.list', input, options);

// Post hooks
export const usePosts = (
  input: RouterInput<AppRouter, 'post.list'>,
  options?: UseQueryOptions
) => useAPIQuery('post.list', input, options);

export const usePost = (
  slug: string,
  options?: UseQueryOptions
) => useAPIQuery('post.getBySlug', { slug }, options);

export const useCreatePost = (options?: UseMutationOptions) =>
  useAPIMutation('post.create', options);

export const useUpdatePost = (options?: UseMutationOptions) =>
  useAPIMutation('post.update', options);

export const useDeletePost = (options?: UseMutationOptions) =>
  useAPIMutation('post.delete', {
    ...options,
    onSuccess: (data, variables, context) => {
      const queryClient = useQueryClient();
      
      // Remove from cache
      queryClient.removeQueries({ 
        queryKey: ['post.getBySlug', { slug: variables.id }] 
      });
      
      // Invalidate lists
      queryClient.invalidateQueries({ queryKey: ['post.list'] });
      
      options?.onSuccess?.(data, variables, context);
    },
  });

export const useToggleLike = (options?: UseMutationOptions) =>
  useAPIMutation('post.toggleLike', {
    ...options,
    onMutate: async (variables) => {
      const queryClient = useQueryClient();
      
      // Optimistic update
      const previousPost = queryClient.getQueryData([
        'post.getBySlug',
        { slug: variables.postId },
      ]);
      
      if (previousPost) {
        queryClient.setQueryData(
          ['post.getBySlug', { slug: variables.postId }],
          (old: any) => ({
            ...old,
            data: {
              ...old.data,
              likes: old.data.liked 
                ? old.data.likes - 1 
                : old.data.likes + 1,
              liked: !old.data.liked,
            },
          })
        );
      }
      
      return { previousPost };
    },
    onError: (err, variables, context) => {
      const queryClient = useQueryClient();
      
      // Revert optimistic update
      if (context?.previousPost) {
        queryClient.setQueryData(
          ['post.getBySlug', { slug: variables.postId }],
          context.previousPost
        );
      }
      
      options?.onError?.(err, variables, context);
    },
  });

// Comment hooks
export const useComments = (
  postId: string,
  options?: UseQueryOptions
) => useAPIQuery('comment.listByPost', { postId }, options);

export const useCreateComment = (options?: UseMutationOptions) =>
  useAPIMutation('comment.create', {
    ...options,
    onSuccess: (data, variables, context) => {
      const queryClient = useQueryClient();
      
      // Add to comments list
      queryClient.setQueryData(
        ['comment.listByPost', { postId: variables.postId }],
        (old: any) => ({
          ...old,
          data: {
            ...old.data,
            items: [data.data, ...old.data.items],
            total: old.data.total + 1,
          },
        })
      );
      
      options?.onSuccess?.(data, variables, context);
    },
  });

// Tag hooks
export const useTags = (options?: UseQueryOptions) =>
  useAPIQuery('tag.list', {}, options);

export const usePopularTags = (options?: UseQueryOptions) =>
  useAPIQuery('tag.popular', {}, options);
```

### Schritt 3: Utility Functions
Erstelle `packages/api/src/utils/client.ts`:

```typescript
import type { AppRouter, RouterOutput } from '../router';

/**
 * Extract success data from API response
 */
export function extractData<T extends { success: boolean; data: any }>(
  response: T
): T extends { success: true; data: infer D } ? D : never {
  if (!response.success) {
    throw new Error('API request failed');
  }
  return response.data;
}

/**
 * Pagination helpers
 */
export interface PaginationState {
  page: number;
  limit: number;
}

export function usePagination(initialState: PaginationState = { page: 1, limit: 10 }) {
  const [state, setState] = React.useState(initialState);
  
  const setPage = (page: number) => setState(prev => ({ ...prev, page }));
  const setLimit = (limit: number) => setState(prev => ({ ...prev, limit: 1 }));
  const nextPage = () => setState(prev => ({ ...prev, page: prev.page + 1 }));
  const prevPage = () => setState(prev => ({ ...prev, page: Math.max(1, prev.page - 1) }));
  
  return {
    ...state,
    setPage,
    setLimit,
    nextPage,
    prevPage,
  };
}

/**
 * Infinite scroll helper
 */
export function useInfiniteScroll<T>(
  queryKey: string[],
  fetchFn: (page: number) => Promise<{ items: T[]; hasMore: boolean }>
) {
  const [items, setItems] = React.useState<T[]>([]);
  const [page, setPage] = React.useState(1);
  const [hasMore, setHasMore] = React.useState(true);
  const [loading, setLoading] = React.useState(false);
  
  const loadMore = async () => {
    if (loading || !hasMore) return;
    
    setLoading(true);
    try {
      const result = await fetchFn(page);
      setItems(prev => [...prev, ...result.items]);
      setHasMore(result.hasMore);
      setPage(prev => prev + 1);
    } finally {
      setLoading(false);
    }
  };
  
  return {
    items,
    hasMore,
    loading,
    loadMore,
  };
}

/**
 * Debounced search helper
 */
export function useDebouncedValue<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = React.useState(value);
  
  React.useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [value, delay]);
  
  return debouncedValue;
}
```

### Schritt 4: Example Usage Component
Erstelle `packages/api/examples/usage.tsx`:

```typescript
import React from 'react';
import { 
  APIProvider,
  useCurrentUser,
  usePosts,
  useCreatePost,
  useToggleLike,
  useDebouncedValue,
} from '@starter-kit/api/hooks';

/**
 * Example: User Profile Component
 */
function UserProfile() {
  const { data: user, isLoading, error } = useCurrentUser();
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user?.data) return <div>Not logged in</div>;
  
  return (
    <div>
      <h1>{user.data.name}</h1>
      <p>{user.data.email}</p>
    </div>
  );
}

/**
 * Example: Posts List with Search
 */
function PostsList() {
  const [search, setSearch] = React.useState('');
  const debouncedSearch = useDebouncedValue(search);
  
  const { data, isLoading } = usePosts({
    page: 1,
    limit: 10,
    search: debouncedSearch,
    published: true,
  });
  
  const { mutate: toggleLike } = useToggleLike({
    onSuccess: (result) => {
      console.log('Like toggled:', result.data.liked);
    },
  });
  
  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search posts..."
      />
      
      {isLoading && <div>Loading...</div>}
      
      {data?.data.items.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
          <button onClick={() => toggleLike({ postId: post.id })}>
            {post.liked ? 'Unlike' : 'Like'} ({post.likes})
          </button>
        </article>
      ))}
    </div>
  );
}

/**
 * Example: Create Post Form
 */
function CreatePostForm() {
  const { mutate: createPost, isLoading } = useCreatePost({
    onSuccess: (result) => {
      console.log('Post created:', result.data);
      // Redirect to post
      window.location.href = `/posts/${result.data.slug}`;
    },
    onError: (error) => {
      console.error('Failed to create post:', error);
    },
  });
  
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    
    createPost({
      title: formData.get('title') as string,
      content: formData.get('content') as string,
      tags: (formData.get('tags') as string).split(',').map(t => t.trim()),
      published: formData.get('published') === 'on',
    });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="title" placeholder="Title" required />
      <textarea name="content" placeholder="Content" required />
      <input name="tags" placeholder="Tags (comma separated)" />
      <label>
        <input type="checkbox" name="published" />
        Publish immediately
      </label>
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Creating...' : 'Create Post'}
      </button>
    </form>
  );
}

/**
 * Example: App Root with Provider
 */
export function App() {
  return (
    <APIProvider
      config={{
        baseURL: process.env.NEXT_PUBLIC_API_URL || '/api/rpc',
        headers: () => ({
          'Content-Type': 'application/json',
        }),
        onError: (error) => {
          console.error('API Error:', error);
          // Show toast notification
        },
      }}
    >
      <UserProfile />
      <PostsList />
      <CreatePostForm />
    </APIProvider>
  );
}
```

## Verifizierung

### Test 1: Basic API Call
```typescript
const client = createAPIClient();
const result = await client.user.me();
console.log(result); // Type-safe response
```

### Test 2: React Hook Usage
```tsx
function Component() {
  const { data, isLoading } = useCurrentUser();
  
  if (isLoading) return <div>Loading...</div>;
  return <div>{data?.data.name}</div>;
}
```

### Test 3: Optimistic Updates
```tsx
const { mutate: toggleLike } = useToggleLike();

// Optimistic update happens automatically
toggleLike({ postId: 'post-id' });
```

### Test 4: Error Handling
```tsx
const { mutate } = useCreatePost({
  onError: (error) => {
    if (error.code === 'RATE_LIMIT_EXCEEDED') {
      toast.error('Too many requests');
    }
  },
});
```

## Erfolgskriterien
- [ ] Type-safe Client SDK
- [ ] React Hooks implementiert
- [ ] Optimistic Updates funktionieren
- [ ] Error Handling robust
- [ ] Caching Strategy aktiv
- [ ] Pagination Helpers verfügbar

## Nächste Schritte
- Weiter mit 07.07: API Route Handler