# Arbeitspaket 07.04: Post Procedures

## Ziel
Implementierung vollständiger Blog Post API Procedures mit CRUD Operations, Publishing, Tags und Comments.

## Kontext
- Aufbauend auf Base Procedures (07.02)
- Blog/CMS Funktionalität
- Tag System
- Comment System
- View Tracking

## Implementierung

### Schritt 1: Post Schemas
Erstelle `packages/api/src/schemas/post.ts`:

```typescript
import { z } from 'zod';
import { publicUserSchema } from './user';

// Post status enum
export const PostStatus = z.enum(['DRAFT', 'PUBLISHED', 'ARCHIVED']);

// Tag schema
export const tagSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  postCount: z.number().optional(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

// Comment schema
export const commentSchema = z.object({
  id: z.string().uuid(),
  content: z.string(),
  postId: z.string().uuid(),
  authorId: z.string().uuid(),
  parentId: z.string().uuid().nullable(),
  editedAt: z.date().nullable(),
  deletedAt: z.date().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

// Base post schema
export const postSchema = z.object({
  id: z.string().uuid(),
  title: z.string(),
  slug: z.string(),
  content: z.string(),
  excerpt: z.string().nullable(),
  coverImage: z.string().url().nullable(),
  status: PostStatus.default('DRAFT'),
  published: z.boolean().default(false),
  publishedAt: z.date().nullable(),
  authorId: z.string().uuid(),
  views: z.number().default(0),
  likes: z.number().default(0),
  featured: z.boolean().default(false),
  allowComments: z.boolean().default(true),
  metadata: z.record(z.any()).nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
  deletedAt: z.date().nullable(),
});

// Post with relations
export const postWithRelationsSchema = postSchema.extend({
  author: publicUserSchema,
  tags: z.array(tagSchema).default([]),
  _count: z.object({
    comments: z.number(),
    likes: z.number(),
  }).optional(),
});

// Comment with author
export const commentWithAuthorSchema = commentSchema.extend({
  author: publicUserSchema,
  replies: z.array(z.lazy(() => commentWithAuthorSchema)).optional(),
});

// Create post input
export const createPostSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().min(10),
  excerpt: z.string().max(500).nullable().optional(),
  coverImage: z.string().url().nullable().optional(),
  tags: z.array(z.string()).max(10).optional(),
  status: PostStatus.optional(),
  published: z.boolean().optional(),
  featured: z.boolean().optional(),
  allowComments: z.boolean().optional(),
  metadata: z.record(z.any()).optional(),
});

// Update post input
export const updatePostSchema = createPostSchema.partial();

// Create comment input
export const createCommentSchema = z.object({
  content: z.string().min(1).max(1000),
  parentId: z.string().uuid().nullable().optional(),
});
```

### Schritt 2: Post Procedures Implementation
Erstelle `packages/api/src/procedures/post.ts`:

```typescript
import { z } from 'zod';
import { 
  publicProcedure,
  authedProcedure,
  adminProcedure,
  moderatorProcedure,
  withRateLimit,
  withCache,
  withOwnership,
  withLogging,
} from './base';
import { createError } from '../errors/app-error';
import { createAuditLog } from '../utils/audit-log';
import {
  successSchema,
  paginationSchema,
  paginatedResponseSchema,
} from '../utils/schemas';
import {
  postSchema,
  postWithRelationsSchema,
  createPostSchema,
  updatePostSchema,
  PostStatus,
} from '../schemas/post';

// Helper function to generate slug
function generateSlug(title: string): string {
  const base = title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
  
  // Add timestamp for uniqueness
  return `${base}-${Date.now().toString(36)}`;
}

export const postProcedures = {
  // Create new post
  create: authedProcedure
    .use(withRateLimit({ limit: 'strict' }))
    .use(withLogging({ includeInput: true }))
    .input(createPostSchema)
    .output(successSchema(postWithRelationsSchema))
    .handler(async ({ input, context }) => {
      // Generate unique slug
      const slug = generateSlug(input.title);
      
      // Check for duplicate slug (edge case)
      const existing = await context.db.post.findUnique({
        where: { slug },
      });
      
      if (existing) {
        throw createError.conflict('A post with this title already exists');
      }
      
      // Create post with tags
      const post = await context.db.post.create({
        data: {
          title: input.title,
          slug,
          content: input.content,
          excerpt: input.excerpt || input.content.substring(0, 200) + '...',
          coverImage: input.coverImage,
          status: input.status || 'DRAFT',
          published: input.published || false,
          publishedAt: input.published ? new Date() : null,
          featured: input.featured || false,
          allowComments: input.allowComments ?? true,
          metadata: input.metadata,
          authorId: context.userId!,
          tags: input.tags ? {
            connectOrCreate: input.tags.map(tag => ({
              where: { slug: tag.toLowerCase().replace(/\s+/g, '-') },
              create: {
                name: tag,
                slug: tag.toLowerCase().replace(/\s+/g, '-'),
              },
            })),
          } : undefined,
        },
        include: {
          author: {
            select: {
              id: true,
              name: true,
              image: true,
              profile: {
                select: { bio: true },
              },
            },
          },
          tags: true,
          _count: {
            select: {
              comments: true,
              likes: true,
            },
          },
        },
      });
      
      // Format response
      const formattedPost = {
        ...post,
        author: {
          id: post.author.id,
          name: post.author.name,
          image: post.author.image,
          bio: post.author.profile?.bio || null,
        },
      };
      
      // Audit log
      await createAuditLog(context.db, {
        userId: context.userId!,
        action: 'POST_CREATED',
        entity: 'posts',
        entityId: post.id,
        newValues: input,
        ip: context.ip,
        userAgent: context.userAgent,
      });
      
      return { success: true, data: formattedPost };
    }),

  // Get post by slug
  getBySlug: publicProcedure
    .use(withCache({
      key: (input) => `post:slug:${input.slug}`,
      ttl: 300, // 5 minutes
    }))
    .input(z.object({
      slug: z.string(),
      incrementViews: z.boolean().optional(),
    }))
    .output(successSchema(postWithRelationsSchema))
    .handler(async ({ input, context }) => {
      const post = await context.db.post.findFirst({
        where: {
          slug: input.slug,
          deletedAt: null,
          OR: [
            { published: true },
            ...(context.userId ? [{ authorId: context.userId }] : []),
          ],
        },
        include: {
          author: {
            select: {
              id: true,
              name: true,
              image: true,
              profile: {
                select: { bio: true },
              },
            },
          },
          tags: true,
          _count: {
            select: {
              comments: true,
              likes: true,
            },
          },
        },
      });
      
      if (!post) {
        throw createError.notFound('Post');
      }
      
      // Increment views (if requested and published)
      if (input.incrementViews && post.published) {
        await context.db.post.update({
          where: { id: post.id },
          data: { views: { increment: 1 } },
        });
      }
      
      // Format response
      const formattedPost = {
        ...post,
        author: {
          id: post.author.id,
          name: post.author.name,
          image: post.author.image,
          bio: post.author.profile?.bio || null,
        },
      };
      
      return { success: true, data: formattedPost };
    }),

  // List posts
  list: publicProcedure
    .use(withCache({
      key: (input) => `posts:list:${JSON.stringify(input)}`,
      ttl: 60, // 1 minute
    }))
    .input(paginationSchema.extend({
      status: PostStatus.optional(),
      published: z.boolean().optional(),
      featured: z.boolean().optional(),
      authorId: z.string().uuid().optional(),
      tag: z.string().optional(),
      search: z.string().optional(),
      orderBy: z.enum(['createdAt', 'publishedAt', 'views', 'likes', 'title']).default('publishedAt'),
      order: z.enum(['asc', 'desc']).default('desc'),
    }))
    .output(successSchema(paginatedResponseSchema(postWithRelationsSchema)))
    .handler(async ({ input, context }) => {
      const { 
        page, 
        limit, 
        status, 
        published, 
        featured, 
        authorId, 
        tag, 
        search, 
        orderBy, 
        order 
      } = input;
      const skip = (page - 1) * limit;
      
      // Build where clause
      const where: any = {
        deletedAt: null,
        ...(status && { status }),
        ...(published !== undefined && { published }),
        ...(featured !== undefined && { featured }),
        ...(authorId && { authorId }),
        ...(tag && {
          tags: {
            some: { 
              OR: [
                { slug: tag.toLowerCase().replace(/\s+/g, '-') },
                { name: { contains: tag, mode: 'insensitive' } },
              ],
            },
          },
        }),
        ...(search && {
          OR: [
            { title: { contains: search, mode: 'insensitive' } },
            { content: { contains: search, mode: 'insensitive' } },
            { excerpt: { contains: search, mode: 'insensitive' } },
          ],
        }),
      };
      
      // Only show published posts to non-authors
      if (!context.userId) {
        where.published = true;
      } else if (!context.isAdmin && authorId !== context.userId) {
        where.OR = [
          { published: true },
          { authorId: context.userId },
        ];
      }
      
      // Execute queries
      const [posts, total] = await Promise.all([
        context.db.post.findMany({
          where,
          skip,
          take: limit,
          orderBy: { [orderBy]: order },
          include: {
            author: {
              select: {
                id: true,
                name: true,
                image: true,
                profile: {
                  select: { bio: true },
                },
              },
            },
            tags: true,
            _count: {
              select: {
                comments: true,
                likes: true,
              },
            },
          },
        }),
        context.db.post.count({ where }),
      ]);
      
      // Format posts
      const formattedPosts = posts.map(post => ({
        ...post,
        author: {
          id: post.author.id,
          name: post.author.name,
          image: post.author.image,
          bio: post.author.profile?.bio || null,
        },
      }));
      
      const totalPages = Math.ceil(total / limit);
      
      return {
        success: true,
        data: {
          items: formattedPosts,
          total,
          page,
          totalPages,
          hasMore: page < totalPages,
        },
      };
    }),

  // Update post
  update: authedProcedure
    .use(withOwnership({
      getResource: async (input, ctx) => 
        ctx.db.post.findUnique({ 
          where: { id: input.id } 
        }),
      ownerField: 'authorId',
    }))
    .use(withRateLimit({ limit: 'strict' }))
    .input(z.object({
      id: z.string().uuid(),
    }).merge(updatePostSchema))
    .output(successSchema(postWithRelationsSchema))
    .handler(async ({ input, context }) => {
      const { id, tags, ...data } = input;
      const resource = (context as any).resource;
      
      // Update post
      const post = await context.db.post.update({
        where: { id },
        data: {
          ...data,
          // Update publishedAt if publishing for first time
          ...(data.published && !resource.published && {
            publishedAt: new Date(),
          }),
          // Update tags if provided
          ...(tags !== undefined && {
            tags: {
              set: [], // Clear existing
              connectOrCreate: tags.map(tag => ({
                where: { slug: tag.toLowerCase().replace(/\s+/g, '-') },
                create: {
                  name: tag,
                  slug: tag.toLowerCase().replace(/\s+/g, '-'),
                },
              })),
            },
          }),
        },
        include: {
          author: {
            select: {
              id: true,
              name: true,
              image: true,
              profile: {
                select: { bio: true },
              },
            },
          },
          tags: true,
          _count: {
            select: {
              comments: true,
              likes: true,
            },
          },
        },
      });
      
      // Format response
      const formattedPost = {
        ...post,
        author: {
          id: post.author.id,
          name: post.author.name,
          image: post.author.image,
          bio: post.author.profile?.bio || null,
        },
      };
      
      // Audit log
      await createAuditLog(context.db, {
        userId: context.userId!,
        action: 'POST_UPDATED',
        entity: 'posts',
        entityId: post.id,
        oldValues: resource,
        newValues: input,
        ip: context.ip,
        userAgent: context.userAgent,
      });
      
      return { success: true, data: formattedPost };
    }),

  // Delete post
  delete: authedProcedure
    .use(withOwnership({
      getResource: async (input, ctx) => 
        ctx.db.post.findUnique({ 
          where: { id: input.id } 
        }),
      ownerField: 'authorId',
    }))
    .input(z.object({
      id: z.string().uuid(),
    }))
    .output(successSchema(z.object({ 
      deleted: z.boolean(),
      message: z.string(),
    })))
    .handler(async ({ input, context }) => {
      // Soft delete post and cascade
      await context.db.$transaction([
        // Soft delete post
        context.db.post.update({
          where: { id: input.id },
          data: { 
            deletedAt: new Date(),
            slug: `deleted_${Date.now()}_${input.id}`, // Prevent slug conflicts
          },
        }),
        // Soft delete comments
        context.db.comment.updateMany({
          where: { postId: input.id },
          data: { deletedAt: new Date() },
        }),
      ]);
      
      // Audit log
      await createAuditLog(context.db, {
        userId: context.userId!,
        action: 'POST_DELETED',
        entity: 'posts',
        entityId: input.id,
        ip: context.ip,
        userAgent: context.userAgent,
      });
      
      return { 
        success: true, 
        data: { 
          deleted: true,
          message: 'Post and associated comments have been deleted',
        },
      };
    }),

  // Toggle like
  toggleLike: authedProcedure
    .use(withRateLimit({ limit: 'relaxed' }))
    .input(z.object({
      postId: z.string().uuid(),
    }))
    .output(successSchema(z.object({
      liked: z.boolean(),
      likeCount: z.number(),
    })))
    .handler(async ({ input, context }) => {
      // Check if already liked
      const existingLike = await context.db.postLike.findUnique({
        where: {
          postId_userId: {
            postId: input.postId,
            userId: context.userId!,
          },
        },
      });
      
      let liked: boolean;
      
      if (existingLike) {
        // Unlike
        await context.db.postLike.delete({
          where: {
            postId_userId: {
              postId: input.postId,
              userId: context.userId!,
            },
          },
        });
        liked = false;
      } else {
        // Like
        await context.db.postLike.create({
          data: {
            postId: input.postId,
            userId: context.userId!,
          },
        });
        liked = true;
      }
      
      // Get updated count
      const likeCount = await context.db.postLike.count({
        where: { postId: input.postId },
      });
      
      // Update post like count (denormalized for performance)
      await context.db.post.update({
        where: { id: input.postId },
        data: { likes: likeCount },
      });
      
      return {
        success: true,
        data: { liked, likeCount },
      };
    }),

  // Get trending posts
  trending: publicProcedure
    .use(withCache({
      key: () => 'posts:trending',
      ttl: 900, // 15 minutes
    }))
    .input(z.object({
      limit: z.number().min(1).max(20).default(5),
      days: z.number().min(1).max(30).default(7),
    }))
    .output(successSchema(z.array(postWithRelationsSchema)))
    .handler(async ({ input, context }) => {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - input.days);
      
      const posts = await context.db.post.findMany({
        where: {
          published: true,
          publishedAt: { gte: cutoffDate },
          deletedAt: null,
        },
        orderBy: [
          { views: 'desc' },
          { likes: 'desc' },
          { publishedAt: 'desc' },
        ],
        take: input.limit,
        include: {
          author: {
            select: {
              id: true,
              name: true,
              image: true,
              profile: {
                select: { bio: true },
              },
            },
          },
          tags: true,
          _count: {
            select: {
              comments: true,
              likes: true,
            },
          },
        },
      });
      
      // Format posts
      const formattedPosts = posts.map(post => ({
        ...post,
        author: {
          id: post.author.id,
          name: post.author.name,
          image: post.author.image,
          bio: post.author.profile?.bio || null,
        },
      }));
      
      return { success: true, data: formattedPosts };
    }),
};
```

## Verifizierung

### Test 1: Create Post
```typescript
const api = createAPIClient('/api/rpc');
const { data: post } = await api.post.create({
  title: 'My First Post',
  content: 'This is the content of my post...',
  tags: ['typescript', 'nextjs'],
  published: true,
});
```

### Test 2: List Posts
```typescript
const { data } = await api.post.list({
  page: 1,
  limit: 10,
  published: true,
  orderBy: 'publishedAt',
});
console.log(data.items); // Array of posts
```

### Test 3: Update Post
```typescript
const { data: updated } = await api.post.update({
  id: 'post-id',
  title: 'Updated Title',
  published: true,
});
```

### Test 4: Toggle Like
```typescript
const { data } = await api.post.toggleLike({
  postId: 'post-id',
});
console.log(data.liked); // true/false
console.log(data.likeCount); // number
```

## Erfolgskriterien
- [ ] Post CRUD Operations vollständig
- [ ] Tag System funktioniert
- [ ] View Tracking implementiert
- [ ] Like System funktioniert
- [ ] Soft Delete mit Cascade
- [ ] Trending Posts Endpoint

## Nächste Schritte
- Weiter mit 07.05: Router Assembly