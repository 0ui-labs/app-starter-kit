# Task 09.09.4: E2E Tests - Posts CRUD Flow

## Ziel
Sicherstellen, dass das Erstellen, Bearbeiten, Anzeigen und Löschen von Posts durchgängig funktioniert. Testen von Entwürfen, Veröffentlichung, Filterung und Pagination.

## Voraussetzungen
- Task 09.09.3 abgeschlossen (Dashboard Tests)
- Posts Feature implementiert
- Authenticated State verfügbar

## Implementierung

### Schritt 1: Create Post Tests
Erstelle `e2e/posts-create.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';
import { TestHelpers } from './helpers/test-helpers';

test.describe('Create Post', () => {
  test.use({ storageState: 'playwright/.auth/user.json' });
  
  let helpers: TestHelpers;

  test.beforeEach(async ({ page }) => {
    helpers = new TestHelpers(page);
    await page.goto('/posts/new');
  });

  test('create and publish post', async ({ page }) => {
    const title = `Test Post ${Date.now()}`;
    const content = 'This is test content for E2E testing.';
    
    // Fill post form
    await page.fill('[name="title"], input[placeholder*="Title"]', title);
    
    // Handle different editor types
    const richEditor = page.locator('[data-testid="rich-editor"], .tiptap, .ProseMirror');
    const textArea = page.locator('textarea[name="content"]');
    
    if (await richEditor.isVisible()) {
      await richEditor.fill(content);
    } else if (await textArea.isVisible()) {
      await textArea.fill(content);
    }
    
    // Select category if available
    const categorySelect = page.locator('[name="category"], select[aria-label*="Category"]');
    if (await categorySelect.isVisible()) {
      await categorySelect.selectOption({ index: 1 });
    }
    
    // Add tags
    const tagsInput = page.locator('[name="tags"], input[placeholder*="Tags"]');
    if (await tagsInput.isVisible()) {
      await tagsInput.fill('test, e2e, playwright');
      await tagsInput.press('Enter');
    }
    
    // Add featured image if available
    const imageUpload = page.locator('input[type="file"][accept*="image"]');
    if (await imageUpload.isVisible()) {
      // Skip file upload in tests or use test image
    }
    
    // Publish directly
    const publishButton = page.locator('button:has-text("Publish")');
    await publishButton.click();
    
    // Handle confirmation dialog if present
    const confirmButton = page.locator('button:has-text("Confirm"), button:has-text("Yes")');
    if (await confirmButton.isVisible({ timeout: 1000 })) {
      await confirmButton.click();
    }
    
    // Should show success message
    await helpers.expectToast(/Published|Success|Created/i);
    
    // Should redirect to post view
    await expect(page).toHaveURL(/\/posts\/[^\/]+$/);
    
    // Verify post is displayed
    await expect(page.locator('h1')).toContainText(title);
    await expect(page.locator('main, article')).toContainText(content);
  });

  test('save post as draft', async ({ page }) => {
    const title = `Draft Post ${Date.now()}`;
    
    // Fill minimal required fields
    await page.fill('[name="title"]', title);
    await page.fill('[name="content"], textarea', 'Draft content');
    
    // Save as draft
    const draftButton = page.locator('button:has-text("Save as Draft"), button:has-text("Save Draft")');
    await draftButton.click();
    
    // Should show success
    await helpers.expectToast(/Draft|Saved/i);
    
    // Should redirect to edit page
    await expect(page).toHaveURL(/\/posts\/[^\/]+\/edit/);
    
    // Status should show draft
    const statusBadge = page.locator('[data-testid="post-status"]');
    await expect(statusBadge).toContainText(/Draft/i);
  });

  test('form validation', async ({ page }) => {
    // Try to publish without required fields
    const publishButton = page.locator('button:has-text("Publish")');
    await publishButton.click();
    
    // Should show validation errors
    await expect(page.locator('text=/Title.*required|Please.*title/i')).toBeVisible();
    
    // Fill title but leave content empty
    await page.fill('[name="title"]', 'Test Title');
    await publishButton.click();
    
    // Should show content error
    await expect(page.locator('text=/Content.*required|Please.*content/i')).toBeVisible();
  });

  test('autosave functionality', async ({ page }) => {
    // Skip if autosave not implemented
    const autosaveIndicator = page.locator('[data-testid="autosave-status"]');
    
    if (await autosaveIndicator.isVisible({ timeout: 1000 })) {
      // Type title
      await page.fill('[name="title"]', 'Autosave Test');
      
      // Wait for autosave
      await page.waitForTimeout(3000);
      
      // Check autosave indicator
      await expect(autosaveIndicator).toContainText(/Saved|Autosaved/i);
      
      // Reload page
      await page.reload();
      
      // Content should be preserved
      const titleInput = page.locator('[name="title"]');
      await expect(titleInput).toHaveValue('Autosave Test');
    }
  });

  test('cancel and confirm dialog', async ({ page }) => {
    // Make changes
    await page.fill('[name="title"]', 'Unsaved Post');
    
    // Try to navigate away
    await page.click('a[href="/posts"]');
    
    // Should show confirmation dialog
    const dialog = page.locator('[role="dialog"], [role="alertdialog"]');
    
    if (await dialog.isVisible({ timeout: 1000 })) {
      await expect(dialog).toContainText(/unsaved|changes|leave/i);
      
      // Cancel navigation
      await dialog.locator('button:has-text("Cancel"), button:has-text("Stay")').click();
      
      // Should stay on page
      await expect(page).toHaveURL(/\/posts\/new/);
      
      // Try again and confirm
      await page.click('a[href="/posts"]');
      await dialog.locator('button:has-text("Leave"), button:has-text("Discard")').click();
      
      // Should navigate away
      await expect(page).toHaveURL('/posts');
    }
  });
});
```

### Schritt 2: Read/List Posts Tests
Erstelle `e2e/posts-list.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';
import { TestHelpers } from './helpers/test-helpers';

test.describe('Posts List and Filtering', () => {
  test.use({ storageState: 'playwright/.auth/user.json' });
  
  let helpers: TestHelpers;

  test.beforeEach(async ({ page }) => {
    helpers = new TestHelpers(page);
    await page.goto('/posts');
  });

  test('displays posts list', async ({ page }) => {
    // Check page title
    await expect(page.locator('h1')).toContainText(/Posts|Articles|Blog/i);
    
    // Check for posts or empty state
    const postCards = page.locator('[data-testid="post-card"]');
    const emptyState = page.locator('[data-testid="empty-state"]');
    
    const hasPosts = await postCards.count() > 0;
    const isEmpty = await emptyState.isVisible().catch(() => false);
    
    expect(hasPosts || isEmpty).toBeTruthy();
    
    if (hasPosts) {
      // Check post card structure
      const firstPost = postCards.first();
      
      // Should have title
      await expect(firstPost.locator('[data-testid="post-title"]')).toBeVisible();
      
      // Should have metadata
      const metadata = firstPost.locator('[data-testid="post-meta"]');
      if (await metadata.isVisible()) {
        // Check for date, author, etc.
        const metaText = await metadata.textContent();
        expect(metaText).toBeTruthy();
      }
      
      // Should be clickable
      const link = firstPost.locator('a');
      await expect(link).toHaveAttribute('href', /\/posts\/.+/);
    }
  });

  test('filter by status', async ({ page }) => {
    const statusFilter = page.locator('[name="status"], select[aria-label*="Status"]');
    
    if (await statusFilter.isVisible()) {
      // Filter by published
      await statusFilter.selectOption('published');
      await page.waitForLoadState('networkidle');
      
      // Check results
      const posts = page.locator('[data-testid="post-card"]');
      const count = await posts.count();
      
      if (count > 0) {
        // All should be published
        for (let i = 0; i < count; i++) {
          const status = posts.nth(i).locator('[data-testid="post-status"]');
          if (await status.isVisible()) {
            await expect(status).toContainText(/Published/i);
          }
        }
      }
      
      // Filter by draft
      await statusFilter.selectOption('draft');
      await page.waitForLoadState('networkidle');
      
      // Check draft posts
      const draftPosts = page.locator('[data-testid="post-card"]');
      const draftCount = await draftPosts.count();
      
      if (draftCount > 0) {
        const firstDraftStatus = draftPosts.first().locator('[data-testid="post-status"]');
        if (await firstDraftStatus.isVisible()) {
          await expect(firstDraftStatus).toContainText(/Draft/i);
        }
      }
    }
  });

  test('search posts', async ({ page }) => {
    const searchInput = page.locator('[placeholder*="Search"], input[type="search"]');
    
    if (await searchInput.isVisible()) {
      // Create a unique post first
      const uniqueTitle = `Unique ${Date.now()}`;
      await helpers.createTestPost({ title: uniqueTitle });
      
      // Search for it
      await page.goto('/posts');
      await searchInput.fill(uniqueTitle);
      await searchInput.press('Enter');
      
      await page.waitForLoadState('networkidle');
      
      // Should find the post
      const results = page.locator('[data-testid="post-card"]');
      const resultCount = await results.count();
      
      if (resultCount > 0) {
        const firstResult = results.first();
        await expect(firstResult).toContainText(uniqueTitle);
      }
      
      // Clear search
      await searchInput.clear();
      await searchInput.press('Enter');
    }
  });

  test('sort posts', async ({ page }) => {
    const sortSelect = page.locator('[name="sort"], select[aria-label*="Sort"]');
    
    if (await sortSelect.isVisible()) {
      // Sort by newest
      await sortSelect.selectOption(/new|recent|date.*desc/i);
      await page.waitForLoadState('networkidle');
      
      // Get dates
      const posts = page.locator('[data-testid="post-card"]');
      const dates: Date[] = [];
      
      const count = Math.min(await posts.count(), 5);
      for (let i = 0; i < count; i++) {
        const dateText = await posts.nth(i).locator('[data-testid="post-date"]').textContent();
        if (dateText) {
          dates.push(new Date(dateText));
        }
      }
      
      // Check dates are descending
      for (let i = 1; i < dates.length; i++) {
        expect(dates[i].getTime()).toBeLessThanOrEqual(dates[i - 1].getTime());
      }
      
      // Sort by oldest
      await sortSelect.selectOption(/old|date.*asc/i);
      await page.waitForLoadState('networkidle');
      
      // Dates should now be ascending
    }
  });

  test('pagination', async ({ page }) => {
    const pagination = page.locator('[data-testid="pagination"], nav[aria-label="Pagination"]');
    
    if (await pagination.isVisible()) {
      // Get first page posts
      const firstPagePost = await page.locator('[data-testid="post-card"]').first().textContent();
      
      // Go to next page
      const nextButton = pagination.locator('button:has-text("Next"), a:has-text("Next")');
      await nextButton.click();
      
      // Wait for navigation
      await page.waitForLoadState('networkidle');
      
      // Should have different posts
      const secondPagePost = await page.locator('[data-testid="post-card"]').first().textContent();
      expect(secondPagePost).not.toBe(firstPagePost);
      
      // Check URL updated
      expect(page.url()).toContain('page=2');
      
      // Go back to first page
      const prevButton = pagination.locator('button:has-text("Previous"), a:has-text("Previous")');
      await prevButton.click();
      
      // Should be back on page 1
      await expect(page.locator('[data-testid="post-card"]').first()).toContainText(firstPagePost || '');
    }
  });
});
```

### Schritt 3: Update Post Tests
Erstelle `e2e/posts-update.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';
import { TestHelpers } from './helpers/test-helpers';

test.describe('Update Post', () => {
  test.use({ storageState: 'playwright/.auth/user.json' });
  
  let helpers: TestHelpers;
  let testPostId: string;

  test.beforeEach(async ({ page }) => {
    helpers = new TestHelpers(page);
    
    // Create a test post to edit
    const post = await helpers.createTestPost({
      title: 'Post to Edit',
      content: 'Original content',
      status: 'draft'
    });
    testPostId = post.id;
    
    await page.goto(`/posts/${testPostId}/edit`);
  });

  test('edit post title and content', async ({ page }) => {
    // Update title
    const titleInput = page.locator('[name="title"]');
    await titleInput.clear();
    await titleInput.fill('Updated Post Title');
    
    // Update content
    const contentInput = page.locator('[name="content"], textarea, [data-testid="rich-editor"]');
    await contentInput.clear();
    await contentInput.fill('Updated content for the post.');
    
    // Save changes
    await page.click('button:has-text("Save"), button:has-text("Update")');
    
    // Should show success
    await helpers.expectToast(/Updated|Saved/i);
    
    // Verify changes persisted
    await page.reload();
    await expect(titleInput).toHaveValue('Updated Post Title');
    await expect(contentInput).toContainText('Updated content');
  });

  test('change post status', async ({ page }) => {
    // Current status should be draft
    const statusBadge = page.locator('[data-testid="post-status"]');
    await expect(statusBadge).toContainText(/Draft/i);
    
    // Publish post
    const publishButton = page.locator('button:has-text("Publish")');
    await publishButton.click();
    
    // Confirm if needed
    const confirmButton = page.locator('button:has-text("Confirm")');
    if (await confirmButton.isVisible({ timeout: 1000 })) {
      await confirmButton.click();
    }
    
    // Should show success
    await helpers.expectToast(/Published/i);
    
    // Status should update
    await expect(statusBadge).toContainText(/Published/i);
    
    // Unpublish back to draft
    const unpublishButton = page.locator('button:has-text("Unpublish"), button:has-text("Revert to Draft")');
    if (await unpublishButton.isVisible()) {
      await unpublishButton.click();
      await helpers.expectToast(/Draft|Unpublished/i);
      await expect(statusBadge).toContainText(/Draft/i);
    }
  });

  test('update post metadata', async ({ page }) => {
    // Update category
    const categorySelect = page.locator('[name="category"]');
    if (await categorySelect.isVisible()) {
      await categorySelect.selectOption({ index: 2 });
    }
    
    // Update tags
    const tagsInput = page.locator('[name="tags"]');
    if (await tagsInput.isVisible()) {
      await tagsInput.clear();
      await tagsInput.fill('updated, tags, test');
    }
    
    // Update slug
    const slugInput = page.locator('[name="slug"]');
    if (await slugInput.isVisible()) {
      await slugInput.clear();
      await slugInput.fill('updated-post-slug');
    }
    
    // Update excerpt
    const excerptInput = page.locator('[name="excerpt"], textarea[aria-label*="Excerpt"]');
    if (await excerptInput.isVisible()) {
      await excerptInput.fill('This is an updated excerpt.');
    }
    
    // Save changes
    await page.click('button:has-text("Save")');
    await helpers.expectToast(/Updated|Saved/i);
    
    // Verify slug change in URL
    if (await slugInput.isVisible()) {
      await page.goto('/posts/updated-post-slug');
      await expect(page.locator('h1')).toBeVisible();
    }
  });

  test('revision history', async ({ page }) => {
    // Look for revision/history button
    const historyButton = page.locator('button:has-text("History"), button:has-text("Revisions")');
    
    if (await historyButton.isVisible()) {
      await historyButton.click();
      
      // Should show revision list
      const revisionPanel = page.locator('[data-testid="revision-panel"], [role="dialog"]');
      await expect(revisionPanel).toBeVisible();
      
      // Should have at least one revision
      const revisions = revisionPanel.locator('[data-testid="revision-item"]');
      expect(await revisions.count()).toBeGreaterThan(0);
      
      // Test restore if available
      const restoreButton = revisions.first().locator('button:has-text("Restore")');
      if (await restoreButton.isVisible()) {
        await restoreButton.click();
        
        // Confirm restore
        const confirmRestore = page.locator('button:has-text("Confirm Restore")');
        if (await confirmRestore.isVisible()) {
          await confirmRestore.click();
        }
        
        await helpers.expectToast(/Restored/i);
      }
      
      // Close panel
      await page.keyboard.press('Escape');
    }
  });

  test('preview changes', async ({ page }) => {
    // Make changes
    await page.fill('[name="title"]', 'Preview Test Title');
    
    // Find preview button
    const previewButton = page.locator('button:has-text("Preview")');
    
    if (await previewButton.isVisible()) {
      await previewButton.click();
      
      // Should open preview
      const preview = page.locator('[data-testid="preview-panel"], iframe[title*="Preview"]');
      
      if (await preview.isVisible()) {
        // If iframe, switch context
        if (preview.toString().includes('iframe')) {
          const frame = page.frameLocator('iframe[title*="Preview"]');
          await expect(frame.locator('h1')).toContainText('Preview Test Title');
        } else {
          // Direct preview panel
          await expect(preview.locator('h1')).toContainText('Preview Test Title');
        }
      } else {
        // Might open in new tab
        const [newPage] = await Promise.all([
          page.waitForEvent('popup'),
          previewButton.click()
        ]);
        
        await expect(newPage.locator('h1')).toContainText('Preview Test Title');
        await newPage.close();
      }
    }
  });
});
```

### Schritt 4: Delete Post Tests
Erstelle `e2e/posts-delete.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';
import { TestHelpers } from './helpers/test-helpers';

test.describe('Delete Post', () => {
  test.use({ storageState: 'playwright/.auth/user.json' });
  
  let helpers: TestHelpers;

  test.beforeEach(async ({ page }) => {
    helpers = new TestHelpers(page);
  });

  test('delete post from edit page', async ({ page }) => {
    // Create a test post
    const post = await helpers.createTestPost({
      title: 'Post to Delete from Edit'
    });
    
    await page.goto(`/posts/${post.id}/edit`);
    
    // Find delete button
    const deleteButton = page.locator('button:has-text("Delete")');
    await deleteButton.click();
    
    // Confirm deletion
    const dialog = page.locator('[role="dialog"], [role="alertdialog"]');
    await expect(dialog).toContainText(/delete|remove|confirm/i);
    
    const confirmButton = dialog.locator('button:has-text("Delete"), button:has-text("Confirm")');
    await confirmButton.click();
    
    // Should show success
    await helpers.expectToast(/Deleted|Removed/i);
    
    // Should redirect to posts list
    await expect(page).toHaveURL('/posts');
    
    // Post should not exist
    await expect(page.locator(`text="${post.title}"`)).not.toBeVisible();
  });

  test('delete post from list', async ({ page }) => {
    // Create a test post
    const post = await helpers.createTestPost({
      title: `Delete from List ${Date.now()}`
    });
    
    await page.goto('/posts');
    
    // Find the post card
    const postCard = page.locator(`[data-testid="post-card"]:has-text("${post.title}")`);
    
    // Open post options
    const optionsButton = postCard.locator('[aria-label="Options"], button:has-text("⋮")');
    await optionsButton.click();
    
    // Click delete option
    const deleteOption = page.locator('button:has-text("Delete"), [role="menuitem"]:has-text("Delete")');
    await deleteOption.click();
    
    // Confirm deletion
    const confirmButton = page.locator('button:has-text("Confirm"), button:has-text("Yes")');
    await confirmButton.click();
    
    // Should show success
    await helpers.expectToast(/Deleted/i);
    
    // Post should be removed from list
    await expect(postCard).not.toBeVisible();
  });

  test('bulk delete posts', async ({ page }) => {
    // Create multiple test posts
    const posts = await Promise.all([
      helpers.createTestPost({ title: 'Bulk Delete 1' }),
      helpers.createTestPost({ title: 'Bulk Delete 2' }),
      helpers.createTestPost({ title: 'Bulk Delete 3' })
    ]);
    
    await page.goto('/posts');
    
    // Check if bulk actions are available
    const selectAllCheckbox = page.locator('[aria-label="Select all"], input[type="checkbox"]').first();
    
    if (await selectAllCheckbox.isVisible()) {
      // Select posts
      for (const post of posts) {
        const checkbox = page.locator(`[data-testid="post-card"]:has-text("${post.title}") input[type="checkbox"]`);
        await checkbox.check();
      }
      
      // Bulk actions should appear
      const bulkActions = page.locator('[data-testid="bulk-actions"]');
      await expect(bulkActions).toBeVisible();
      
      // Click bulk delete
      const bulkDeleteButton = bulkActions.locator('button:has-text("Delete")');
      await bulkDeleteButton.click();
      
      // Confirm bulk deletion
      const dialog = page.locator('[role="dialog"]');
      await expect(dialog).toContainText(/delete.*3.*posts/i);
      
      await dialog.locator('button:has-text("Delete All")').click();
      
      // Should show success
      await helpers.expectToast(/Deleted.*3/i);
      
      // Posts should be removed
      for (const post of posts) {
        await expect(page.locator(`text="${post.title}"`)).not.toBeVisible();
      }
    }
  });

  test('cancel delete operation', async ({ page }) => {
    const post = await helpers.createTestPost({
      title: 'Do Not Delete'
    });
    
    await page.goto(`/posts/${post.id}/edit`);
    
    // Start delete process
    await page.click('button:has-text("Delete")');
    
    // Cancel deletion
    const dialog = page.locator('[role="dialog"]');
    const cancelButton = dialog.locator('button:has-text("Cancel"), button:has-text("No")');
    await cancelButton.click();
    
    // Dialog should close
    await expect(dialog).not.toBeVisible();
    
    // Should still be on edit page
    await expect(page).toHaveURL(`/posts/${post.id}/edit`);
    
    // Post should still exist
    await page.goto('/posts');
    await expect(page.locator(`text="${post.title}"`)).toBeVisible();
  });

  test('trash and restore', async ({ page }) => {
    // Check if trash feature exists
    const post = await helpers.createTestPost({
      title: 'Trash Test Post'
    });
    
    await page.goto(`/posts/${post.id}/edit`);
    
    // Look for trash button (soft delete)
    const trashButton = page.locator('button:has-text("Trash"), button:has-text("Move to Trash")');
    
    if (await trashButton.isVisible()) {
      await trashButton.click();
      
      await helpers.expectToast(/Trashed|Moved to trash/i);
      
      // Go to trash view
      await page.goto('/posts?status=trashed');
      
      // Post should be in trash
      await expect(page.locator(`text="${post.title}"`)).toBeVisible();
      
      // Restore post
      const postCard = page.locator(`[data-testid="post-card"]:has-text("${post.title}")`);
      const restoreButton = postCard.locator('button:has-text("Restore")');
      
      if (await restoreButton.isVisible()) {
        await restoreButton.click();
        await helpers.expectToast(/Restored/i);
        
        // Post should be back in regular list
        await page.goto('/posts');
        await expect(page.locator(`text="${post.title}"`)).toBeVisible();
      }
    }
  });
});
```

## Verifizierung

### Test 1: Run CRUD Tests
```bash
npx playwright test posts-*.spec.ts
# Alle Posts Tests sollten grün sein
```

### Test 2: Test Data Cleanup
```bash
# Cleanup Script für Test-Posts
npx playwright test posts-delete.spec.ts --grep="bulk delete"
```

### Test 3: Performance Test
```bash
npx playwright test posts-list.spec.ts --repeat-each=3
# Test mit mehreren Durchläufen für Performance
```

## Erfolgskriterien
- [ ] Post erstellen (Entwurf) funktioniert
- [ ] Post veröffentlichen funktioniert
- [ ] Formvalidierung funktioniert
- [ ] Post-Liste wird angezeigt
- [ ] Filterung nach Status funktioniert
- [ ] Suche funktioniert
- [ ] Sortierung funktioniert
- [ ] Pagination funktioniert
- [ ] Post bearbeiten funktioniert
- [ ] Status ändern funktioniert
- [ ] Post löschen funktioniert
- [ ] Bulk-Operationen funktionieren
- [ ] Trash/Restore funktioniert (falls implementiert)

## Wichtige Hinweise

### Test Data Management
```typescript
// Helper für Test-Daten Cleanup
afterAll(async () => {
  await helpers.cleanupTestPosts();
});
```

### Flaky Test Prevention
```typescript
// Wait for autosave
await page.waitForSelector('[data-testid="autosave-status"]:has-text("Saved")');

// Wait for list update
await page.waitForResponse(resp => resp.url().includes('/api/posts'));
```

### Rich Editor Testing
```typescript
// Handle different editor implementations
const editor = await helpers.getEditor(page);
await editor.setContent('Test content');
```

## Potentielle Probleme

### Problem: Rich Text Editor Tests
**Lösung**: Editor-spezifische Selektoren
```typescript
// TipTap
await page.locator('.ProseMirror').fill('content');

// Slate
await page.locator('[data-slate-editor="true"]').fill('content');

// Quill
await page.locator('.ql-editor').fill('content');
```

### Problem: File Upload in Tests
**Lösung**: Mock File Upload
```typescript
await page.setInputFiles('input[type="file"]', {
  name: 'test.jpg',
  mimeType: 'image/jpeg',
  buffer: Buffer.from('fake-image-data')
});
```

### Problem: Async State Updates
**Lösung**: Wait for State Changes
```typescript
await page.waitForFunction(
  text => document.querySelector('[data-testid="post-status"]')?.textContent === text,
  'Published'
);
```

## Zeitschätzung
- Create Tests: 5 Minuten
- List/Filter Tests: 5 Minuten
- Update Tests: 5 Minuten
- Delete Tests: 5 Minuten
- Verifizierung: 2 Minuten
- **Total: 22 Minuten**

## Nächster Schritt
Nach erfolgreichen CRUD Tests → [09.09.5 Accessibility Audit E2E Tests](./09.09.5-e2e-accessibility-audit.md)