# Arbeitspaket 03.04: Database Utilities

## Ziel
Erstellung von wiederverwendbaren Utility-Funktionen für Pagination, Audit Logging und häufige Datenbankoperationen.

## Kontext
- **Package**: `@starter-kit/db`
- **Location**: `packages/db/src/utils.ts`
- **Purpose**: Wiederverwendbare Database Helpers

## Implementierung

### Database Utilities
Erstelle `packages/db/src/utils.ts`:

```typescript
import { Prisma, AuditAction, UserRole, UserStatus } from '../generated/prisma';
import type { ExtendedPrismaClient } from './client';

// ============================================
// Pagination Utilities
// ============================================

export interface PaginationParams {
  page?: number;
  limit?: number;
  orderBy?: string;
  order?: 'asc' | 'desc';
}

export interface PaginationResult<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}

/**
 * Get pagination parameters for Prisma queries
 */
export function getPaginationParams(params: PaginationParams) {
  const page = Math.max(1, params.page || 1);
  const limit = Math.min(100, Math.max(1, params.limit || 10));
  const skip = (page - 1) * limit;
  
  return {
    skip,
    take: limit,
    orderBy: params.orderBy
      ? { [params.orderBy]: params.order || 'desc' }
      : { createdAt: 'desc' },
  };
}

/**
 * Create paginated response with metadata
 */
export async function paginate<T>(
  model: any,
  params: PaginationParams & { where?: any; include?: any; select?: any }
): Promise<PaginationResult<T>> {
  const { skip, take, orderBy } = getPaginationParams(params);
  
  const [data, total] = await Promise.all([
    model.findMany({
      skip,
      take,
      orderBy,
      where: params.where,
      include: params.include,
      select: params.select,
    }),
    model.count({ where: params.where }),
  ]);
  
  const page = params.page || 1;
  const limit = params.limit || 10;
  const totalPages = Math.ceil(total / limit);
  
  return {
    data,
    meta: {
      total,
      page,
      limit,
      totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
    },
  };
}

// ============================================
// Audit Logging Utilities
// ============================================

export interface AuditLogData {
  userId?: string;
  action: AuditAction;
  entity: string;
  entityId?: string;
  oldValues?: any;
  newValues?: any;
  ip?: string;
  userAgent?: string;
}

/**
 * Create an audit log entry
 */
export async function createAuditLog(
  prisma: ExtendedPrismaClient,
  data: AuditLogData
) {
  return prisma.auditLog.create({
    data: {
      userId: data.userId,
      action: data.action,
      entity: data.entity,
      entityId: data.entityId,
      oldValues: data.oldValues ? JSON.stringify(data.oldValues) : null,
      newValues: data.newValues ? JSON.stringify(data.newValues) : null,
      ip: data.ip,
      userAgent: data.userAgent,
    },
  });
}

/**
 * Audit log wrapper for mutations
 */
export async function withAudit<T>(
  prisma: ExtendedPrismaClient,
  auditData: Omit<AuditLogData, 'oldValues' | 'newValues'>,
  operation: () => Promise<T>,
  options?: {
    captureOldValues?: () => Promise<any>;
    captureNewValues?: (result: T) => any;
  }
): Promise<T> {
  let oldValues: any = null;
  
  // Capture old values if needed
  if (options?.captureOldValues && auditData.action !== AuditAction.CREATE) {
    oldValues = await options.captureOldValues();
  }
  
  // Execute operation
  const result = await operation();
  
  // Capture new values
  const newValues = options?.captureNewValues
    ? options.captureNewValues(result)
    : result;
  
  // Create audit log
  await createAuditLog(prisma, {
    ...auditData,
    oldValues,
    newValues,
  });
  
  return result;
}

// ============================================
// Search & Filter Utilities
// ============================================

export interface SearchParams {
  query?: string;
  fields?: string[];
  mode?: 'insensitive' | 'default';
}

/**
 * Build search conditions for text fields
 */
export function buildSearchConditions(params: SearchParams): any {
  if (!params.query || !params.fields?.length) {
    return undefined;
  }
  
  return {
    OR: params.fields.map(field => ({
      [field]: {
        contains: params.query,
        mode: params.mode || 'insensitive',
      },
    })),
  };
}

/**
 * Build date range filter
 */
export function buildDateRangeFilter(
  field: string,
  from?: Date | string,
  to?: Date | string
): any {
  const conditions: any = {};
  
  if (from) {
    conditions.gte = new Date(from);
  }
  
  if (to) {
    conditions.lte = new Date(to);
  }
  
  return Object.keys(conditions).length > 0
    ? { [field]: conditions }
    : undefined;
}

// ============================================
// Batch Operations Utilities
// ============================================

/**
 * Process items in batches
 */
export async function processBatch<T, R>(
  items: T[],
  batchSize: number,
  processor: (batch: T[]) => Promise<R[]>
): Promise<R[]> {
  const results: R[] = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await processor(batch);
    results.push(...batchResults);
  }
  
  return results;
}

/**
 * Upsert multiple records
 */
export async function upsertMany<T>(
  prisma: any,
  model: string,
  records: Array<{
    where: any;
    create: any;
    update: any;
  }>
): Promise<T[]> {
  return processBatch(records, 100, async (batch) => {
    return Promise.all(
      batch.map(record =>
        (prisma[model] as any).upsert({
          where: record.where,
          create: record.create,
          update: record.update,
        })
      )
    );
  });
}

// ============================================
// Cache Key Utilities
// ============================================

/**
 * Generate cache key for queries
 */
export function getCacheKey(
  model: string,
  operation: string,
  params?: any
): string {
  const paramString = params
    ? JSON.stringify(params, Object.keys(params).sort())
    : '';
  return `${model}:${operation}:${paramString}`;
}

// ============================================
// Transaction Utilities
// ============================================

export interface TransactionOptions {
  maxWait?: number;
  timeout?: number;
  isolationLevel?: Prisma.TransactionIsolationLevel;
}

/**
 * Execute operations in a transaction with retry logic
 */
export async function withTransaction<T>(
  prisma: ExtendedPrismaClient,
  operations: (tx: Prisma.TransactionClient) => Promise<T>,
  options?: TransactionOptions & { retries?: number }
): Promise<T> {
  const { retries = 3, ...txOptions } = options || {};
  
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await prisma.$transaction(operations, txOptions);
    } catch (error: any) {
      // Retry on deadlock or lock timeout
      if (
        attempt < retries &&
        (error.code === 'P2034' || error.code === 'P2024')
      ) {
        await new Promise(resolve => 
          setTimeout(resolve, Math.pow(2, attempt) * 100)
        );
        continue;
      }
      throw error;
    }
  }
  
  throw new Error('Transaction failed after maximum retries');
}

// ============================================
// Validation Utilities
// ============================================

/**
 * Check if user has permission for action
 */
export function hasPermission(
  user: { role: UserRole; status: UserStatus },
  action: string,
  resource?: string
): boolean {
  // Inactive users have no permissions
  if (user.status !== UserStatus.ACTIVE) {
    return false;
  }
  
  // Admin has all permissions
  if (user.role === UserRole.ADMIN) {
    return true;
  }
  
  // Define permission matrix
  const permissions: Record<UserRole, string[]> = {
    [UserRole.ADMIN]: ['*'],
    [UserRole.MODERATOR]: [
      'post:read',
      'post:update',
      'post:delete',
      'comment:*',
      'user:read',
      'user:suspend',
    ],
    [UserRole.USER]: [
      'post:read',
      'post:create',
      'post:update:own',
      'post:delete:own',
      'comment:read',
      'comment:create',
      'comment:update:own',
      'comment:delete:own',
      'profile:read',
      'profile:update:own',
    ],
  };
  
  const userPermissions = permissions[user.role] || [];
  
  // Check for wildcard permission
  if (userPermissions.includes('*') || userPermissions.includes(`${resource}:*`)) {
    return true;
  }
  
  // Check for specific permission
  const fullAction = resource ? `${resource}:${action}` : action;
  return userPermissions.includes(fullAction);
}

/**
 * Validate ownership
 */
export function isOwner(
  userId: string,
  resource: { userId?: string; authorId?: string; ownerId?: string }
): boolean {
  return (
    resource.userId === userId ||
    resource.authorId === userId ||
    resource.ownerId === userId
  );
}

// ============================================
// Export Types
// ============================================

export type {
  ExtendedPrismaClient,
} from './client';
```

## Features

### Pagination
- `getPaginationParams()`: Konvertiert Page/Limit zu Skip/Take
- `paginate()`: Komplette Pagination mit Metadata
- Automatische Total Count und Page Info

### Audit Logging
- `createAuditLog()`: Einfache Audit Log Erstellung
- `withAudit()`: Wrapper für automatisches Audit Logging
- Old/New Values Capture

### Search & Filter
- `buildSearchConditions()`: Multi-Field Text Search
- `buildDateRangeFilter()`: Datum Range Queries
- Case-insensitive Search Support

### Batch Operations
- `processBatch()`: Batch Processing für große Datenmengen
- `upsertMany()`: Bulk Upsert Operations
- Automatisches Batching für Performance

### Transactions
- `withTransaction()`: Transaction mit Retry Logic
- Deadlock Detection und Retry
- Configurable Isolation Levels

### Permissions
- `hasPermission()`: Role-based Access Control
- `isOwner()`: Ownership Validation
- Permission Matrix für alle Rollen

## Verwendung

```typescript
import { 
  paginate, 
  withAudit, 
  buildSearchConditions,
  hasPermission 
} from '@starter-kit/db';

// Pagination
const result = await paginate(prisma.post, {
  page: 1,
  limit: 20,
  orderBy: 'createdAt',
  where: { published: true }
});

// Audit Logging
const post = await withAudit(
  prisma,
  {
    userId: currentUser.id,
    action: AuditAction.UPDATE,
    entity: 'posts',
    entityId: postId,
  },
  async () => {
    return prisma.post.update({
      where: { id: postId },
      data: { title: newTitle }
    });
  },
  {
    captureOldValues: async () => {
      return prisma.post.findUnique({ where: { id: postId } });
    }
  }
);

// Search
const searchConditions = buildSearchConditions({
  query: 'typescript',
  fields: ['title', 'content', 'excerpt'],
  mode: 'insensitive'
});

// Permissions
if (hasPermission(user, 'update', 'post')) {
  // User can update posts
}
```

## Erfolgskriterien
- [ ] Pagination mit Metadata
- [ ] Audit Logging mit Old/New Values
- [ ] Search & Filter Utilities
- [ ] Batch Operations
- [ ] Transaction mit Retry
- [ ] Permission System