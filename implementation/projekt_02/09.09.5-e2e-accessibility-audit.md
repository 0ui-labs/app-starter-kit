# Task 09.09.5: E2E Tests - Accessibility Audit

## Ziel
Automatisierte Überprüfung der Barrierefreiheit auf den wichtigsten Seiten. Integration von axe-playwright für WCAG-Compliance und Durchführung von Keyboard-Navigation Tests.

## Voraussetzungen
- Task 09.09.4 abgeschlossen (CRUD Tests)
- axe-playwright installiert
- Playwright konfiguriert

## Installation

### Schritt 1: axe-playwright installieren
```bash
npm install --save-dev axe-playwright @axe-core/playwright
```

## Implementierung

### Schritt 1: Core Accessibility Tests
Erstelle `e2e/accessibility-core.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';
import { injectAxe, checkA11y, configureAxe } from 'axe-playwright';

test.describe('Core Accessibility', () => {
  test('homepage accessibility', async ({ page }) => {
    await page.goto('/');
    await injectAxe(page);
    
    // Configure axe for specific WCAG levels
    await configureAxe(page, {
      rules: {
        'color-contrast': { enabled: true },
        'image-alt': { enabled: true },
        'label': { enabled: true },
        'link-name': { enabled: true },
        'button-name': { enabled: true },
      },
    });
    
    // Run accessibility check
    await checkA11y(page, undefined, {
      detailedReport: true,
      detailedReportOptions: {
        html: true,
      },
    });
  });

  test('sign in page accessibility', async ({ page }) => {
    await page.goto('/sign-in');
    await injectAxe(page);
    
    // Check entire page
    await checkA11y(page);
    
    // Check form specifically
    await checkA11y(page, 'form', {
      detailedReport: true,
    });
  });

  test('sign up page accessibility', async ({ page }) => {
    await page.goto('/sign-up');
    await injectAxe(page);
    
    await checkA11y(page, undefined, {
      detailedReport: true,
    });
  });

  test('dashboard accessibility', async ({ page }) => {
    // Use authenticated state
    await page.goto('/dashboard', {
      storageState: 'playwright/.auth/user.json',
    });
    
    await injectAxe(page);
    
    // Exclude dynamic content that might cause false positives
    await checkA11y(page, undefined, {
      exclude: [['.toast'], ['[data-testid="live-region"]']],
    });
  });

  test('posts page accessibility', async ({ page }) => {
    await page.goto('/posts', {
      storageState: 'playwright/.auth/user.json',
    });
    
    await injectAxe(page);
    await checkA11y(page);
  });

  test('post create page accessibility', async ({ page }) => {
    await page.goto('/posts/new', {
      storageState: 'playwright/.auth/user.json',
    });
    
    await injectAxe(page);
    
    // Rich text editors might have known issues
    await checkA11y(page, undefined, {
      exclude: [['[data-testid="rich-editor"]']],
    });
  });
});
```

### Schritt 2: Keyboard Navigation Tests
Erstelle `e2e/accessibility-keyboard.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';

test.describe('Keyboard Navigation', () => {
  test('navigate homepage with keyboard', async ({ page }) => {
    await page.goto('/');
    
    // Start tabbing
    await page.keyboard.press('Tab');
    
    // Skip to main content link should be first
    let activeElement = await page.evaluate(() => ({
      text: document.activeElement?.textContent,
      tag: document.activeElement?.tagName,
      href: document.activeElement?.getAttribute('href'),
    }));
    
    if (activeElement.text?.includes('Skip')) {
      // Test skip link
      await page.keyboard.press('Enter');
      
      // Focus should move to main content
      activeElement = await page.evaluate(() => ({
        id: document.activeElement?.id,
        tag: document.activeElement?.tagName,
      }));
      
      expect(activeElement.tag).toBe('MAIN');
    }
    
    // Tab through navigation
    const navigationOrder: string[] = [];
    
    for (let i = 0; i < 10; i++) {
      await page.keyboard.press('Tab');
      
      const element = await page.evaluate(() => {
        const el = document.activeElement;
        return {
          text: el?.textContent?.trim(),
          tag: el?.tagName,
          role: el?.getAttribute('role'),
          href: el?.getAttribute('href'),
        };
      });
      
      if (element.tag) {
        navigationOrder.push(`${element.tag}: ${element.text}`);
      }
      
      // Should only focus interactive elements
      if (element.tag) {
        expect(['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA']).toContain(element.tag);
      }
    }
    
    // Verify logical tab order
    expect(navigationOrder.length).toBeGreaterThan(0);
  });

  test('form keyboard navigation', async ({ page }) => {
    await page.goto('/sign-in');
    
    // Tab to first form field
    await page.keyboard.press('Tab');
    await page.keyboard.press('Tab'); // Skip skip-link if present
    
    // Should focus email field
    const firstField = await page.evaluate(() => ({
      name: document.activeElement?.getAttribute('name'),
      type: document.activeElement?.getAttribute('type'),
    }));
    
    expect(firstField.type).toBe('email');
    
    // Type in field
    await page.keyboard.type('test@example.com');
    
    // Tab to password field
    await page.keyboard.press('Tab');
    
    const secondField = await page.evaluate(() => ({
      name: document.activeElement?.getAttribute('name'),
      type: document.activeElement?.getAttribute('type'),
    }));
    
    expect(secondField.type).toBe('password');
    
    // Type password
    await page.keyboard.type('password123');
    
    // Tab to submit button
    await page.keyboard.press('Tab');
    
    // Might have remember me checkbox
    const currentElement = await page.evaluate(() => ({
      type: document.activeElement?.getAttribute('type'),
      tag: document.activeElement?.tagName,
    }));
    
    if (currentElement.type === 'checkbox') {
      // Toggle checkbox with space
      await page.keyboard.press('Space');
      await page.keyboard.press('Tab');
    }
    
    // Should now be on submit button
    const submitButton = await page.evaluate(() => ({
      tag: document.activeElement?.tagName,
      type: document.activeElement?.getAttribute('type'),
      text: document.activeElement?.textContent,
    }));
    
    expect(submitButton.tag).toBe('BUTTON');
    expect(submitButton.type).toBe('submit');
  });

  test('modal keyboard trap', async ({ page }) => {
    await page.goto('/dashboard', {
      storageState: 'playwright/.auth/user.json',
    });
    
    // Open a modal (e.g., user menu)
    const userMenu = page.locator('[data-testid="user-menu"]');
    await userMenu.click();
    
    // Check if focus is trapped in modal
    const modal = page.locator('[role="dialog"], [data-testid="dropdown-menu"]');
    
    if (await modal.isVisible()) {
      // Tab through modal
      const focusableElements: string[] = [];
      
      for (let i = 0; i < 10; i++) {
        await page.keyboard.press('Tab');
        
        const element = await page.evaluate(() => ({
          tag: document.activeElement?.tagName,
          isInModal: document.activeElement?.closest('[role="dialog"], [data-testid="dropdown-menu"]') !== null,
        }));
        
        if (element.tag) {
          focusableElements.push(element.tag);
          // Focus should stay within modal
          expect(element.isInModal).toBeTruthy();
        }
      }
      
      // Escape should close modal
      await page.keyboard.press('Escape');
      await expect(modal).not.toBeVisible();
    }
  });

  test('keyboard shortcuts', async ({ page }) => {
    await page.goto('/dashboard', {
      storageState: 'playwright/.auth/user.json',
    });
    
    // Test search shortcut (usually Ctrl/Cmd + K)
    await page.keyboard.press('Control+K');
    
    let searchVisible = await page.locator('[data-testid="search-modal"], [data-testid="command-palette"]').isVisible();
    
    if (!searchVisible) {
      // Try Mac shortcut
      await page.keyboard.press('Meta+K');
      searchVisible = await page.locator('[data-testid="search-modal"]').isVisible();
    }
    
    if (searchVisible) {
      // Close with Escape
      await page.keyboard.press('Escape');
      await expect(page.locator('[data-testid="search-modal"]')).not.toBeVisible();
    }
    
    // Test other shortcuts if available
    // Example: New post shortcut
    await page.keyboard.press('Control+N');
    
    if (page.url().includes('/posts/new')) {
      // Shortcut worked
      expect(page.url()).toContain('/posts/new');
    }
  });
});
```

### Schritt 3: Screen Reader Tests
Erstelle `e2e/accessibility-screen-reader.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';

test.describe('Screen Reader Support', () => {
  test('landmarks and regions', async ({ page }) => {
    await page.goto('/');
    
    // Check for main landmark
    const main = page.locator('main, [role="main"]');
    await expect(main).toBeVisible();
    
    // Check for navigation landmark
    const nav = page.locator('nav, [role="navigation"]');
    await expect(nav).toBeVisible();
    
    // Check for banner/header
    const header = page.locator('header, [role="banner"]');
    await expect(header).toBeVisible();
    
    // Check for contentinfo/footer
    const footer = page.locator('footer, [role="contentinfo"]');
    await expect(footer).toBeVisible();
    
    // Check for complementary/aside if exists
    const aside = page.locator('aside, [role="complementary"]');
    if (await aside.count() > 0) {
      await expect(aside.first()).toBeVisible();
    }
  });

  test('headings hierarchy', async ({ page }) => {
    await page.goto('/');
    
    // Get all headings
    const headings = await page.locator('h1, h2, h3, h4, h5, h6').all();
    
    // Should have exactly one h1
    const h1Count = await page.locator('h1').count();
    expect(h1Count).toBe(1);
    
    // Check heading hierarchy
    let lastLevel = 0;
    
    for (const heading of headings) {
      const tagName = await heading.evaluate(el => el.tagName);
      const level = parseInt(tagName.substring(1));
      
      // Heading levels should not skip
      if (lastLevel > 0) {
        expect(level - lastLevel).toBeLessThanOrEqual(1);
      }
      
      lastLevel = level;
      
      // Headings should have text content
      const text = await heading.textContent();
      expect(text?.trim()).toBeTruthy();
    }
  });

  test('form labels and descriptions', async ({ page }) => {
    await page.goto('/sign-up');
    
    // Check all form inputs have labels
    const inputs = await page.locator('input:not([type="hidden"]), select, textarea').all();
    
    for (const input of inputs) {
      const inputId = await input.getAttribute('id');
      const inputName = await input.getAttribute('name');
      const ariaLabel = await input.getAttribute('aria-label');
      const ariaLabelledBy = await input.getAttribute('aria-labelledby');
      
      // Input should have label
      if (inputId) {
        const label = page.locator(`label[for="${inputId}"]`);
        const hasLabel = await label.count() > 0;
        
        // Should have either label, aria-label, or aria-labelledby
        expect(hasLabel || ariaLabel || ariaLabelledBy).toBeTruthy();
      } else {
        // If no id, must have aria-label
        expect(ariaLabel).toBeTruthy();
      }
      
      // Check for error messages association
      const ariaDescribedBy = await input.getAttribute('aria-describedby');
      const ariaInvalid = await input.getAttribute('aria-invalid');
      
      if (ariaInvalid === 'true') {
        // Invalid fields should have error description
        expect(ariaDescribedBy).toBeTruthy();
      }
    }
  });

  test('images and media', async ({ page }) => {
    await page.goto('/');
    
    // Check all images have alt text
    const images = await page.locator('img').all();
    
    for (const img of images) {
      const alt = await img.getAttribute('alt');
      const role = await img.getAttribute('role');
      const ariaLabel = await img.getAttribute('aria-label');
      
      // Image should have alt text or be marked as decorative
      if (role !== 'presentation' && role !== 'none') {
        expect(alt || ariaLabel).toBeTruthy();
        
        // Alt text should not be redundant
        if (alt) {
          expect(alt).not.toMatch(/^image|photo|picture$/i);
        }
      }
    }
    
    // Check videos have captions
    const videos = await page.locator('video').all();
    
    for (const video of videos) {
      const tracks = await video.locator('track[kind="captions"]').count();
      const ariaLabel = await video.getAttribute('aria-label');
      
      // Video should have captions or description
      expect(tracks > 0 || ariaLabel).toBeTruthy();
    }
  });

  test('live regions and announcements', async ({ page }) => {
    await page.goto('/dashboard', {
      storageState: 'playwright/.auth/user.json',
    });
    
    // Check for live regions
    const liveRegions = await page.locator('[aria-live], [role="alert"], [role="status"]').all();
    
    for (const region of liveRegions) {
      const ariaLive = await region.getAttribute('aria-live');
      const role = await region.getAttribute('role');
      
      // Live regions should have appropriate politeness
      if (role === 'alert') {
        expect(ariaLive === 'assertive' || !ariaLive).toBeTruthy();
      } else if (role === 'status') {
        expect(ariaLive === 'polite' || !ariaLive).toBeTruthy();
      }
    }
    
    // Test toast notifications
    // Trigger an action that shows a toast
    const button = page.locator('button').first();
    await button.click();
    
    // Check if toast has proper ARIA attributes
    const toast = page.locator('.toast, [role="alert"], [data-testid="toast"]');
    
    if (await toast.isVisible({ timeout: 1000 })) {
      const role = await toast.getAttribute('role');
      const ariaLive = await toast.getAttribute('aria-live');
      
      // Toast should announce to screen readers
      expect(role === 'alert' || ariaLive === 'polite' || ariaLive === 'assertive').toBeTruthy();
    }
  });
});
```

### Schritt 4: Color Contrast and Visual Tests
Erstelle `e2e/accessibility-visual.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';
import { injectAxe, checkA11y } from 'axe-playwright';

test.describe('Visual Accessibility', () => {
  test('color contrast compliance', async ({ page }) => {
    await page.goto('/');
    await injectAxe(page);
    
    // Check specifically for color contrast
    const results = await page.evaluate(async () => {
      // @ts-ignore
      return await axe.run(document, {
        rules: {
          'color-contrast': { enabled: true },
        },
      });
    });
    
    // Should have no color contrast violations
    const contrastViolations = results.violations.filter(v => v.id === 'color-contrast');
    
    if (contrastViolations.length > 0) {
      console.log('Color contrast violations:', contrastViolations);
    }
    
    expect(contrastViolations).toHaveLength(0);
  });

  test('focus indicators', async ({ page }) => {
    await page.goto('/');
    
    // Tab to first interactive element
    await page.keyboard.press('Tab');
    
    // Check focus is visible
    const focusedElement = await page.evaluate(() => {
      const el = document.activeElement;
      if (!el) return null;
      
      const styles = window.getComputedStyle(el);
      const pseudoStyles = window.getComputedStyle(el, ':focus');
      
      return {
        outline: styles.outline,
        outlineWidth: styles.outlineWidth,
        outlineColor: styles.outlineColor,
        boxShadow: styles.boxShadow,
        border: styles.border,
      };
    });
    
    // Should have visible focus indicator
    const hasOutline = focusedElement?.outlineWidth !== '0px' && focusedElement?.outline !== 'none';
    const hasBoxShadow = focusedElement?.boxShadow && focusedElement.boxShadow !== 'none';
    const hasBorder = focusedElement?.border && !focusedElement.border.includes('0px');
    
    expect(hasOutline || hasBoxShadow || hasBorder).toBeTruthy();
  });

  test('text scaling', async ({ page }) => {
    await page.goto('/');
    
    // Test with 200% zoom (WCAG requirement)
    await page.evaluate(() => {
      document.documentElement.style.fontSize = '200%';
    });
    
    // Check content is still accessible
    const mainContent = page.locator('main');
    await expect(mainContent).toBeVisible();
    
    // Check no horizontal scroll
    const hasHorizontalScroll = await page.evaluate(() => {
      return document.documentElement.scrollWidth > document.documentElement.clientWidth;
    });
    
    // Should not require horizontal scrolling at 200% zoom
    expect(hasHorizontalScroll).toBeFalsy();
    
    // Reset zoom
    await page.evaluate(() => {
      document.documentElement.style.fontSize = '';
    });
  });

  test('dark mode accessibility', async ({ page }) => {
    await page.goto('/');
    
    // Check if dark mode toggle exists
    const darkModeToggle = page.locator('[aria-label*="theme"], [aria-label*="dark"], button:has-text("Dark")');
    
    if (await darkModeToggle.isVisible()) {
      // Enable dark mode
      await darkModeToggle.click();
      
      // Wait for theme change
      await page.waitForTimeout(500);
      
      // Inject axe and check dark mode
      await injectAxe(page);
      
      // Dark mode should also pass accessibility
      await checkA11y(page, undefined, {
        rules: {
          'color-contrast': { enabled: true },
        },
      });
    }
  });

  test('responsive accessibility', async ({ page }) => {
    // Test mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    
    await injectAxe(page);
    
    // Mobile should also be accessible
    await checkA11y(page);
    
    // Check touch targets
    const buttons = await page.locator('button, a').all();
    
    for (const button of buttons.slice(0, 5)) {
      const box = await button.boundingBox();
      
      if (box) {
        // Touch targets should be at least 44x44 pixels (WCAG 2.5.5)
        expect(box.width).toBeGreaterThanOrEqual(44);
        expect(box.height).toBeGreaterThanOrEqual(44);
      }
    }
  });
});
```

### Schritt 5: Custom Accessibility Helpers
Erstelle `e2e/helpers/a11y-helpers.ts`:

```typescript
import { Page } from '@playwright/test';
import { injectAxe, checkA11y, Result } from 'axe-playwright';

export class A11yHelpers {
  constructor(private page: Page) {}

  async checkPage(selector?: string): Promise<Result> {
    await injectAxe(this.page);
    
    const results = await this.page.evaluate(async (sel) => {
      // @ts-ignore
      return await axe.run(sel ? document.querySelector(sel) : document);
    }, selector);
    
    return results;
  }

  async checkCriticalIssues(): Promise<void> {
    const results = await this.checkPage();
    
    // Filter for critical and serious issues only
    const criticalViolations = results.violations.filter(
      v => v.impact === 'critical' || v.impact === 'serious'
    );
    
    if (criticalViolations.length > 0) {
      throw new Error(`Found ${criticalViolations.length} critical accessibility issues`);
    }
  }

  async getFocusOrder(): Promise<string[]> {
    const elements: string[] = [];
    
    // Tab through page and record focus order
    for (let i = 0; i < 20; i++) {
      await this.page.keyboard.press('Tab');
      
      const element = await this.page.evaluate(() => {
        const el = document.activeElement;
        return el ? `${el.tagName}#${el.id || 'no-id'}.${el.className || 'no-class'}` : null;
      });
      
      if (element) {
        elements.push(element);
      }
    }
    
    return elements;
  }

  async checkFormAccessibility(formSelector: string) {
    const form = this.page.locator(formSelector);
    
    // Check all inputs have labels
    const inputs = form.locator('input:not([type="hidden"]), select, textarea');
    const inputCount = await inputs.count();
    
    for (let i = 0; i < inputCount; i++) {
      const input = inputs.nth(i);
      const hasLabel = await this.hasAccessibleLabel(input);
      
      if (!hasLabel) {
        const name = await input.getAttribute('name');
        throw new Error(`Input ${name} has no accessible label`);
      }
    }
  }

  private async hasAccessibleLabel(element: any): Promise<boolean> {
    const id = await element.getAttribute('id');
    const ariaLabel = await element.getAttribute('aria-label');
    const ariaLabelledBy = await element.getAttribute('aria-labelledby');
    
    if (ariaLabel || ariaLabelledBy) {
      return true;
    }
    
    if (id) {
      const label = this.page.locator(`label[for="${id}"]`);
      return await label.count() > 0;
    }
    
    return false;
  }
}
```

## Verifizierung

### Test 1: Run All Accessibility Tests
```bash
npx playwright test accessibility-*.spec.ts
# Alle A11y Tests sollten grün sein
```

### Test 2: Generate Accessibility Report
```bash
npx playwright test accessibility-core.spec.ts --reporter=html
# HTML Report mit Details öffnen
```

### Test 3: Check Specific WCAG Level
```bash
# Nur WCAG AA Tests
npx playwright test accessibility-*.spec.ts --grep="AA"
```

## Erfolgskriterien
- [ ] Keine kritischen Accessibility-Violations
- [ ] Alle Seiten haben korrekte Landmarks
- [ ] Heading-Hierarchie ist korrekt
- [ ] Alle Formular-Inputs haben Labels
- [ ] Alle Bilder haben Alt-Text
- [ ] Keyboard-Navigation funktioniert
- [ ] Focus-Indikatoren sind sichtbar
- [ ] Color Contrast erfüllt WCAG AA
- [ ] Skip-Links funktionieren
- [ ] Screen Reader Support vorhanden
- [ ] Touch Targets sind groß genug
- [ ] Dark Mode ist accessible

## Wichtige Hinweise

### WCAG Compliance Levels
```typescript
// AA Compliance (Standard)
rules: {
  'wcag2aa': { enabled: true },
  'wcag21aa': { enabled: true }
}

// AAA Compliance (Erweitert)
rules: {
  'wcag2aaa': { enabled: true }
}
```

### Known Issues Handling
```typescript
// Bekannte Issues dokumentieren
const knownIssues = [
  'color-contrast', // Rich editor
  'aria-required-parent', // Third-party component
];

const violations = results.violations.filter(
  v => !knownIssues.includes(v.id)
);
```

### CI/CD Integration
```yaml
# GitHub Actions Example
- name: Accessibility Tests
  run: npx playwright test accessibility-*.spec.ts
  continue-on-error: false
```

## Potentielle Probleme

### Problem: Third-Party Components
**Lösung**: Exclude problematisch Bereiche
```typescript
await checkA11y(page, undefined, {
  exclude: [
    ['iframe'], // External content
    ['.third-party-widget'],
  ]
});
```

### Problem: Dynamic Content
**Lösung**: Wait for Content
```typescript
await page.waitForSelector('[data-loaded="true"]');
await injectAxe(page);
await checkA11y(page);
```

### Problem: False Positives
**Lösung**: Context-aware Testing
```typescript
// Ignore bestimmte Regeln für spezielle Komponenten
await checkA11y(page, '.rich-editor', {
  rules: {
    'aria-required-children': { enabled: false }
  }
});
```

## Zeitschätzung
- Core Tests Setup: 3 Minuten
- Keyboard Tests: 4 Minuten
- Screen Reader Tests: 4 Minuten
- Visual Tests: 3 Minuten
- Helper Implementation: 2 Minuten
- Verifizierung: 2 Minuten
- **Total: 18 Minuten**

## Nächster Schritt
Nach erfolgreichen Accessibility Tests → Alle E2E Tests sind implementiert und aufgeteilt!