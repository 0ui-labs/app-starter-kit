# Sub-Task 06.03: Router mit Validation updaten

## Ziel
Integration der Zod Schemas in den oRPC Router mit Error Handling.

## Package
`@starter-kit/api`

## Datei
`packages/api/src/router.ts`

## Implementation

```typescript
import { os, ORPCError, onError, ValidationError } from '@orpc/server';
import { z } from 'zod';
import { db } from '@starter-kit/db';
import { requireAuth, requireRole } from '@starter-kit/auth';
import {
  userSchema,
  createUserSchema,
  updateUserSchema,
  userFiltersSchema,
} from './schemas/user';
import { paginationSchema, successSchema, idSchema } from './schemas/base';

// Error handling middleware
const baseWithErrorHandling = os.use(onError((error) => {
  if (
    error instanceof ORPCError
    && error.code === 'BAD_REQUEST'
    && error.cause instanceof ValidationError
  ) {
    // Handle Zod validation errors
    const zodError = new z.ZodError(error.cause.issues as z.ZodIssue[]);
    
    throw new ORPCError('INPUT_VALIDATION_FAILED', {
      status: 422,
      message: 'Validation failed',
      data: zodError.flatten(),
      cause: error.cause,
    });
  }
  
  // Re-throw other errors
  throw error;
}));

// Base procedure with auth
const protectedProcedure = baseWithErrorHandling
  .use(async ({ context, next }) => {
    const userId = await requireAuth().catch(() => null);
    if (!userId) {
      throw new ORPCError('UNAUTHORIZED', {
        status: 401,
        message: 'Authentication required'
      });
    }
    return next({ context: { ...context, userId, db } });
  });

// Admin procedure
const adminProcedure = protectedProcedure
  .use(async ({ context, next }) => {
    const isAdmin = await requireRole('admin').catch(() => false);
    if (!isAdmin) {
      throw new ORPCError('FORBIDDEN', {
        status: 403,
        message: 'Admin role required'
      });
    }
    return next();
  });

export const router = baseWithErrorHandling.router({
  // Health check (public)
  health: os
    .output(successSchema(z.object({ status: z.literal('ok') })))
    .handler(() => ({ success: true, data: { status: 'ok' } })),

  // User endpoints
  user: baseWithErrorHandling.router({
    // Get current user
    me: protectedProcedure
      .output(successSchema(userSchema))
      .handler(async ({ context }) => {
        const user = await context.db.user.findUnique({
          where: { id: context.userId },
        });
        
        if (!user) {
          throw new ORPCError('NOT_FOUND', {
            status: 404,
            message: 'User not found'
          });
        }
        
        return { success: true, data: user };
      }),

    // Create user
    create: baseWithErrorHandling
      .input(createUserSchema)
      .output(successSchema(userSchema))
      .handler(async ({ input, context }) => {
        // Hash password (use bcrypt in production)
        const hashedPassword = input.password; // TODO: Hash this
        
        const user = await context.db.user.create({
          data: {
            email: input.email,
            name: input.name,
            password: hashedPassword,
          },
        });
        
        return { success: true, data: user };
      }),

    // Update user
    update: protectedProcedure
      .input(updateUserSchema)
      .output(successSchema(userSchema))
      .handler(async ({ input, context }) => {
        const user = await context.db.user.update({
          where: { id: context.userId },
          data: input,
        });
        
        return { success: true, data: user };
      }),

    // List users (admin only)
    list: adminProcedure
      .input(z.object({
        ...paginationSchema.shape,
        ...userFiltersSchema.shape,
      }))
      .output(successSchema(z.object({
        users: z.array(userSchema),
        total: z.number(),
        page: z.number(),
        totalPages: z.number(),
      })))
      .handler(async ({ input, context }) => {
        const { page, limit, ...filters } = input;
        const offset = (page - 1) * limit;
        
        const where = {
          ...(filters.email && { email: filters.email }),
          ...(filters.role && { role: filters.role }),
          ...(filters.search && {
            OR: [
              { name: { contains: filters.search } },
              { email: { contains: filters.search } },
            ],
          }),
        };
        
        const [users, total] = await Promise.all([
          context.db.user.findMany({
            where,
            skip: offset,
            take: limit,
            orderBy: { createdAt: 'desc' },
          }),
          context.db.user.count({ where }),
        ]);
        
        return {
          success: true,
          data: {
            users,
            total,
            page,
            totalPages: Math.ceil(total / limit),
          },
        };
      }),

    // Delete user (admin only)
    delete: adminProcedure
      .input(z.object({ id: idSchema }))
      .output(successSchema(z.object({ deleted: z.boolean() })))
      .handler(async ({ input, context }) => {
        await context.db.user.delete({
          where: { id: input.id },
        });
        
        return { success: true, data: { deleted: true } };
      }),
  }),
});

export type AppRouter = typeof router;
```

## Kernkonzepte

### 1. Error Handling Middleware
- Fängt Zod Validation Errors
- Konvertiert zu strukturierten API Errors
- Status 422 für Validation Errors
- Flattened Error Format für Frontend

### 2. Procedure Hierarchie

```
baseWithErrorHandling (Global Error Handler)
  ├── public procedures (z.B. health)
  ├── protectedProcedure (Auth Required)
  │   └── adminProcedure (Admin Role Required)
```

### 3. Input/Output Validation
- **Input**: `.input(schema)` validiert Request Body
- **Output**: `.output(schema)` validiert Response
- Automatische Type Inference

### 4. Context Pattern
```typescript
context: {
  userId: string,  // Von Auth Middleware
  db: PrismaClient, // Database Access
  // Weitere Context Properties...
}
```

## API Endpoints

| Endpoint | Method | Auth | Description |
|----------|--------|------|-------------|
| `/health` | GET | Public | Health Check |
| `/user/me` | GET | User | Current User |
| `/user/create` | POST | Public | Register User |
| `/user/update` | PATCH | User | Update Profile |
| `/user/list` | GET | Admin | List All Users |
| `/user/delete` | DELETE | Admin | Delete User |

## Security Features

### 1. Authentication
- JWT Token Validation
- User ID in Context
- Protected Routes

### 2. Authorization
- Role-based Access Control
- Admin-only Endpoints
- Owner-only Updates

### 3. Input Sanitization
- Zod Schema Validation
- Type Coercion
- SQL Injection Prevention (via Prisma)

## Error Responses

```typescript
// Validation Error
{
  "code": "INPUT_VALIDATION_FAILED",
  "message": "Validation failed",
  "data": {
    "fieldErrors": {
      "email": ["Invalid email"],
      "password": ["Must contain uppercase"]
    }
  }
}

// Auth Error
{
  "code": "UNAUTHORIZED",
  "message": "Authentication required"
}

// Not Found
{
  "code": "NOT_FOUND",
  "message": "User not found"
}
```

## TODOs
- [ ] Password Hashing mit bcrypt
- [ ] Rate Limiting
- [ ] Request Logging
- [ ] API Versioning

## Erfolgskriterien
- [ ] Alle Endpoints haben Input Validation
- [ ] Error Handling ist konsistent
- [ ] Auth/Admin Middleware funktioniert
- [ ] Pagination implementiert
- [ ] Filter/Search funktioniert
- [ ] Type Safety end-to-end

## Geschätzte Zeit
30 Minuten