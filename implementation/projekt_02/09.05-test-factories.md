# Task 09.05: Test Factories - Faker.js Testdaten-Generierung

## Ziel
Implementierung von Test Data Factories mit Faker.js für realistische und konsistente Testdaten.

## Voraussetzungen
- Task 09.01 abgeschlossen (@faker-js/faker installiert)
- Prisma Schema Types verfügbar

## Implementierung

### Schritt 1: Base Factory Setup
Erstelle `test/factories/base.ts`:

```typescript
import { faker } from '@faker-js/faker';

// Set seed for consistent test data (optional)
export function setSeed(seed: number) {
  faker.seed(seed);
}

// Reset faker to random seed
export function resetSeed() {
  faker.seed();
}

// Base factory type
export interface Factory<T> {
  build(overrides?: Partial<T>): T;
  buildMany(count: number, overrides?: Partial<T>): T[];
  buildWithRelations(overrides?: Partial<T>): T;
}

// Factory builder helper
export function createFactory<T>(
  defaultBuilder: (overrides?: Partial<T>) => T
): Factory<T> {
  return {
    build: (overrides?: Partial<T>) => defaultBuilder(overrides),
    buildMany: (count: number, overrides?: Partial<T>) => 
      Array.from({ length: count }, () => defaultBuilder(overrides)),
    buildWithRelations: (overrides?: Partial<T>) => defaultBuilder(overrides),
  };
}
```

### Schritt 2: User Factory
Erstelle `test/factories/user.factory.ts`:

```typescript
import { faker } from '@faker-js/faker';
import { createFactory } from './base';
import type { User, Profile, UserRole, UserStatus } from '@starter-kit/db/generated/prisma';

// User Factory
export const userFactory = createFactory<User>((overrides) => ({
  id: faker.string.uuid(),
  email: faker.internet.email().toLowerCase(),
  name: faker.person.fullName(),
  role: faker.helpers.arrayElement(['USER', 'ADMIN'] as UserRole[]),
  status: faker.helpers.arrayElement(['ACTIVE', 'INACTIVE', 'SUSPENDED'] as UserStatus[]),
  clerkId: `clerk_${faker.string.alphanumeric(20)}`,
  emailVerified: faker.datatype.boolean() ? faker.date.past() : null,
  image: faker.image.avatar(),
  lastLoginAt: faker.date.recent(),
  loginCount: faker.number.int({ min: 0, max: 100 }),
  createdAt: faker.date.past({ years: 2 }),
  updatedAt: faker.date.recent(),
  deletedAt: null,
  ...overrides,
}));

// Profile Factory
export const profileFactory = createFactory<Profile>((overrides) => ({
  id: faker.string.uuid(),
  userId: faker.string.uuid(),
  bio: faker.lorem.paragraph(),
  website: faker.internet.url(),
  location: faker.location.city() + ', ' + faker.location.country(),
  twitter: '@' + faker.internet.userName(),
  github: faker.internet.userName(),
  linkedin: faker.internet.userName(),
  company: faker.company.name(),
  jobTitle: faker.person.jobTitle(),
  skills: faker.helpers.multiple(() => faker.hacker.noun(), { count: { min: 3, max: 8 } }),
  interests: faker.helpers.multiple(() => faker.commerce.department(), { count: { min: 2, max: 5 } }),
  timezone: faker.location.timeZone(),
  language: faker.helpers.arrayElement(['en', 'de', 'fr', 'es', 'pt']),
  theme: faker.helpers.arrayElement(['light', 'dark', 'system']),
  emailNotifications: faker.datatype.boolean(),
  pushNotifications: faker.datatype.boolean(),
  createdAt: faker.date.past(),
  updatedAt: faker.date.recent(),
  ...overrides,
}));

// User with Profile
export function createUserWithProfile(overrides?: {
  user?: Partial<User>;
  profile?: Partial<Profile>;
}) {
  const user = userFactory.build(overrides?.user);
  const profile = profileFactory.build({
    userId: user.id,
    ...overrides?.profile,
  });
  
  return { ...user, profile };
}

// Create test users with specific roles
export const createAdminUser = (overrides?: Partial<User>) =>
  userFactory.build({ role: 'ADMIN', ...overrides });

export const createRegularUser = (overrides?: Partial<User>) =>
  userFactory.build({ role: 'USER', ...overrides });

export const createSuspendedUser = (overrides?: Partial<User>) =>
  userFactory.build({ status: 'SUSPENDED', ...overrides });
```

### Schritt 3: Post Factory
Erstelle `test/factories/post.factory.ts`:

```typescript
import { faker } from '@faker-js/faker';
import { createFactory } from './base';
import type { Post, PostStatus } from '@starter-kit/db/generated/prisma';

// Generate realistic slug from title
function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50);
}

// Post Factory
export const postFactory = createFactory<Post>((overrides) => {
  const title = overrides?.title || faker.lorem.sentence();
  const published = overrides?.published ?? faker.datatype.boolean();
  
  return {
    id: faker.string.uuid(),
    authorId: faker.string.uuid(),
    title,
    slug: generateSlug(title) + '-' + faker.string.alphanumeric(6),
    content: faker.lorem.paragraphs({ min: 3, max: 8 }, '\n\n'),
    excerpt: faker.lorem.paragraph(),
    published,
    status: published ? 'PUBLISHED' : faker.helpers.arrayElement(['DRAFT', 'REVIEW'] as PostStatus[]),
    publishedAt: published ? faker.date.past() : null,
    scheduledAt: !published && faker.datatype.boolean() ? faker.date.future() : null,
    featuredImage: faker.image.url(),
    featuredImageAlt: faker.lorem.sentence(),
    views: faker.number.int({ min: 0, max: 10000 }),
    likes: faker.number.int({ min: 0, max: 1000 }),
    shares: faker.number.int({ min: 0, max: 500 }),
    readTime: faker.number.int({ min: 1, max: 30 }),
    tags: faker.helpers.multiple(() => faker.lorem.word(), { count: { min: 1, max: 5 } }),
    category: faker.helpers.arrayElement(['Tech', 'Business', 'Lifestyle', 'Travel', 'Food']),
    metaTitle: faker.lorem.sentence({ min: 5, max: 10 }),
    metaDescription: faker.lorem.paragraph({ min: 1, max: 2 }),
    metaKeywords: faker.helpers.multiple(() => faker.lorem.word(), { count: { min: 3, max: 8 } }),
    allowComments: faker.datatype.boolean(),
    isPinned: faker.datatype.boolean({ probability: 0.1 }),
    isArchived: faker.datatype.boolean({ probability: 0.05 }),
    createdAt: faker.date.past({ years: 1 }),
    updatedAt: faker.date.recent(),
    deletedAt: null,
    ...overrides,
  };
});

// Create different post types
export const createDraftPost = (overrides?: Partial<Post>) =>
  postFactory.build({ 
    published: false, 
    status: 'DRAFT',
    publishedAt: null,
    ...overrides 
  });

export const createPublishedPost = (overrides?: Partial<Post>) =>
  postFactory.build({ 
    published: true,
    status: 'PUBLISHED',
    publishedAt: faker.date.past(),
    ...overrides 
  });

export const createScheduledPost = (overrides?: Partial<Post>) =>
  postFactory.build({
    published: false,
    status: 'SCHEDULED',
    scheduledAt: faker.date.future(),
    ...overrides
  });

export const createFeaturedPost = (overrides?: Partial<Post>) =>
  postFactory.build({
    published: true,
    isPinned: true,
    views: faker.number.int({ min: 5000, max: 50000 }),
    ...overrides
  });
```

### Schritt 4: Comment Factory
Erstelle `test/factories/comment.factory.ts`:

```typescript
import { faker } from '@faker-js/faker';
import { createFactory } from './base';
import type { Comment, CommentStatus } from '@starter-kit/db/generated/prisma';

// Comment Factory
export const commentFactory = createFactory<Comment>((overrides) => ({
  id: faker.string.uuid(),
  postId: faker.string.uuid(),
  authorId: faker.string.uuid(),
  content: faker.lorem.paragraph({ min: 1, max: 3 }),
  parentId: null,
  status: faker.helpers.arrayElement(['APPROVED', 'PENDING', 'SPAM'] as CommentStatus[]),
  approved: faker.datatype.boolean({ probability: 0.8 }),
  flagged: faker.datatype.boolean({ probability: 0.1 }),
  flagReason: null,
  likes: faker.number.int({ min: 0, max: 100 }),
  edited: faker.datatype.boolean({ probability: 0.2 }),
  editedAt: faker.datatype.boolean({ probability: 0.2 }) ? faker.date.recent() : null,
  ipAddress: faker.internet.ip(),
  userAgent: faker.internet.userAgent(),
  createdAt: faker.date.past(),
  updatedAt: faker.date.recent(),
  deletedAt: null,
  ...overrides,
}));

// Create comment thread
export function createCommentThread(
  postId: string,
  depth = 3,
  commentsPerLevel = 2
): Comment[] {
  const comments: Comment[] = [];
  
  function createLevel(parentId: string | null, currentDepth: number) {
    if (currentDepth >= depth) return;
    
    for (let i = 0; i < commentsPerLevel; i++) {
      const comment = commentFactory.build({
        postId,
        parentId,
        approved: true,
        status: 'APPROVED',
      });
      
      comments.push(comment);
      
      // Create replies
      if (faker.datatype.boolean({ probability: 0.7 })) {
        createLevel(comment.id, currentDepth + 1);
      }
    }
  }
  
  createLevel(null, 0);
  return comments;
}

// Create different comment types
export const createApprovedComment = (overrides?: Partial<Comment>) =>
  commentFactory.build({ 
    approved: true,
    status: 'APPROVED',
    flagged: false,
    ...overrides 
  });

export const createPendingComment = (overrides?: Partial<Comment>) =>
  commentFactory.build({
    approved: false,
    status: 'PENDING',
    ...overrides
  });

export const createFlaggedComment = (overrides?: Partial<Comment>) =>
  commentFactory.build({
    flagged: true,
    flagReason: faker.helpers.arrayElement(['spam', 'inappropriate', 'offensive']),
    status: 'FLAGGED',
    ...overrides
  });
```

### Schritt 5: Relationship Factories
Erstelle `test/factories/relationships.ts`:

```typescript
import { userFactory, createUserWithProfile } from './user.factory';
import { postFactory, createPublishedPost } from './post.factory';
import { commentFactory, createApprovedComment } from './comment.factory';

// Create complete blog post with author and comments
export function createBlogPostWithComments(options?: {
  commentCount?: number;
  includeAuthor?: boolean;
}) {
  const author = options?.includeAuthor ? createUserWithProfile() : null;
  const post = createPublishedPost({
    authorId: author?.id || faker.string.uuid(),
  });
  
  const comments = commentFactory.buildMany(
    options?.commentCount || faker.number.int({ min: 0, max: 10 }),
    { postId: post.id }
  );
  
  return {
    post,
    author,
    comments,
  };
}

// Create user with posts
export function createAuthorWithPosts(postCount = 5) {
  const author = createUserWithProfile();
  
  const posts = Array.from({ length: postCount }, () => {
    const published = faker.datatype.boolean({ probability: 0.7 });
    return postFactory.build({
      authorId: author.id,
      published,
    });
  });
  
  return {
    author,
    posts,
  };
}

// Create complete test dataset
export function createTestDataset() {
  const users = userFactory.buildMany(10);
  const admins = [createAdminUser(), createAdminUser()];
  
  const posts = users.flatMap(user =>
    postFactory.buildMany(
      faker.number.int({ min: 1, max: 5 }),
      { authorId: user.id }
    )
  );
  
  const comments = posts.flatMap(post =>
    commentFactory.buildMany(
      faker.number.int({ min: 0, max: 10 }),
      { postId: post.id }
    )
  );
  
  return {
    users: [...users, ...admins],
    posts,
    comments,
    stats: {
      totalUsers: users.length + admins.length,
      totalPosts: posts.length,
      publishedPosts: posts.filter(p => p.published).length,
      totalComments: comments.length,
    },
  };
}
```

### Schritt 6: Main Export File
Erstelle `test/factories/index.ts`:

```typescript
// Re-export all factories
export * from './base';
export * from './user.factory';
export * from './post.factory';
export * from './comment.factory';
export * from './relationships';

// Main factories object
import { userFactory, profileFactory } from './user.factory';
import { postFactory } from './post.factory';
import { commentFactory } from './comment.factory';

export const factories = {
  user: userFactory,
  profile: profileFactory,
  post: postFactory,
  comment: commentFactory,
};

// Preset configurations
export const presets = {
  adminUser: () => userFactory.build({ role: 'ADMIN' }),
  regularUser: () => userFactory.build({ role: 'USER' }),
  publishedPost: () => postFactory.build({ published: true }),
  draftPost: () => postFactory.build({ published: false }),
  approvedComment: () => commentFactory.build({ approved: true }),
};
```

## Verifizierung

### Test 1: Factory Import
```typescript
// test-factories.test.ts
import { factories, userFactory, postFactory } from './test/factories';
import { describe, it, expect } from 'vitest';

describe('Factories', () => {
  it('should create user', () => {
    const user = userFactory.build();
    expect(user.id).toBeDefined();
    expect(user.email).toMatch(/^[^@]+@[^@]+$/);
  });
  
  it('should create post', () => {
    const post = postFactory.build();
    expect(post.title).toBeDefined();
    expect(post.slug).toBeDefined();
  });
  
  it('should override properties', () => {
    const user = userFactory.build({ name: 'John Doe' });
    expect(user.name).toBe('John Doe');
  });
  
  it('should create many', () => {
    const users = userFactory.buildMany(5);
    expect(users).toHaveLength(5);
    expect(new Set(users.map(u => u.id)).size).toBe(5); // All unique
  });
});
```

### Test 2: Relationship Factories
```typescript
import { createBlogPostWithComments, createAuthorWithPosts } from './test/factories/relationships';

describe('Relationship Factories', () => {
  it('should create blog post with comments', () => {
    const data = createBlogPostWithComments({ 
      commentCount: 5,
      includeAuthor: true 
    });
    
    expect(data.post).toBeDefined();
    expect(data.author).toBeDefined();
    expect(data.comments).toHaveLength(5);
  });
  
  it('should create author with posts', () => {
    const data = createAuthorWithPosts(3);
    
    expect(data.author).toBeDefined();
    expect(data.posts).toHaveLength(3);
    expect(data.posts[0].authorId).toBe(data.author.id);
  });
});
```

## Erfolgskriterien
- [ ] Base factory utilities erstellt
- [ ] User & Profile factories implementiert
- [ ] Post factory mit verschiedenen Status
- [ ] Comment factory mit Thread-Support
- [ ] Relationship factories für komplexe Daten
- [ ] Main export file mit allen factories
- [ ] Realistische Testdaten mit Faker.js
- [ ] Override-Möglichkeiten funktionieren
- [ ] BuildMany für Batch-Erstellung

## Wichtige Hinweise

### Faker.js Seed
- Für konsistente Tests kann ein Seed gesetzt werden
- In CI/CD sollte der Seed random bleiben für bessere Coverage

### Type Safety
- Nutze Prisma Generated Types für Type Safety
- Partial<T> für Override-Parameter

### Performance
- Factories sollten schnell sein
- Vermeide komplexe Berechnungen in Factories

## Potentielle Probleme

### Problem: Prisma Types nicht gefunden
**Lösung**: Prisma generate ausführen
```bash
npx prisma generate
```

### Problem: Faker generiert ungültige Daten
**Lösung**: Validierung hinzufügen
```typescript
email: faker.internet.email().toLowerCase(), // Ensure lowercase
```

### Problem: Zirkuläre Dependencies
**Lösung**: Separate Dateien für verschiedene Factories

## Rollback Plan
Falls Factories Probleme machen:
```typescript
// Nutze simple Mock-Objekte
const mockUser = { id: '1', email: 'test@test.com' };
```

## Zeitschätzung
- Base Factory Setup: 5 Minuten
- User Factory: 8 Minuten
- Post Factory: 8 Minuten
- Comment Factory: 6 Minuten
- Relationships: 6 Minuten
- Main Export: 2 Minuten
- Verifizierung: 3 Minuten
- **Total: 38 Minuten**

## Nächster Schritt
Nach erfolgreicher Factory-Erstellung → [09.06 UI Component Tests](./09.06-ui-component-tests.md)