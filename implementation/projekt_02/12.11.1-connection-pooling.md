# Sub-Task 12.11.1: Connection Pooling für AI Provider

## Ziel
Implementierung von keep-alive HTTP-Verbindungen, um den Overhead bei wiederholten API-Anfragen an die AI-Provider zu reduzieren. Reduziert TCP-Handshake-Overhead um 30-50%.

## Voraussetzungen
- AI Adapter Grundstruktur implementiert
- Provider-Konfigurationen vorhanden
- Node.js https/http Module verfügbar

## Umfang
- Globaler HTTP/HTTPS Agent mit Connection Pooling
- Provider-spezifische Agent-Konfiguration
- Connection Lifecycle Management
- Performance Monitoring

## Implementierung

### Schritt 1: Global HTTP Agent Setup
Erstelle `packages/ai-adapter/src/connection/http-agent.ts`:

```typescript
import https from 'https';
import http from 'http';

/**
 * Globale HTTP/HTTPS Agents für Connection Pooling
 * Reduziert TCP-Handshake Overhead durch Wiederverwendung von Verbindungen
 */
export class ConnectionPoolManager {
  private static instance: ConnectionPoolManager;
  private agents: Map<string, https.Agent | http.Agent> = new Map();
  
  // Default Konfiguration für optimale Performance
  private defaultConfig = {
    keepAlive: true,
    keepAliveMsecs: 60000, // Keep connections alive for 60 seconds
    maxSockets: 50, // Max concurrent connections per host
    maxFreeSockets: 10, // Max idle connections per host
    timeout: 30000, // Socket timeout 30 seconds
    scheduling: 'lifo' as const // Last-in-first-out for better cache locality
  };

  private constructor() {}

  static getInstance(): ConnectionPoolManager {
    if (!ConnectionPoolManager.instance) {
      ConnectionPoolManager.instance = new ConnectionPoolManager();
    }
    return ConnectionPoolManager.instance;
  }

  /**
   * Get or create an agent for a specific provider
   */
  getAgent(providerId: string, isHttps = true): https.Agent | http.Agent {
    const key = `${providerId}-${isHttps ? 'https' : 'http'}`;
    
    if (!this.agents.has(key)) {
      const AgentClass = isHttps ? https.Agent : http.Agent;
      const agent = new AgentClass(this.defaultConfig);
      this.agents.set(key, agent);
    }
    
    return this.agents.get(key)!;
  }

  /**
   * Create a custom agent with specific configuration
   */
  createCustomAgent(
    providerId: string,
    config: Partial<https.AgentOptions>
  ): https.Agent {
    const mergedConfig = { ...this.defaultConfig, ...config };
    const agent = new https.Agent(mergedConfig);
    this.agents.set(`${providerId}-custom`, agent);
    return agent;
  }

  /**
   * Get connection statistics for monitoring
   */
  getStats(providerId: string): ConnectionStats {
    const agent = this.agents.get(`${providerId}-https`) as https.Agent;
    
    if (!agent) {
      return {
        activeSockets: 0,
        freeSockets: 0,
        pendingRequests: 0
      };
    }

    // Access internal agent properties for stats
    const sockets = (agent as any).sockets || {};
    const freeSockets = (agent as any).freeSockets || {};
    const requests = (agent as any).requests || {};

    return {
      activeSockets: Object.values(sockets).flat().length,
      freeSockets: Object.values(freeSockets).flat().length,
      pendingRequests: Object.values(requests).flat().length
    };
  }

  /**
   * Destroy all connections for a provider
   */
  destroyProvider(providerId: string): void {
    const keys = Array.from(this.agents.keys()).filter(k => 
      k.startsWith(providerId)
    );
    
    keys.forEach(key => {
      const agent = this.agents.get(key);
      if (agent) {
        agent.destroy();
        this.agents.delete(key);
      }
    });
  }

  /**
   * Destroy all agents and connections
   */
  destroyAll(): void {
    this.agents.forEach(agent => agent.destroy());
    this.agents.clear();
  }
}

interface ConnectionStats {
  activeSockets: number;
  freeSockets: number;
  pendingRequests: number;
}
```

### Schritt 2: Provider Integration
Update `packages/ai-adapter/src/providers/base-provider.ts`:

```typescript
import { ConnectionPoolManager } from '../connection/http-agent';
import fetch, { RequestInit } from 'node-fetch';

export abstract class BaseProvider {
  protected connectionPool: ConnectionPoolManager;
  protected agentId: string;

  constructor(protected config: ProviderConfig) {
    this.connectionPool = ConnectionPoolManager.getInstance();
    this.agentId = this.config.id || this.constructor.name;
  }

  /**
   * Make HTTP request with connection pooling
   */
  protected async makeRequest(
    url: string,
    options: RequestInit = {}
  ): Promise<Response> {
    const agent = this.connectionPool.getAgent(this.agentId, true);
    
    const enhancedOptions: RequestInit = {
      ...options,
      agent,
      headers: {
        'Connection': 'keep-alive',
        'Keep-Alive': 'timeout=60',
        ...options.headers
      }
    };

    // Add performance tracking
    const startTime = performance.now();
    
    try {
      const response = await fetch(url, enhancedOptions);
      
      // Track successful request
      this.trackPerformance(startTime, true);
      
      return response;
    } catch (error) {
      // Track failed request
      this.trackPerformance(startTime, false);
      throw error;
    }
  }

  private trackPerformance(startTime: number, success: boolean): void {
    const duration = performance.now() - startTime;
    const stats = this.connectionPool.getStats(this.agentId);
    
    // Log performance metrics
    if (process.env.DEBUG_CONNECTIONS) {
      console.log(`[${this.agentId}] Request completed:`, {
        duration: `${duration.toFixed(2)}ms`,
        success,
        connections: stats
      });
    }
  }

  /**
   * Clean up provider connections
   */
  destroy(): void {
    this.connectionPool.destroyProvider(this.agentId);
  }
}
```

### Schritt 3: OpenAI Provider mit Connection Pooling
Update `packages/ai-adapter/src/providers/openai.ts`:

```typescript
import OpenAI from 'openai';
import { BaseProvider } from './base-provider';
import { ConnectionPoolManager } from '../connection/http-agent';

export class OpenAIProvider extends BaseProvider {
  private client: OpenAI;

  constructor(config: OpenAIConfig) {
    super(config);
    
    // Get the connection pool agent
    const agent = this.connectionPool.getAgent('openai', true);
    
    // Configure OpenAI client with custom agent
    this.client = new OpenAI({
      apiKey: config.apiKey,
      httpAgent: agent,
      maxRetries: 2,
      timeout: 30000,
      // Custom fetch with connection pooling
      fetch: async (url: string, init?: RequestInit) => {
        return this.makeRequest(url, {
          ...init,
          headers: {
            ...init?.headers,
            'Authorization': `Bearer ${config.apiKey}`
          }
        });
      }
    });
  }

  async complete(options: AICompletionOptions): Promise<AICompletion> {
    // Connection pooling is automatically used through the configured agent
    const completion = await this.client.chat.completions.create({
      model: options.model || 'gpt-4',
      messages: options.messages,
      temperature: options.temperature,
      stream: false
    });

    return {
      content: completion.choices[0].message.content || '',
      usage: completion.usage
    };
  }
}
```

### Schritt 4: Connection Pool Monitoring
Erstelle `packages/ai-adapter/src/connection/monitor.ts`:

```typescript
import { ConnectionPoolManager } from './http-agent';

export class ConnectionMonitor {
  private connectionPool: ConnectionPoolManager;
  private metricsInterval?: NodeJS.Timer;
  private metrics: ConnectionMetrics[] = [];

  constructor() {
    this.connectionPool = ConnectionPoolManager.getInstance();
  }

  /**
   * Start monitoring connection pool metrics
   */
  startMonitoring(intervalMs = 10000): void {
    this.metricsInterval = setInterval(() => {
      this.collectMetrics();
    }, intervalMs);
  }

  /**
   * Stop monitoring
   */
  stopMonitoring(): void {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
      this.metricsInterval = undefined;
    }
  }

  private collectMetrics(): void {
    const providers = ['openai', 'anthropic', 'google'];
    const timestamp = Date.now();

    providers.forEach(provider => {
      const stats = this.connectionPool.getStats(provider);
      
      this.metrics.push({
        timestamp,
        provider,
        ...stats,
        efficiency: this.calculateEfficiency(stats)
      });
    });

    // Keep only last hour of metrics
    const oneHourAgo = timestamp - 3600000;
    this.metrics = this.metrics.filter(m => m.timestamp > oneHourAgo);
  }

  private calculateEfficiency(stats: any): number {
    const total = stats.activeSockets + stats.freeSockets;
    if (total === 0) return 0;
    
    // Higher free socket ratio = better connection reuse
    return (stats.freeSockets / total) * 100;
  }

  /**
   * Get connection pool health report
   */
  getHealthReport(): HealthReport {
    const latestMetrics = this.getLatestMetrics();
    
    return {
      healthy: this.isHealthy(latestMetrics),
      providers: latestMetrics,
      recommendations: this.getRecommendations(latestMetrics)
    };
  }

  private isHealthy(metrics: any[]): boolean {
    return metrics.every(m => 
      m.pendingRequests < 10 && // Not too many pending
      m.efficiency > 20 // Good connection reuse
    );
  }

  private getRecommendations(metrics: any[]): string[] {
    const recommendations: string[] = [];

    metrics.forEach(m => {
      if (m.pendingRequests > 10) {
        recommendations.push(
          `Provider ${m.provider}: High pending requests. Consider increasing maxSockets.`
        );
      }
      
      if (m.efficiency < 20) {
        recommendations.push(
          `Provider ${m.provider}: Low connection reuse. Check keep-alive settings.`
        );
      }

      if (m.activeSockets > 40) {
        recommendations.push(
          `Provider ${m.provider}: Near socket limit. May need to increase maxSockets.`
        );
      }
    });

    return recommendations;
  }

  private getLatestMetrics(): any[] {
    const providers = ['openai', 'anthropic', 'google'];
    return providers.map(provider => ({
      provider,
      ...this.connectionPool.getStats(provider)
    }));
  }
}

interface ConnectionMetrics {
  timestamp: number;
  provider: string;
  activeSockets: number;
  freeSockets: number;
  pendingRequests: number;
  efficiency: number;
}

interface HealthReport {
  healthy: boolean;
  providers: any[];
  recommendations: string[];
}
```

### Schritt 5: Tests
Erstelle `packages/ai-adapter/src/connection/__tests__/pooling.test.ts`:

```typescript
import { ConnectionPoolManager } from '../http-agent';
import { ConnectionMonitor } from '../monitor';
import nock from 'nock';

describe('Connection Pooling', () => {
  let poolManager: ConnectionPoolManager;
  let monitor: ConnectionMonitor;

  beforeEach(() => {
    poolManager = ConnectionPoolManager.getInstance();
    monitor = new ConnectionMonitor();
  });

  afterEach(() => {
    poolManager.destroyAll();
    monitor.stopMonitoring();
    nock.cleanAll();
  });

  test('should reuse connections', async () => {
    const agent = poolManager.getAgent('test-provider');
    
    // Mock API endpoint
    nock('https://api.test.com')
      .persist()
      .get('/test')
      .reply(200, { success: true });

    // Make multiple requests
    const requests = Array(5).fill(0).map(() =>
      fetch('https://api.test.com/test', { agent })
    );

    await Promise.all(requests);

    // Check connection stats
    const stats = poolManager.getStats('test-provider');
    
    // Should have reused connections
    expect(stats.freeSockets).toBeGreaterThan(0);
  });

  test('should handle provider-specific agents', () => {
    const agent1 = poolManager.getAgent('provider1');
    const agent2 = poolManager.getAgent('provider2');
    
    expect(agent1).not.toBe(agent2);
  });

  test('should clean up connections on destroy', () => {
    poolManager.getAgent('test-provider');
    
    const statsBefore = poolManager.getStats('test-provider');
    expect(statsBefore).toBeDefined();
    
    poolManager.destroyProvider('test-provider');
    
    const statsAfter = poolManager.getStats('test-provider');
    expect(statsAfter.activeSockets).toBe(0);
  });

  test('should monitor connection health', () => {
    monitor.startMonitoring(100);
    
    // Create some activity
    poolManager.getAgent('openai');
    poolManager.getAgent('anthropic');
    
    const report = monitor.getHealthReport();
    
    expect(report.healthy).toBe(true);
    expect(report.providers).toHaveLength(3);
    expect(report.recommendations).toEqual([]);
  });
});
```

## Verifizierung

### Test 1: Connection Reuse
```bash
# Run with debug logging
DEBUG_CONNECTIONS=true npm test -- connection-pooling
```

### Test 2: Performance Benchmark
```typescript
// Benchmark with and without pooling
const withPooling = await benchmarkWithPooling();
const withoutPooling = await benchmarkWithoutPooling();

console.log('Performance improvement:', 
  ((withoutPooling - withPooling) / withoutPooling * 100).toFixed(2) + '%'
);
```

### Test 3: Load Test
```bash
# Simulate high load
npm run test:load -- --connections=100 --duration=60s
```

## Erfolgskriterien
- [ ] HTTP Agent mit keep-alive konfiguriert
- [ ] Connection Pooling für alle Provider aktiv
- [ ] Connections werden wiederverwendet (Stats zeigen freeSockets > 0)
- [ ] Performance-Verbesserung messbar (30-50% weniger Latenz)
- [ ] Monitoring zeigt gesunde Connection-Nutzung
- [ ] Keine Connection Leaks bei Destroy
- [ ] Load Tests erfolgreich

## Potentielle Probleme

### Problem: Connection Limits
**Lösung**: Provider-spezifische Limits konfigurieren
```typescript
// OpenAI hat andere Limits als Anthropic
const openaiAgent = poolManager.createCustomAgent('openai', {
  maxSockets: 25,
  maxFreeSockets: 5
});
```

### Problem: Firewall/Proxy Issues
**Lösung**: Proxy-aware Agent
```typescript
const agent = new https.Agent({
  ...defaultConfig,
  proxy: process.env.HTTPS_PROXY
});
```

### Problem: Memory Leaks durch offene Connections
**Lösung**: Automatic Cleanup
```typescript
setInterval(() => {
  poolManager.cleanupIdleConnections();
}, 300000); // Every 5 minutes
```

## Zeitschätzung
- Implementation: 8 Minuten
- Tests: 4 Minuten
- Monitoring Setup: 3 Minuten
- Verifizierung: 3 Minuten
- **Total: 18 Minuten**

## Nächster Schritt
Nach erfolgreicher Connection Pooling Implementation → [12.11.2 Response Caching](./12.11.2-response-caching.md)