# Task 09.04: Test Utilities - React Testing Helper

## Ziel
Erstellung von Test-Utilities für React Component Testing mit Provider-Wrapping und Custom Render Functions.

## Voraussetzungen
- Task 09.01-09.03 abgeschlossen
- React Testing Library installiert
- Clerk Provider Mocks vorhanden

## Implementierung

### Schritt 1: Test Utils mit Providers
Erstelle `test/utils/test-utils.tsx`:

```typescript
import React, { ReactElement } from 'react';
import { render as rtlRender, RenderOptions } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ClerkProvider } from '@clerk/nextjs';
import userEvent from '@testing-library/user-event';

// Create a new QueryClient for each test
function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
        staleTime: 0,
      },
      mutations: {
        retry: false,
      },
    },
  });
}

interface ProvidersProps {
  children: React.ReactNode;
}

// All providers that wrap the app
function Providers({ children }: ProvidersProps) {
  const queryClient = createTestQueryClient();
  
  return (
    <QueryClientProvider client={queryClient}>
      <ClerkProvider>
        {children}
      </ClerkProvider>
    </QueryClientProvider>
  );
}

// Custom render function
function customRender(
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) {
  return rtlRender(ui, { wrapper: Providers, ...options });
}

// Setup user event
export function setup(jsx: ReactElement) {
  return {
    user: userEvent.setup(),
    ...customRender(jsx),
  };
}

// Re-export everything
export * from '@testing-library/react';
export { customRender as render };
export { userEvent };
```

### Schritt 2: Test Helper Functions
Erstelle `test/utils/helpers.ts`:

```typescript
import { screen, waitFor } from '@testing-library/react';
import { expect } from 'vitest';

// Wait for element to disappear
export async function waitForElementToBeRemoved(
  callback: () => HTMLElement | null,
  options = {}
) {
  await waitFor(
    () => {
      const element = callback();
      expect(element).not.toBeInTheDocument();
    },
    options
  );
}

// Wait for loading to complete
export async function waitForLoadingToFinish() {
  await waitForElementToBeRemoved(
    () => screen.queryByTestId('loading-spinner'),
    { timeout: 3000 }
  );
}

// Assert element has focus
export function assertHasFocus(element: HTMLElement) {
  expect(document.activeElement).toBe(element);
}

// Get by text with partial match
export function getByTextContent(text: string) {
  return screen.getByText((content, element) => {
    const hasText = (element: Element | null): boolean => {
      if (!element) return false;
      const elementText = element.textContent || '';
      return elementText.includes(text);
    };
    return hasText(element);
  });
}

// Debug helper
export function debugDOM(element?: HTMLElement) {
  const target = element || document.body;
  console.log(require('util').inspect(target, false, null, true));
}

// Async assertion helper
export async function expectEventually(
  assertion: () => void,
  { timeout = 3000, interval = 100 } = {}
) {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      assertion();
      return;
    } catch (error) {
      await new Promise(resolve => setTimeout(resolve, interval));
    }
  }
  
  // Final attempt that will throw if it fails
  assertion();
}
```

### Schritt 3: Mock Data Helpers
Erstelle `test/utils/mock-data.ts`:

```typescript
// Common mock data for tests
export const mockUser = {
  id: 'user-test-1',
  email: 'test@example.com',
  name: 'Test User',
  role: 'USER' as const,
  clerkId: 'clerk_test_123',
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-01'),
};

export const mockAdmin = {
  ...mockUser,
  id: 'admin-test-1',
  email: 'admin@example.com',
  name: 'Admin User',
  role: 'ADMIN' as const,
  clerkId: 'clerk_admin_123',
};

export const mockPost = {
  id: 'post-test-1',
  title: 'Test Post',
  slug: 'test-post',
  content: 'This is test content',
  excerpt: 'Test excerpt',
  published: true,
  authorId: mockUser.id,
  author: mockUser,
  publishedAt: new Date('2024-01-01'),
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-01'),
};

export const mockComment = {
  id: 'comment-test-1',
  content: 'Test comment',
  postId: mockPost.id,
  post: mockPost,
  authorId: mockUser.id,
  author: mockUser,
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-01'),
};
```

### Schritt 4: Accessibility Testing Utils
Erstelle `test/utils/a11y.ts`:

```typescript
import { render } from './test-utils';
import { axe, toHaveNoViolations } from 'jest-axe';
import { expect } from 'vitest';

// Extend matchers
expect.extend(toHaveNoViolations);

// Accessibility test helper
export async function testA11y(ui: React.ReactElement) {
  const { container } = render(ui);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
  return results;
}

// Check ARIA attributes
export function checkAriaAttributes(element: HTMLElement) {
  const issues: string[] = [];
  
  // Check for missing labels
  if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
    if (!element.getAttribute('aria-label') && 
        !element.getAttribute('aria-labelledby') &&
        !element.id) {
      issues.push('Input element missing accessible label');
    }
  }
  
  // Check for missing alt text
  if (element.tagName === 'IMG') {
    if (!element.getAttribute('alt')) {
      issues.push('Image missing alt text');
    }
  }
  
  // Check button accessibility
  if (element.tagName === 'BUTTON') {
    const text = element.textContent;
    const ariaLabel = element.getAttribute('aria-label');
    if (!text && !ariaLabel) {
      issues.push('Button missing accessible text');
    }
  }
  
  return issues;
}
```

### Schritt 5: React Hook Testing Utils
Erstelle `test/utils/hooks.ts`:

```typescript
import { renderHook as rtlRenderHook, RenderHookOptions } from '@testing-library/react';
import { Providers } from './test-utils';

// Custom renderHook with providers
export function renderHook<TProps, TResult>(
  render: (props: TProps) => TResult,
  options?: RenderHookOptions<TProps>
) {
  return rtlRenderHook(render, {
    wrapper: Providers as any,
    ...options,
  });
}

// Test async hook
export async function testAsyncHook<T>(
  hook: () => T,
  assertion: (result: T) => void | Promise<void>
) {
  const { result } = renderHook(hook);
  
  await waitFor(async () => {
    await assertion(result.current);
  });
  
  return result;
}
```

### Schritt 6: Network Mock Utils
Erstelle `test/utils/network.ts`:

```typescript
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';

// Override specific handlers for a test
export function mockAPI(
  method: 'get' | 'post' | 'put' | 'patch' | 'delete',
  path: string,
  response: any,
  status = 200
) {
  const handler = http[method](path, () => {
    return HttpResponse.json(response, { status });
  });
  
  server.use(handler);
}

// Mock API error
export function mockAPIError(
  method: 'get' | 'post' | 'put' | 'patch' | 'delete',
  path: string,
  error = 'Internal Server Error',
  status = 500
) {
  const handler = http[method](path, () => {
    return HttpResponse.json(
      { error, success: false },
      { status }
    );
  });
  
  server.use(handler);
}

// Mock network delay
export function mockDelay(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Reset all handlers to defaults
export function resetAPIMocks() {
  server.resetHandlers();
}
```

## Verifizierung

### Test 1: Import Test Utils
```typescript
// test-import.test.ts
import { render, screen, setup } from './test/utils/test-utils';
import { describe, it, expect } from 'vitest';

describe('Test Utils', () => {
  it('should import correctly', () => {
    expect(render).toBeDefined();
    expect(screen).toBeDefined();
    expect(setup).toBeDefined();
  });
});
```

### Test 2: Render mit Providers
```typescript
// test-render.test.tsx
import { render, screen } from './test/utils/test-utils';

function TestComponent() {
  return <div>Test Component</div>;
}

it('renders with providers', () => {
  render(<TestComponent />);
  expect(screen.getByText('Test Component')).toBeInTheDocument();
});
```

### Test 3: User Events
```typescript
// test-user-event.test.tsx
import { setup } from './test/utils/test-utils';

it('handles user events', async () => {
  const { user } = setup(<input type="text" />);
  const input = screen.getByRole('textbox');
  
  await user.type(input, 'Hello');
  expect(input).toHaveValue('Hello');
});
```

## Erfolgskriterien
- [ ] test-utils.tsx mit Provider Wrapper erstellt
- [ ] Custom render function implementiert
- [ ] Setup function mit userEvent erstellt
- [ ] Helper functions für common test scenarios
- [ ] Mock data helpers implementiert
- [ ] Accessibility test utilities
- [ ] Hook testing utilities
- [ ] Network mock utilities
- [ ] Alle Utilities exportiert und importierbar

## Wichtige Hinweise

### Provider Wrapping
- Alle Provider die in der App verwendet werden müssen auch in Tests gewrappt werden
- QueryClient sollte für jeden Test neu erstellt werden um Isolation zu gewährleisten

### UserEvent vs FireEvent
- Bevorzuge `userEvent` über `fireEvent` für realistischere User-Interaktionen
- UserEvent simuliert echte Browser-Events inklusive Delays

### Test Isolation
- Jeder Test sollte unabhängig laufen können
- QueryClient Cache zwischen Tests leeren

## Potentielle Probleme

### Problem: "Cannot find module '@tanstack/react-query'"
**Lösung**: React Query installieren falls verwendet
```bash
npm install -D @tanstack/react-query
```

### Problem: jest-axe Typen fehlen
**Lösung**: Types installieren
```bash
npm install -D jest-axe @types/jest-axe
```

### Problem: Provider nicht gemockt
**Lösung**: Mock in vitest.setup.ts hinzufügen oder echten Provider verwenden

## Rollback Plan
Falls Utils Probleme machen:
```typescript
// Nutze direkt RTL ohne custom wrapper
import { render } from '@testing-library/react';
```

## Zeitschätzung
- Test Utils erstellen: 8 Minuten
- Helper Functions: 6 Minuten
- Mock Data: 4 Minuten
- A11y Utils: 5 Minuten
- Hook & Network Utils: 5 Minuten
- Verifizierung: 3 Minuten
- **Total: 31 Minuten**

## Nächster Schritt
Nach erfolgreicher Utils-Erstellung → [09.05 Test Factories](./09.05-test-factories.md)