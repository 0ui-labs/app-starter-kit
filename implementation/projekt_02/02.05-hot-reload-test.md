# 02.05 - Development Hot Reload Test

## Ziel
Sicherstellen dass das Singleton Pattern bei Hot Reload (HMR) keine Memory Leaks verursacht und Turbopack-kompatibel ist.

## Voraussetzungen
- [ ] Schritte 02.01 bis 02.04 abgeschlossen
- [ ] Development Server kann gestartet werden
- [ ] Eine Seite die PrismaClient verwendet

## Test 1: Development Server Start

### 1. Starte Development Server
```bash
# Aus dem Root-Verzeichnis
npm run dev
```

**Erwartung:**
- Server startet auf Port 3004
- Keine PrismaClient Warnungen in der Konsole

### 2. Prüfe Initial Logs
Schaue in der Terminal-Ausgabe nach:
- ✅ Keine "Already 10 PrismaClients are actively running" Warnung
- ✅ Query Logs erscheinen (wenn `NODE_ENV=development`)

## Test 2: Hot Reload Memory Test

### 1. Erstelle Test-Komponente
Erstelle `apps/web/app/test-db/page.tsx`:

```tsx
import { db } from '@starter-kit/db';

export const dynamic = 'force-dynamic';

export default async function TestDBPage() {
  // Zähle User (oder anderes Model aus deinem Schema)
  const count = await db.user.count();
  
  // Log für Debugging
  console.log(`[${new Date().toISOString()}] User count:`, count);
  
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-4">Database Test Page</h1>
      <p>User Count: {count}</p>
      <p>Rendered at: {new Date().toISOString()}</p>
      <p className="mt-4 text-sm text-gray-600">
        Edit this file and save to trigger hot reload
      </p>
    </div>
  );
}
```

### 2. Öffne die Seite
```bash
# Öffne im Browser
open http://localhost:3004/test-db
```

### 3. Trigger Hot Reload
1. Ändere etwas in der Komponente (z.B. den Text)
2. Speichere die Datei
3. Beobachte die Terminal-Ausgabe

**Durchführe dies 5-10 mal**

### 4. Prüfe auf Memory Leaks
Terminal-Ausgabe sollte zeigen:
- ✅ Keine "Already 10 PrismaClients" Warnung
- ✅ Keine steigenden Memory Warnungen
- ✅ HMR Updates funktionieren

## Test 3: Connection Pool Monitoring

### 1. Erstelle Monitoring Endpoint
Erstelle `apps/web/app/api/db-status/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { db } from '@starter-kit/db';

export async function GET() {
  try {
    // Test Query
    const result = await db.$queryRaw`SELECT COUNT(*) FROM pg_stat_activity WHERE datname = current_database()`;
    
    // Get globalThis info
    const globalInfo = {
      hasPrismaClient: !!(globalThis as any).__prisma_client__,
      isInitialized: !!(globalThis as any).__prisma_client_dev_initialized__,
    };
    
    return NextResponse.json({
      status: 'connected',
      connections: result,
      singleton: globalInfo,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    return NextResponse.json({
      status: 'error',
      error: error.message,
    }, { status: 500 });
  }
}
```

### 2. Teste den Endpoint
```bash
# Während der Dev Server läuft
curl http://localhost:3004/api/db-status | jq
```

**Erwartung:**
```json
{
  "status": "connected",
  "connections": [{ "count": "5" }],
  "singleton": {
    "hasPrismaClient": true,
    "isInitialized": true
  },
  "timestamp": "2024-..."
}
```

### 3. Teste nach mehreren Hot Reloads
1. Trigger 5-10 Hot Reloads
2. Rufe den Status erneut ab
3. Connection Count sollte stabil bleiben

## Test 4: Process Memory Test

### 1. Monitor Memory Usage
```bash
# In einem neuen Terminal, finde den Next.js Process
ps aux | grep "next dev" | grep -v grep

# Note die PID und monitore Memory
# macOS:
while true; do 
  ps -o pid,rss,comm -p [PID] | tail -1
  sleep 5
done

# Linux:
watch -n 5 "ps -o pid,rss,comm -p [PID]"
```

### 2. Trigger Multiple Reloads
1. Ändere Dateien mehrmals
2. Beobachte Memory (RSS Wert)

**Erwartung:**
- Memory sollte relativ stabil bleiben
- Kleine Schwankungen sind normal
- Kein kontinuierlicher Anstieg

## Test 5: Turbopack-spezifische Tests

### 1. Prüfe Turbopack Caching
```bash
# Stoppe Dev Server
# Lösche .next Folder
rm -rf apps/web/.next

# Starte neu
npm run dev

# Beobachte erste Ladezeit
```

### 2. Teste Fast Refresh
1. Öffne Developer Tools im Browser
2. Gehe zu Network Tab
3. Ändere die Test-Komponente
4. Sollte nur relevante Module neu laden (nicht full page reload)

## Troubleshooting

### Problem: "Already 10 PrismaClients" Warnung
```typescript
// Prüfe ob globalThis richtig gesetzt wird
console.log('Global PrismaClient:', (globalThis as any).__prisma_client__);
```

### Problem: Memory steigt kontinuierlich
```bash
# Prüfe auf andere Memory Leaks
npm run dev 2>&1 | grep -i "memory\|leak"
```

### Problem: HMR funktioniert nicht
```bash
# Stelle sicher dass Turbopack aktiviert ist
grep "turbo" package.json
# Sollte zeigen: "dev": "next dev --turbo"
```

## Performance Metriken

### Ideal-Werte
- First Load: < 2 Sekunden
- Hot Reload: < 500ms
- Memory nach 10 Reloads: < 10% Anstieg
- Connection Pool: Stabil bei 5-10 Connections

## Cleanup Tests

### 1. Test Process Cleanup
```bash
# Stoppe Dev Server mit Ctrl+C
# Prüfe ob alle Connections geschlossen wurden
ps aux | grep postgres | grep [your-db-name]
```

### 2. Lösche Test-Dateien
```bash
rm -rf apps/web/app/test-db
rm -f apps/web/app/api/db-status/route.ts
```

## Checkliste
- [ ] Dev Server startet ohne Warnungen
- [ ] Hot Reload triggert keine PrismaClient Warnungen
- [ ] Memory bleibt stabil nach mehreren Reloads
- [ ] Connection Pool bleibt stabil
- [ ] Turbopack Fast Refresh funktioniert
- [ ] Clean shutdown ohne hängende Connections

## Nächster Schritt
→ [02.06 - Finale Verifizierung](./02.06-finale-verifizierung.md)

## Wichtige Erkenntnisse
- Singleton Pattern verhindert mehrfache PrismaClient Instanzen
- globalThis überlebt Hot Reloads in Turbopack
- beforeExit Handler sorgt für Clean Disconnect
- Development Logging hilft beim Debugging