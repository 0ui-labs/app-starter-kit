# Teilaufgabe 05.03: Enhanced Middleware Configuration

## Ziel
Implementierung einer umfassenden Middleware mit Route Protection, Security Headers und Role-Based Access Control.

## Zeitschätzung
25 Minuten

## Vorbedingungen
- [ ] 05.01 abgeschlossen (Clerk Dashboard konfiguriert)
- [ ] 05.02 abgeschlossen (TypeScript Definitions erstellt)
- [ ] Clerk SDK installiert und konfiguriert

## Implementierung

### Schritt 1: Backup existierender Middleware
```bash
# Falls bereits eine middleware.ts existiert
cp apps/web/src/middleware.ts apps/web/src/middleware.ts.backup
```

### Schritt 2: Implementiere Enhanced Middleware

Erstelle/Update `apps/web/src/middleware.ts`:

```typescript
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
import { NextRequest, NextResponse } from 'next/server';

// Route Matchers
const publicRoutes = createRouteMatcher([
  '/',
  '/sign-in(.*)',
  '/sign-up(.*)',
  '/pricing',
  '/features',
  '/blog(.*)',
  '/api/webhooks(.*)',
  '/api/health',
]);

const authRoutes = createRouteMatcher([
  '/sign-in(.*)',
  '/sign-up(.*)',
]);

const apiRoutes = createRouteMatcher([
  '/api(.*)',
]);

const adminRoutes = createRouteMatcher([
  '/admin(.*)',
  '/api/admin(.*)',
]);

const moderatorRoutes = createRouteMatcher([
  '/moderate(.*)',
  '/api/moderate(.*)',
]);

// Security Headers
const securityHeaders = {
  'X-Frame-Options': 'DENY',
  'X-Content-Type-Options': 'nosniff',
  'X-XSS-Protection': '1; mode=block',
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
};

// Content Security Policy - angepasst für Clerk
const cspHeader = `
  default-src 'self';
  script-src 'self' 'unsafe-inline' 'unsafe-eval' https://*.clerk.accounts.dev https://*.clerk.com;
  style-src 'self' 'unsafe-inline' https://*.clerk.accounts.dev;
  img-src 'self' blob: data: https: https://*.clerk.accounts.dev https://*.clerk.com;
  font-src 'self' data: https://*.clerk.accounts.dev;
  connect-src 'self' https://*.clerk.accounts.dev https://*.clerk.com wss://*.clerk.accounts.dev;
  frame-src 'self' https://*.clerk.accounts.dev https://*.clerk.com;
  object-src 'none';
  base-uri 'self';
  form-action 'self' https://*.clerk.accounts.dev;
  frame-ancestors 'none';
  upgrade-insecure-requests;
`.replace(/\n/g, ' ').trim();

export default clerkMiddleware(async (auth, req: NextRequest) => {
  const { userId, sessionClaims } = await auth();
  const response = NextResponse.next();

  // Add security headers
  Object.entries(securityHeaders).forEach(([key, value]) => {
    response.headers.set(key, value);
  });
  
  // Add CSP header for production
  if (process.env.NODE_ENV === 'production') {
    response.headers.set('Content-Security-Policy', cspHeader);
  }

  // Handle auth routes (sign-in/sign-up)
  if (authRoutes(req)) {
    if (userId) {
      const afterSignInUrl = '/dashboard';
      return NextResponse.redirect(new URL(afterSignInUrl, req.url));
    }
    return response;
  }

  // Handle public routes
  if (publicRoutes(req)) {
    return response;
  }

  // Require authentication for all other routes
  if (!userId) {
    // Store the attempted URL for redirect after sign-in
    const signInUrl = new URL('/sign-in', req.url);
    signInUrl.searchParams.set('redirect_url', req.url);
    return NextResponse.redirect(signInUrl);
  }

  // Check admin routes
  if (adminRoutes(req)) {
    const isAdmin = sessionClaims?.metadata?.role === 'admin';
    if (!isAdmin) {
      return NextResponse.redirect(new URL('/unauthorized', req.url));
    }
  }

  // Check moderator routes
  if (moderatorRoutes(req)) {
    const isModerator = sessionClaims?.metadata?.role === 'moderator' || 
                       sessionClaims?.metadata?.role === 'admin';
    if (!isModerator) {
      return NextResponse.redirect(new URL('/unauthorized', req.url));
    }
  }

  // Rate limiting for API routes
  if (apiRoutes(req)) {
    const ip = req.headers.get('x-forwarded-for') || 'unknown';
    response.headers.set('X-RateLimit-IP', ip);
    
    // Add API version header
    response.headers.set('X-API-Version', '1.0.0');
  }

  // Session refresh hint
  const sessionAge = sessionClaims?.iat ? Date.now() / 1000 - sessionClaims.iat : 0;
  if (sessionAge > 3600) { // 1 hour
    response.headers.set('X-Session-Refresh', 'true');
  }

  return response;
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};
```

### Schritt 3: Erstelle Test Routes

Erstelle Test-Route für Public Access `apps/web/src/app/api/health/route.ts`:
```typescript
import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json({ status: 'ok', timestamp: new Date().toISOString() });
}
```

Erstelle Test-Route für Admin Access `apps/web/src/app/api/admin/test/route.ts`:
```typescript
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';

export async function GET() {
  const { userId, sessionClaims } = await auth();
  
  return NextResponse.json({
    message: 'Admin route accessed successfully',
    userId,
    role: sessionClaims?.metadata?.role
  });
}
```

## Verifizierung

### Test 1: Public Route Access
```bash
curl -I http://localhost:3004/api/health
# Sollte 200 OK zurückgeben
```

### Test 2: Protected Route ohne Auth
```bash
curl -I http://localhost:3004/dashboard
# Sollte 307 Redirect zu /sign-in zurückgeben
```

### Test 3: Admin Route ohne Admin Role
```bash
# Als User eingeloggt
curl http://localhost:3004/admin
# Sollte zu /unauthorized redirecten
```

### Test 4: Security Headers
```bash
curl -I http://localhost:3004
# Prüfe Headers:
# X-Frame-Options: DENY
# X-Content-Type-Options: nosniff
# X-XSS-Protection: 1; mode=block
```

### Test 5: CSP in Production
```bash
NODE_ENV=production npm run build && npm start
curl -I http://localhost:3004
# Content-Security-Policy header sollte vorhanden sein
```

## Erfolgskriterien
- [ ] Middleware schützt alle nicht-öffentlichen Routes
- [ ] Role-based routing funktioniert (admin, moderator)
- [ ] Security Headers werden gesetzt
- [ ] CSP wird in Production aktiviert
- [ ] Auth redirects funktionieren korrekt
- [ ] API Routes haben Versioning Headers

## Troubleshooting

### Problem: Infinite Redirect Loop
**Lösung:**
1. Prüfe matcher config in `export const config`
2. Stelle sicher dass `/sign-in` in publicRoutes ist
3. Clear Browser Cookies und Cache

### Problem: sessionClaims.metadata ist undefined
**Lösung:**
1. Logout und Login um neues Token zu erhalten
2. Prüfe Clerk Dashboard Config (05.01)
3. Verifiziere TypeScript Definitions (05.02)

### Problem: CSP blockiert Clerk Resources
**Lösung:**
1. Füge fehlende Clerk Domains zum CSP hinzu
2. Prüfe Browser Console für CSP Violations
3. Temporär CSP in Development deaktivieren

### Problem: Middleware wird nicht ausgeführt
**Lösung:**
1. Prüfe Dateiname: Muss `middleware.ts` sein (nicht `.js`)
2. Prüfe Pfad: Muss in `src/` oder Root sein
3. Restart Dev Server nach Änderungen

## Nächster Schritt
Nach erfolgreicher Middleware-Implementierung → [05.04-auth-package-enhancement.md](./05.04-auth-package-enhancement.md)