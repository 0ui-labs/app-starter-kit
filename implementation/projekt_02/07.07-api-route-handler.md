# Arbeitspaket 07.07: API Route Handler

## Ziel
Integration des oRPC Routers in Next.js 15 App Router mit Middleware, Error Handling und CORS Support.

## Kontext
- Next.js 15 App Router
- oRPC Server Integration
- Middleware Chain
- Error Boundaries
- CORS Configuration

## Implementierung

### Schritt 1: Main API Route
Erstelle `app/api/rpc/route.ts`:

```typescript
import { RPCHandler } from '@orpc/server/fetch';
import { router, createContext } from '@starter-kit/api';
import { NextRequest } from 'next/server';

// Create RPC handler
const handler = new RPCHandler(router);

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': process.env.NEXT_PUBLIC_APP_URL || '*',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  'Access-Control-Max-Age': '86400',
};

/**
 * OPTIONS handler for CORS preflight
 */
export async function OPTIONS() {
  return new Response(null, {
    status: 200,
    headers: corsHeaders,
  });
}

/**
 * GET handler for RPC calls
 */
export async function GET(request: NextRequest) {
  try {
    const response = await handler.handle(request as Request, {
      context: await createContext(request as Request),
    });
    
    // Add CORS headers to response
    const headers = new Headers(response.headers);
    Object.entries(corsHeaders).forEach(([key, value]) => {
      headers.set(key, value);
    });
    
    return new Response(response.body, {
      status: response.status,
      headers,
    });
  } catch (error) {
    console.error('API GET Error:', error);
    
    return new Response(
      JSON.stringify({
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred',
        },
      }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders,
        },
      }
    );
  }
}

/**
 * POST handler for RPC calls
 */
export async function POST(request: NextRequest) {
  try {
    const response = await handler.handle(request as Request, {
      context: await createContext(request as Request),
    });
    
    // Add CORS headers to response
    const headers = new Headers(response.headers);
    Object.entries(corsHeaders).forEach(([key, value]) => {
      headers.set(key, value);
    });
    
    return new Response(response.body, {
      status: response.status,
      headers,
    });
  } catch (error) {
    console.error('API POST Error:', error);
    
    return new Response(
      JSON.stringify({
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred',
        },
      }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders,
        },
      }
    );
  }
}
```

### Schritt 2: Middleware Setup
Erstelle `middleware.ts` (im Root-Verzeichnis):

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { rateLimit } from '@/lib/rate-limit';

// Rate limiter (simple in-memory for development)
const rateLimiter = new Map<string, { count: number; resetTime: number }>();

export async function middleware(request: NextRequest) {
  // Only apply to API routes
  if (request.nextUrl.pathname.startsWith('/api')) {
    // Get client identifier
    const ip = request.ip || request.headers.get('x-forwarded-for') || 'unknown';
    const key = `rate-limit:${ip}`;
    
    // Check rate limit (simple implementation)
    const now = Date.now();
    const limit = rateLimiter.get(key);
    
    if (limit) {
      if (limit.resetTime > now) {
        if (limit.count >= 100) {
          // 100 requests per minute
          return new NextResponse(
            JSON.stringify({
              error: {
                code: 'RATE_LIMIT_EXCEEDED',
                message: 'Too many requests',
              },
            }),
            {
              status: 429,
              headers: {
                'Content-Type': 'application/json',
                'X-RateLimit-Limit': '100',
                'X-RateLimit-Remaining': '0',
                'X-RateLimit-Reset': limit.resetTime.toString(),
              },
            }
          );
        }
        limit.count++;
      } else {
        // Reset counter
        rateLimiter.set(key, { count: 1, resetTime: now + 60000 });
      }
    } else {
      // Initialize counter
      rateLimiter.set(key, { count: 1, resetTime: now + 60000 });
    }
    
    // Clean up old entries (every 100 requests)
    if (Math.random() < 0.01) {
      for (const [k, v] of rateLimiter.entries()) {
        if (v.resetTime < now) {
          rateLimiter.delete(k);
        }
      }
    }
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: [
    '/api/:path*',
    // Skip static files
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};
```

### Schritt 3: Environment Configuration
Update `.env.example`:

```bash
# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3004/api/rpc
API_RATE_LIMIT_ENABLED=true
API_RATE_LIMIT_REQUESTS=100
API_RATE_LIMIT_WINDOW=60000

# CORS Configuration
NEXT_PUBLIC_APP_URL=http://localhost:3004
ALLOWED_ORIGINS=http://localhost:3004,http://localhost:3000

# Optional: Redis for distributed rate limiting
UPSTASH_REDIS_REST_URL=
UPSTASH_REDIS_REST_TOKEN=

# Optional: Monitoring
SENTRY_DSN=
AXIOM_TOKEN=
AXIOM_ORG_ID=
```

### Schritt 4: API Health Dashboard
Erstelle `app/api/health/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { db } from '@starter-kit/db';

export async function GET() {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV,
    checks: {
      database: false,
      redis: false,
      auth: false,
    },
  };
  
  // Database check
  try {
    await db.$queryRaw`SELECT 1`;
    health.checks.database = true;
  } catch (error) {
    console.error('Database health check failed:', error);
  }
  
  // Redis check (if configured)
  if (process.env.UPSTASH_REDIS_REST_URL) {
    try {
      const response = await fetch(
        `${process.env.UPSTASH_REDIS_REST_URL}/ping`,
        {
          headers: {
            Authorization: `Bearer ${process.env.UPSTASH_REDIS_REST_TOKEN}`,
          },
        }
      );
      health.checks.redis = response.ok;
    } catch (error) {
      console.error('Redis health check failed:', error);
    }
  }
  
  // Auth check (Clerk)
  try {
    // Simple check if Clerk env vars are set
    health.checks.auth = !!(
      process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY &&
      process.env.CLERK_SECRET_KEY
    );
  } catch (error) {
    console.error('Auth health check failed:', error);
  }
  
  // Determine overall status
  const allHealthy = Object.values(health.checks).every(v => v !== false);
  health.status = allHealthy ? 'healthy' : 'degraded';
  
  return NextResponse.json(health, {
    status: allHealthy ? 200 : 503,
  });
}
```

### Schritt 5: API Documentation Endpoint
Erstelle `app/api/docs/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { router } from '@starter-kit/api';

/**
 * Generate OpenAPI-like documentation from router
 */
function generateDocs(router: any, basePath = ''): any[] {
  const docs: any[] = [];
  
  for (const [key, value] of Object.entries(router)) {
    const path = basePath ? `${basePath}.${key}` : key;
    
    if (typeof value === 'object' && value !== null) {
      if ('handler' in value) {
        // This is a procedure
        docs.push({
          path,
          method: 'POST',
          input: value.input?.shape || null,
          output: value.output?.shape || null,
        });
      } else {
        // Nested router
        docs.push(...generateDocs(value, path));
      }
    }
  }
  
  return docs;
}

export async function GET() {
  const endpoints = generateDocs(router);
  
  const documentation = {
    openapi: '3.0.0',
    info: {
      title: 'Starter Kit API',
      version: '1.0.0',
      description: 'Type-safe API built with oRPC',
    },
    servers: [
      {
        url: process.env.NEXT_PUBLIC_API_URL || '/api/rpc',
        description: 'RPC Server',
      },
    ],
    endpoints: endpoints.map(ep => ({
      path: `/rpc/${ep.path}`,
      method: ep.method,
      description: `RPC procedure: ${ep.path}`,
      requestBody: ep.input ? {
        required: true,
        content: {
          'application/json': {
            schema: { type: 'object' },
          },
        },
      } : undefined,
      responses: {
        200: {
          description: 'Success',
          content: {
            'application/json': {
              schema: { type: 'object' },
            },
          },
        },
      },
    })),
  };
  
  return NextResponse.json(documentation);
}
```

### Schritt 6: Error Monitoring Integration
Erstelle `lib/monitoring.ts`:

```typescript
import * as Sentry from '@sentry/nextjs';

/**
 * Initialize monitoring services
 */
export function initMonitoring() {
  // Sentry
  if (process.env.SENTRY_DSN) {
    Sentry.init({
      dsn: process.env.SENTRY_DSN,
      environment: process.env.NODE_ENV,
      tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
      beforeSend(event, hint) {
        // Filter sensitive data
        if (event.request?.cookies) {
          delete event.request.cookies;
        }
        return event;
      },
    });
  }
}

/**
 * Log API errors
 */
export function logAPIError(
  error: any,
  context: {
    path?: string;
    userId?: string;
    input?: any;
  }
) {
  console.error('API Error:', {
    message: error.message,
    stack: error.stack,
    ...context,
  });
  
  // Send to Sentry
  if (process.env.SENTRY_DSN) {
    Sentry.captureException(error, {
      tags: {
        type: 'api_error',
        path: context.path,
      },
      user: context.userId ? { id: context.userId } : undefined,
      extra: {
        input: context.input,
      },
    });
  }
  
  // Send to Axiom (if configured)
  if (process.env.AXIOM_TOKEN) {
    fetch('https://api.axiom.co/v1/datasets/api-errors/ingest', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.AXIOM_TOKEN}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify([{
        timestamp: new Date().toISOString(),
        level: 'error',
        message: error.message,
        stack: error.stack,
        ...context,
      }]),
    }).catch(err => {
      console.error('Failed to send error to Axiom:', err);
    });
  }
}

/**
 * Log API metrics
 */
export function logAPIMetrics(
  metrics: {
    path: string;
    duration: number;
    status: 'success' | 'error';
    userId?: string;
  }
) {
  // Send to Axiom
  if (process.env.AXIOM_TOKEN) {
    fetch('https://api.axiom.co/v1/datasets/api-metrics/ingest', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.AXIOM_TOKEN}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify([{
        timestamp: new Date().toISOString(),
        ...metrics,
      }]),
    }).catch(err => {
      console.error('Failed to send metrics to Axiom:', err);
    });
  }
}
```

## Verifizierung

### Test 1: Basic RPC Call
```bash
curl -X POST http://localhost:3004/api/rpc \
  -H "Content-Type: application/json" \
  -d '{"path": "health"}'

# Should return:
# { "success": true, "data": { "status": "ok", ... } }
```

### Test 2: Health Check
```bash
curl http://localhost:3004/api/health

# Should return:
# { "status": "healthy", "checks": { ... } }
```

### Test 3: CORS Headers
```bash
curl -X OPTIONS http://localhost:3004/api/rpc \
  -H "Origin: http://localhost:3000" \
  -H "Access-Control-Request-Method: POST"

# Should return proper CORS headers
```

### Test 4: Rate Limiting
```bash
# Make rapid requests
for i in {1..150}; do
  curl -X POST http://localhost:3004/api/rpc \
    -H "Content-Type: application/json" \
    -d '{"path": "health"}'
done

# Should get 429 error after limit
```

### Test 5: API Documentation
```bash
curl http://localhost:3004/api/docs

# Should return OpenAPI-like documentation
```

## Erfolgskriterien
- [ ] RPC Route Handler funktioniert
- [ ] CORS richtig konfiguriert
- [ ] Rate Limiting aktiv
- [ ] Health Endpoint verfügbar
- [ ] Error Monitoring integriert
- [ ] API Dokumentation generiert

## Potentielle Probleme

### Problem: TypeScript Fehler bei Request/Response
**Lösung**: Type Casting für Next.js Request Types:
```typescript
const response = await handler.handle(
  request as unknown as Request,
  { context }
);
```

### Problem: CORS Preflight schlägt fehl
**Lösung**: OPTIONS Handler korrekt implementieren und Middleware Order prüfen

### Problem: Rate Limiting Memory Leak
**Lösung**: Regelmäßige Cleanup-Routine für alte Einträge implementieren

## Nächste Schritte
- Weiter mit 07.08: Testing und Verifikation