# 11.08 Testing & Mocking

## Ziel
Implementierung einer umfassenden Test-Suite mit Mock-Providern für Entwicklung und Testing ohne API-Kosten.

## Umfang
- Mock provider implementation
- Test fixtures und utilities
- Integration tests
- Performance tests
- Development mode mit mock responses

## Tasks

### 1. Mock Provider Implementation
```typescript
// packages/ai-adapter/src/providers/mock.ts
export interface MockResponse {
  pattern: RegExp | string;
  response: CompletionResponse | ((request: CompletionRequest) => CompletionResponse);
  delay?: number;
  error?: AIError;
}

export class MockProvider extends BaseAIProvider {
  private responses: MockResponse[] = [];
  private defaultResponse: CompletionResponse = {
    content: 'This is a mock response',
    model: 'mock-model',
    usage: {
      promptTokens: 10,
      completionTokens: 10,
      totalTokens: 20,
    },
  };
  
  async initialize(config: MockConfig): Promise<void> {
    this.config = config;
    
    // Load predefined responses
    if (config.responses) {
      this.responses = config.responses;
    }
    
    // Load from fixture files
    if (config.fixtureFile) {
      await this.loadFixtures(config.fixtureFile);
    }
  }
  
  async complete(request: CompletionRequest): Promise<CompletionResponse> {
    // Find matching response
    const response = this.findResponse(request);
    
    // Simulate network delay
    if (response.delay) {
      await this.sleep(response.delay);
    }
    
    // Simulate error if configured
    if (response.error) {
      throw response.error;
    }
    
    // Return response
    if (typeof response.response === 'function') {
      return response.response(request);
    }
    
    return response.response;
  }
  
  async *stream(request: CompletionRequest): AsyncIterableIterator<StreamChunk> {
    const response = await this.complete(request);
    
    // Simulate streaming by breaking response into chunks
    const words = response.content.split(' ');
    
    for (const word of words) {
      await this.sleep(50); // Simulate streaming delay
      
      yield {
        id: generateId(),
        type: 'content',
        delta: word + ' ',
      };
    }
    
    yield {
      id: generateId(),
      type: 'done',
      usage: response.usage,
    };
  }
  
  private findResponse(request: CompletionRequest): MockResponse {
    const lastMessage = request.messages[request.messages.length - 1].content;
    
    for (const mockResponse of this.responses) {
      const pattern = mockResponse.pattern;
      
      if (typeof pattern === 'string') {
        if (lastMessage.includes(pattern)) {
          return mockResponse;
        }
      } else if (pattern instanceof RegExp) {
        if (pattern.test(lastMessage)) {
          return mockResponse;
        }
      }
    }
    
    // Return default response
    return {
      pattern: '',
      response: this.defaultResponse,
    };
  }
  
  // Helper to add responses dynamically
  addResponse(response: MockResponse): void {
    this.responses.push(response);
  }
  
  // Helper to simulate different scenarios
  simulateError(error: AIError): void {
    this.responses.unshift({
      pattern: /.*/,
      response: this.defaultResponse,
      error,
    });
  }
  
  simulateRateLimit(): void {
    this.simulateError(new RateLimitError('mock', 5));
  }
  
  simulateTimeout(): void {
    this.simulateError(new TimeoutError(30000));
  }
}
```

### 2. Test Fixtures
```typescript
// packages/ai-adapter/src/testing/fixtures.ts
export const TEST_FIXTURES = {
  chatCompletion: {
    simple: {
      request: {
        messages: [
          { role: 'user', content: 'Hello' },
        ],
      },
      response: {
        content: 'Hello! How can I help you today?',
        model: 'test-model',
        usage: { promptTokens: 2, completionTokens: 8, totalTokens: 10 },
      },
    },
    
    withSystemPrompt: {
      request: {
        messages: [
          { role: 'system', content: 'You are a helpful assistant' },
          { role: 'user', content: 'What is 2+2?' },
        ],
      },
      response: {
        content: '2 + 2 equals 4.',
        model: 'test-model',
        usage: { promptTokens: 10, completionTokens: 5, totalTokens: 15 },
      },
    },
    
    functionCalling: {
      request: {
        messages: [
          { role: 'user', content: 'What is the weather in San Francisco?' },
        ],
        tools: [{
          name: 'get_weather',
          description: 'Get the weather for a location',
          parameters: {
            type: 'object',
            properties: {
              location: { type: 'string' },
            },
          },
        }],
      },
      response: {
        content: '',
        toolCalls: [{
          id: 'call_123',
          name: 'get_weather',
          arguments: { location: 'San Francisco' },
        }],
        model: 'test-model',
        usage: { promptTokens: 20, completionTokens: 10, totalTokens: 30 },
      },
    },
  },
  
  errors: {
    rateLimit: new RateLimitError('test', 60),
    timeout: new TimeoutError(30000),
    tokenLimit: new TokenLimitError('test', 5000, 4000),
    authentication: new AuthenticationError('test'),
  },
};

// Fixture loader
export class FixtureLoader {
  static load(category: string, name: string): any {
    return TEST_FIXTURES[category]?.[name];
  }
  
  static loadRequest(name: string): CompletionRequest {
    return this.load('chatCompletion', name)?.request;
  }
  
  static loadResponse(name: string): CompletionResponse {
    return this.load('chatCompletion', name)?.response;
  }
  
  static loadError(name: string): AIError {
    return this.load('errors', name);
  }
}
```

### 3. Test Utilities
```typescript
// packages/ai-adapter/src/testing/utils.ts
export class TestUtils {
  // Create a test adapter with mock provider
  static createTestAdapter(config?: Partial<MockConfig>): AIAdapter {
    const adapter = new AIAdapter();
    const mockProvider = new MockProvider();
    
    mockProvider.initialize({
      responses: [
        {
          pattern: /test/,
          response: {
            content: 'Test response',
            model: 'mock',
            usage: { promptTokens: 1, completionTokens: 2, totalTokens: 3 },
          },
        },
      ],
      ...config,
    });
    
    adapter.registerProvider('mock', mockProvider);
    adapter.setDefaultProvider('mock');
    
    return adapter;
  }
  
  // Create spy for tracking calls
  static createProviderSpy(provider: AIProvider): ProviderSpy {
    const spy = {
      calls: [],
      responses: [],
      errors: [],
    };
    
    // Wrap methods
    const originalComplete = provider.complete.bind(provider);
    provider.complete = async (request: CompletionRequest) => {
      spy.calls.push({ method: 'complete', request, timestamp: Date.now() });
      
      try {
        const response = await originalComplete(request);
        spy.responses.push(response);
        return response;
      } catch (error) {
        spy.errors.push(error);
        throw error;
      }
    };
    
    return spy;
  }
  
  // Assert response matches expected
  static assertResponse(
    actual: CompletionResponse,
    expected: Partial<CompletionResponse>
  ): void {
    if (expected.content !== undefined) {
      expect(actual.content).toBe(expected.content);
    }
    
    if (expected.model !== undefined) {
      expect(actual.model).toBe(expected.model);
    }
    
    if (expected.usage !== undefined) {
      expect(actual.usage).toEqual(expected.usage);
    }
    
    if (expected.toolCalls !== undefined) {
      expect(actual.toolCalls).toEqual(expected.toolCalls);
    }
  }
  
  // Wait for streaming to complete
  static async collectStream(
    stream: AsyncIterableIterator<StreamChunk>
  ): Promise<StreamChunk[]> {
    const chunks: StreamChunk[] = [];
    
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    
    return chunks;
  }
  
  // Generate test messages
  static generateMessages(count: number): Message[] {
    const messages: Message[] = [];
    
    for (let i = 0; i < count; i++) {
      messages.push({
        role: i % 2 === 0 ? 'user' : 'assistant',
        content: `Message ${i}`,
      });
    }
    
    return messages;
  }
}
```

### 4. Integration Tests
```typescript
// packages/ai-adapter/src/testing/integration.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { AIAdapter } from '../index';
import { TestUtils } from './utils';
import { FixtureLoader } from './fixtures';

describe('AI Adapter Integration', () => {
  let adapter: AIAdapter;
  
  beforeEach(() => {
    adapter = TestUtils.createTestAdapter();
  });
  
  describe('Basic Completion', () => {
    it('should complete a simple request', async () => {
      const request = FixtureLoader.loadRequest('simple');
      const response = await adapter.complete(request);
      
      expect(response).toBeDefined();
      expect(response.content).toBeTruthy();
      expect(response.usage).toBeDefined();
    });
    
    it('should handle system prompts', async () => {
      const request = FixtureLoader.loadRequest('withSystemPrompt');
      const response = await adapter.complete(request);
      
      expect(response.content).toContain('4');
    });
  });
  
  describe('Streaming', () => {
    it('should stream responses', async () => {
      const request = FixtureLoader.loadRequest('simple');
      const stream = adapter.stream(request);
      const chunks = await TestUtils.collectStream(stream);
      
      expect(chunks.length).toBeGreaterThan(1);
      expect(chunks[chunks.length - 1].type).toBe('done');
    });
  });
  
  describe('Error Handling', () => {
    it('should retry on retryable errors', async () => {
      const provider = new MockProvider();
      let attempts = 0;
      
      provider.addResponse({
        pattern: /.*/,
        response: () => {
          attempts++;
          if (attempts < 3) {
            throw new NetworkError();
          }
          return { content: 'Success after retry', model: 'mock' };
        },
      });
      
      adapter.registerProvider('retry-test', provider);
      const response = await adapter.complete(
        { messages: [{ role: 'user', content: 'test' }] },
        { provider: 'retry-test' }
      );
      
      expect(attempts).toBe(3);
      expect(response.content).toBe('Success after retry');
    });
    
    it('should not retry on non-retryable errors', async () => {
      const provider = new MockProvider();
      provider.simulateError(new AuthenticationError('mock'));
      
      adapter.registerProvider('auth-test', provider);
      
      await expect(
        adapter.complete(
          { messages: [{ role: 'user', content: 'test' }] },
          { provider: 'auth-test' }
        )
      ).rejects.toThrow(AuthenticationError);
    });
  });
  
  describe('Provider Fallback', () => {
    it('should fallback to secondary provider on failure', async () => {
      const primary = new MockProvider();
      primary.simulateError(new NetworkError());
      
      const secondary = new MockProvider();
      secondary.addResponse({
        pattern: /.*/,
        response: { content: 'Fallback response', model: 'secondary' },
      });
      
      adapter.registerProvider('primary', primary);
      adapter.registerProvider('secondary', secondary);
      adapter.setFallbackChain(['primary', 'secondary']);
      
      const response = await adapter.complete({
        messages: [{ role: 'user', content: 'test' }],
      });
      
      expect(response.content).toBe('Fallback response');
      expect(response.model).toBe('secondary');
    });
  });
});
```

### 5. Performance Tests
```typescript
// packages/ai-adapter/src/testing/performance.test.ts
import { describe, it, expect } from 'vitest';
import { TokenCounter, TokenOptimizer } from '../tokens';
import { TestUtils } from './utils';

describe('Performance', () => {
  describe('Token Counting', () => {
    it('should count tokens efficiently', () => {
      const counter = new GPTTokenCounter();
      const text = 'Lorem ipsum '.repeat(1000); // ~2000 tokens
      
      const start = performance.now();
      const tokens = counter.count(text);
      const duration = performance.now() - start;
      
      expect(tokens).toBeGreaterThan(1900);
      expect(tokens).toBeLessThan(2100);
      expect(duration).toBeLessThan(100); // Should be fast
    });
    
    it('should handle large message arrays', () => {
      const counter = new GPTTokenCounter();
      const messages = TestUtils.generateMessages(100);
      
      const start = performance.now();
      const tokens = counter.countMessages(messages);
      const duration = performance.now() - start;
      
      expect(tokens).toBeGreaterThan(0);
      expect(duration).toBeLessThan(200);
    });
  });
  
  describe('Stream Processing', () => {
    it('should handle high-throughput streaming', async () => {
      const adapter = TestUtils.createTestAdapter();
      const promises: Promise<StreamChunk[]>[] = [];
      
      // Start 10 concurrent streams
      for (let i = 0; i < 10; i++) {
        const stream = adapter.stream({
          messages: [{ role: 'user', content: `Stream ${i}` }],
        });
        promises.push(TestUtils.collectStream(stream));
      }
      
      const start = performance.now();
      const results = await Promise.all(promises);
      const duration = performance.now() - start;
      
      expect(results).toHaveLength(10);
      expect(duration).toBeLessThan(5000); // Should complete within 5s
    });
  });
});
```

### 6. Development Mode
```typescript
// packages/ai-adapter/src/testing/dev-mode.ts
export class DevModeAdapter extends AIAdapter {
  constructor(config?: DevModeConfig) {
    super();
    
    // Always use mock provider in dev mode
    const mockProvider = new MockProvider();
    
    // Load development responses
    mockProvider.initialize({
      responses: this.loadDevResponses(config),
      defaultDelay: config?.simulateLatency ? 500 : 0,
    });
    
    this.registerProvider('dev', mockProvider);
    this.setDefaultProvider('dev');
    
    // Add console logging
    if (config?.enableLogging) {
      this.enableDevLogging();
    }
  }
  
  private loadDevResponses(config?: DevModeConfig): MockResponse[] {
    return [
      // Code generation
      {
        pattern: /write|create|generate.*code/i,
        response: {
          content: '```typescript\nfunction example() {\n  return "Generated code";\n}\n```',
          model: 'dev-mode',
        },
      },
      
      // Explanations
      {
        pattern: /explain|what|how/i,
        response: {
          content: 'This is a detailed explanation of the concept you asked about.',
          model: 'dev-mode',
        },
      },
      
      // Error simulation
      {
        pattern: /error|fail/i,
        error: new NetworkError('Simulated error for testing'),
      },
      
      // Custom responses from config
      ...(config?.customResponses || []),
    ];
  }
  
  private enableDevLogging(): void {
    const original = this.complete.bind(this);
    
    this.complete = async (request: CompletionRequest, options?: any) => {
      console.log('[DEV] AI Request:', {
        messages: request.messages.length,
        lastMessage: request.messages[request.messages.length - 1],
      });
      
      const response = await original(request, options);
      
      console.log('[DEV] AI Response:', {
        content: response.content.substring(0, 100) + '...',
        usage: response.usage,
      });
      
      return response;
    };
  }
}

// Usage in development
if (process.env.NODE_ENV === 'development') {
  globalThis.aiAdapter = new DevModeAdapter({
    enableLogging: true,
    simulateLatency: true,
    customResponses: [
      {
        pattern: /my custom pattern/,
        response: { content: 'My custom response', model: 'dev' },
      },
    ],
  });
}
```

## Dateien zu erstellen/ändern
- `packages/ai-adapter/src/providers/mock.ts` - Mock provider
- `packages/ai-adapter/src/testing/fixtures.ts` - Test fixtures
- `packages/ai-adapter/src/testing/utils.ts` - Test utilities
- `packages/ai-adapter/src/testing/integration.test.ts` - Integration tests
- `packages/ai-adapter/src/testing/performance.test.ts` - Performance tests
- `packages/ai-adapter/src/testing/dev-mode.ts` - Development mode

## Akzeptanzkriterien
- [ ] Mock provider mit konfigurierbaren responses
- [ ] Test fixtures für common scenarios
- [ ] Test utilities für einfaches testing
- [ ] Integration tests für alle features
- [ ] Performance tests für kritische paths
- [ ] Development mode ohne API calls
- [ ] Error simulation capabilities
- [ ] Stream testing utilities
- [ ] 80%+ test coverage

## Abhängigkeiten
- Vitest test framework
- Alle vorherigen Tasks (11.01-11.07)

## Geschätzter Aufwand
60-75 Minuten