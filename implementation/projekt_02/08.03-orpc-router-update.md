# Arbeitspaket 08.03: oRPC Router mit Error Handling aktualisieren

## Ziel
Integration des Error Handling Systems in den oRPC Router mit Middleware für automatisches Error Logging und strukturierte Error Responses.

## Kontext
- **Basis**: Error Setup aus 08.01 und Prisma Handler aus 08.02
- **Ziel**: Konsistentes Error Handling über alle API Procedures

## Implementierung

### Schritt 1: Error Logging Middleware
Update `packages/api/src/router.ts`:

```typescript
import { baseRouter, logError } from './errors';
import { handlePrismaError } from './errors/prisma-handler';
import { db } from '@starter-kit/db';
import * as z from 'zod';
import { auth } from '@starter-kit/auth';

// Error logging middleware
const errorLogger = baseRouter.middleware(async ({ next, procedure }) => {
  try {
    return await next();
  } catch (error) {
    logError(error, { 
      procedure: procedure?.name || 'unknown',
      timestamp: new Date().toISOString()
    });
    throw error;
  }
});

// Auth middleware with error handling
const authenticated = errorLogger.middleware(async ({ next, errors }) => {
  const session = await auth();
  
  if (!session?.user) {
    throw errors.UNAUTHORIZED({
      message: 'Bitte melden Sie sich an'
    });
  }
  
  return next({
    context: { user: session.user }
  });
});
```

### Schritt 2: Base Router mit Common Procedures
Erweitere `packages/api/src/router.ts`:

```typescript
// Health check procedure
const health = errorLogger
  .procedure('health')
  .handler(async () => {
    try {
      // Test database connection
      await db.$queryRaw`SELECT 1`;
      return { 
        status: 'ok',
        timestamp: new Date().toISOString(),
        database: 'connected'
      };
    } catch (error) {
      throw new ORPCError('DATABASE_ERROR', {
        message: 'Datenbankverbindung fehlgeschlagen'
      });
    }
  });
```

### Schritt 3: User Procedures mit Error Handling
Erweitere `packages/api/src/router.ts`:

```typescript
// User procedures with proper error handling
const userCreate = authenticated
  .procedure('user.create')
  .input(z.object({
    email: z.string().email({ message: 'Ungültige E-Mail-Adresse' }),
    name: z.string().min(2, 'Name muss mindestens 2 Zeichen haben'),
    role: z.enum(['USER', 'ADMIN']).optional().default('USER'),
  }))
  .errors({
    USER_ALREADY_EXISTS: {
      message: 'Benutzer existiert bereits',
      data: z.object({ email: z.string() }),
    },
    INVALID_ROLE: {
      message: 'Ungültige Rolle',
    },
  })
  .handler(async ({ input, errors, context }) => {
    try {
      // Check if user already exists
      const existing = await db.user.findUnique({
        where: { email: input.email }
      });
      
      if (existing) {
        throw errors.USER_ALREADY_EXISTS({
          data: { email: input.email }
        });
      }
      
      // Create user
      const user = await db.user.create({
        data: {
          ...input,
          createdBy: context.user.id,
        },
      });
      
      return user;
    } catch (error) {
      // Check if it's already an oRPC error
      if (error instanceof ORPCError) {
        throw error;
      }
      // Handle Prisma errors
      handlePrismaError(error);
    }
  });

const userGet = authenticated
  .procedure('user.get')
  .input(z.object({
    id: z.string().uuid('Ungültige User ID'),
  }))
  .handler(async ({ input, errors }) => {
    try {
      const user = await db.user.findUnique({
        where: { id: input.id },
        include: {
          posts: true,
          profile: true,
        },
      });
      
      if (!user) {
        throw errors.NOT_FOUND({
          message: 'Benutzer nicht gefunden'
        });
      }
      
      return user;
    } catch (error) {
      if (error instanceof ORPCError) {
        throw error;
      }
      handlePrismaError(error);
    }
  });

const userUpdate = authenticated
  .procedure('user.update')
  .input(z.object({
    id: z.string().uuid(),
    data: z.object({
      name: z.string().optional(),
      email: z.string().email().optional(),
      role: z.enum(['USER', 'ADMIN']).optional(),
    }),
  }))
  .handler(async ({ input, errors, context }) => {
    try {
      // Check permissions
      if (input.id !== context.user.id && context.user.role !== 'ADMIN') {
        throw errors.FORBIDDEN({
          message: 'Sie können nur Ihr eigenes Profil bearbeiten'
        });
      }
      
      const user = await db.user.update({
        where: { id: input.id },
        data: input.data,
      });
      
      return user;
    } catch (error) {
      if (error instanceof ORPCError) {
        throw error;
      }
      handlePrismaError(error);
    }
  });

const userDelete = authenticated
  .procedure('user.delete')
  .input(z.object({
    id: z.string().uuid(),
  }))
  .handler(async ({ input, errors, context }) => {
    try {
      // Only admins can delete users
      if (context.user.role !== 'ADMIN') {
        throw errors.INSUFFICIENT_PERMISSIONS({
          message: 'Nur Administratoren können Benutzer löschen'
        });
      }
      
      await db.user.delete({
        where: { id: input.id },
      });
      
      return { success: true };
    } catch (error) {
      if (error instanceof ORPCError) {
        throw error;
      }
      handlePrismaError(error);
    }
  });
```

### Schritt 4: Rate Limiting Middleware
Erweitere `packages/api/src/router.ts`:

```typescript
// Simple in-memory rate limiting (für Production: Redis verwenden)
const rateLimitMap = new Map<string, { count: number; resetAt: number }>();

const rateLimited = errorLogger.middleware(async ({ next, errors, request }) => {
  const identifier = request?.headers?.['x-forwarded-for'] || 'anonymous';
  const now = Date.now();
  const limit = 100; // 100 requests
  const window = 60 * 1000; // per minute
  
  const current = rateLimitMap.get(identifier);
  
  if (current) {
    if (now < current.resetAt) {
      if (current.count >= limit) {
        throw errors.RATE_LIMIT_EXCEEDED({
          data: { 
            retryAfter: Math.ceil((current.resetAt - now) / 1000)
          }
        });
      }
      current.count++;
    } else {
      rateLimitMap.set(identifier, { count: 1, resetAt: now + window });
    }
  } else {
    rateLimitMap.set(identifier, { count: 1, resetAt: now + window });
  }
  
  return next();
});
```

### Schritt 5: Finaler Router Export
Erweitere `packages/api/src/router.ts`:

```typescript
// Combine all procedures into app router
export const appRouter = {
  health,
  user: {
    create: userCreate,
    get: userGet,
    update: userUpdate,
    delete: userDelete,
    list: userList,
  },
  // Add more namespaces as needed
};

export type AppRouter = typeof appRouter;
```

## Verifizierung

### Test 1: Error Logging
```typescript
// Trigger einen Fehler
await client.user.get({ id: 'invalid-uuid' });
// Sollte in Console mit Kontext geloggt werden
```

### Test 2: Auth Middleware
```typescript
// Ohne Session
await client.user.create({ ... });
// Sollte UNAUTHORIZED werfen
```

### Test 3: Rate Limiting
```typescript
// Sende 101 Requests in einer Minute
for (let i = 0; i < 101; i++) {
  await client.health();
}
// Request 101 sollte RATE_LIMIT_EXCEEDED werfen
```

### Test 4: Permission Check
```typescript
// Als normaler User
await client.user.delete({ id: 'other-user-id' });
// Sollte INSUFFICIENT_PERMISSIONS werfen
```

## Erfolgskriterien
- [ ] Error Logging Middleware implementiert
- [ ] Auth Middleware mit Error Handling
- [ ] Rate Limiting Middleware
- [ ] User Procedures mit vollständigem Error Handling
- [ ] Konsistente Error Responses
- [ ] Permission Checks

## Potentielle Probleme

### Problem: Middleware Reihenfolge
**Lösung**: errorLogger als erste Middleware für vollständiges Logging

### Problem: Context Type Safety
**Lösung**: Proper TypeScript types für context in Middleware

## Zeitschätzung
- Middleware Setup: 10 Minuten
- User Procedures: 10 Minuten
- Total: 20 Minuten