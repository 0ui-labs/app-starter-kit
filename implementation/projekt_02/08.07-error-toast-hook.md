# Arbeitspaket 08.07: Error Toast Hook

## Ziel
Erstellung eines spezialisierten Hooks für Error Handling mit Toast Notifications, der oRPC Errors automatisch in benutzerfreundliche Meldungen übersetzt.

## Kontext
- **Basis**: Toast System aus 08.06
- **Integration**: oRPC Error Types aus 08.01
- **Ziel**: Vereinfachte Error-zu-Toast Konvertierung

## Implementierung

### Schritt 1: Error Toast Hook
Erstelle `apps/web/src/hooks/use-error-toast.ts`:

```typescript
'use client';

import { useToast, toast } from "@/hooks/use-toast";
import { useCallback, useEffect } from "react";
import { isDefinedError } from "@orpc/client";

// Error code to user message mapping
const ERROR_MESSAGES: Record<string, { title: string; description?: string }> = {
  // Validation Errors
  VALIDATION_ERROR: {
    title: "Validierungsfehler",
    description: "Bitte überprüfen Sie Ihre Eingaben",
  },
  INVALID_INPUT: {
    title: "Ungültige Eingabe",
    description: "Die eingegebenen Daten sind nicht korrekt",
  },
  
  // Authentication Errors
  UNAUTHORIZED: {
    title: "Nicht angemeldet",
    description: "Bitte melden Sie sich an, um fortzufahren",
  },
  TOKEN_EXPIRED: {
    title: "Sitzung abgelaufen",
    description: "Bitte melden Sie sich erneut an",
  },
  
  // Authorization Errors
  FORBIDDEN: {
    title: "Zugriff verweigert",
    description: "Sie haben keine Berechtigung für diese Aktion",
  },
  INSUFFICIENT_PERMISSIONS: {
    title: "Fehlende Berechtigungen",
    description: "Ihre Rolle erlaubt diese Aktion nicht",
  },
  
  // Not Found Errors
  NOT_FOUND: {
    title: "Nicht gefunden",
    description: "Die angeforderte Ressource existiert nicht",
  },
  
  // Conflict Errors
  DUPLICATE_RESOURCE: {
    title: "Duplikat",
    description: "Ein Eintrag mit diesen Daten existiert bereits",
  },
  
  // Rate Limiting
  RATE_LIMIT_EXCEEDED: {
    title: "Zu viele Anfragen",
    description: "Bitte warten Sie einen Moment",
  },
  
  // Server Errors
  INTERNAL_ERROR: {
    title: "Serverfehler",
    description: "Ein interner Fehler ist aufgetreten",
  },
  DATABASE_ERROR: {
    title: "Datenbankfehler",
    description: "Problem bei der Datenbankverbindung",
  },
  EXTERNAL_SERVICE_ERROR: {
    title: "Service nicht verfügbar",
    description: "Ein externer Service antwortet nicht",
  },
  
  // Timeout Errors
  TIMEOUT: {
    title: "Zeitüberschreitung",
    description: "Die Anfrage hat zu lange gedauert",
  },
};

interface ErrorDetails {
  code?: string;
  message?: string;
  data?: any;
  field?: string;
  retryAfter?: number;
}

export function useErrorToast() {
  const { toast: showToast } = useToast();

  const showError = useCallback((error: unknown, customTitle?: string) => {
    let title = customTitle || "Fehler";
    let description = "Ein unerwarteter Fehler ist aufgetreten";
    let action = undefined;
    
    // Handle oRPC defined errors
    if (isDefinedError(error)) {
      const errorObj = error as ErrorDetails;
      
      // Get predefined message or use error's message
      const predefinedMsg = errorObj.code ? ERROR_MESSAGES[errorObj.code] : null;
      
      if (predefinedMsg) {
        title = predefinedMsg.title;
        description = predefinedMsg.description || errorObj.message || description;
      } else if (errorObj.message) {
        description = errorObj.message;
      }
      
      // Add field-specific information
      if (errorObj.data?.field || errorObj.field) {
        const fieldName = errorObj.data?.field || errorObj.field;
        description = `${description} (Feld: ${fieldName})`;
      }
      
      // Add retry information for rate limiting
      if (errorObj.code === 'RATE_LIMIT_EXCEEDED' && errorObj.data?.retryAfter) {
        description = `${description}. Versuchen Sie es in ${errorObj.data.retryAfter} Sekunden erneut.`;
      }
      
      // Log detailed error in development
      if (process.env.NODE_ENV === 'development') {
        console.error('Error details:', errorObj);
      }
    } 
    // Handle standard JavaScript errors
    else if (error instanceof Error) {
      // Network errors
      if (error.message.includes('fetch')) {
        title = "Netzwerkfehler";
        description = "Verbindung zum Server fehlgeschlagen";
      } 
      // Chunk load errors
      else if (error.message.includes('Loading chunk')) {
        title = "Ladefehler";
        description = "Anwendung konnte nicht vollständig geladen werden";
        action = {
          label: "Neu laden",
          onClick: () => window.location.reload(),
        };
      }
      // Generic error with message
      else {
        description = error.message;
      }
    }
    // Handle string errors
    else if (typeof error === 'string') {
      description = error;
    }

    // Show the toast
    const toastId = toast.error({
      title,
      description,
      action: action ? (
        <button
          onClick={action.onClick}
          className="text-sm font-medium underline underline-offset-2"
        >
          {action.label}
        </button>
      ) : undefined,
    });

    return toastId;
  }, []);

  const showSuccess = useCallback((message: string, title: string = "Erfolg") => {
    return toast.success({
      title,
      description: message,
    });
  }, []);

  const showInfo = useCallback((message: string, title: string = "Information") => {
    return toast.info({
      title,
      description: message,
    });
  }, []);

  const showWarning = useCallback((message: string, title: string = "Warnung") => {
    return toast.warning({
      title,
      description: message,
    });
  }, []);

  const showLoading = useCallback((message: string = "Laden...") => {
    return toast({
      title: message,
      duration: 0, // Don't auto-dismiss
    });
  }, []);

  // Promise wrapper with toast notifications
  const withToast = useCallback(async <T,>(
    promise: Promise<T>,
    options?: {
      loading?: string;
      success?: string | ((data: T) => string);
      error?: string | ((err: any) => string);
    }
  ): Promise<T> => {
    const { loading, success, error } = options || {};
    
    return toast.promise(
      promise,
      {
        loading: loading || "Verarbeitung läuft...",
        success: success || "Erfolgreich abgeschlossen",
        error: error || ((err) => {
          if (isDefinedError(err)) {
            const errorObj = err as ErrorDetails;
            return ERROR_MESSAGES[errorObj.code!]?.title || errorObj.message || "Fehler aufgetreten";
          }
          return err.message || "Fehler aufgetreten";
        }),
      }
    );
  }, []);

  return {
    showError,
    showSuccess,
    showInfo,
    showWarning,
    showLoading,
    withToast,
  };
}

// Global error listener hook
export function useGlobalErrorListener() {
  const { showError } = useErrorToast();

  useEffect(() => {
    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      console.error('Unhandled promise rejection:', event.reason);
      showError(event.reason, "Unbehandelter Fehler");
    };

    const handleError = (event: ErrorEvent) => {
      console.error('Global error:', event.error);
      showError(event.error, "Anwendungsfehler");
    };

    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    window.addEventListener('error', handleError);

    return () => {
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
      window.removeEventListener('error', handleError);
    };
  }, [showError]);
}
```

### Schritt 2: Form Error Handler
Erstelle `apps/web/src/hooks/use-form-error.ts`:

```typescript
'use client';

import { useErrorToast } from './use-error-toast';
import { useCallback } from 'react';

interface FormError {
  field?: string;
  message: string;
}

export function useFormError() {
  const { showError } = useErrorToast();

  const handleFormError = useCallback((
    error: unknown,
    setFieldError?: (field: string, message: string) => void
  ) => {
    // Extract field-specific errors
    if (error && typeof error === 'object' && 'data' in error) {
      const errorData = (error as any).data;
      
      // If we have field information and a setter, set field error
      if (errorData?.field && setFieldError) {
        const fieldError = errorData.constraints?.join(', ') || 
                          errorData.message || 
                          'Ungültige Eingabe';
        setFieldError(errorData.field, fieldError);
        return;
      }
    }
    
    // Otherwise show toast
    showError(error);
  }, [showError]);

  const clearFormErrors = useCallback((
    clearFieldErrors?: () => void
  ) => {
    clearFieldErrors?.();
  }, []);

  return {
    handleFormError,
    clearFormErrors,
  };
}
```

### Schritt 3: API Error Interceptor
Erstelle `apps/web/src/lib/error-interceptor.ts`:

```typescript
import { toast } from '@/hooks/use-toast';
import { isDefinedError } from '@orpc/client';

// Global error interceptor for API calls
export function setupErrorInterceptor() {
  // Intercept fetch for global error handling
  const originalFetch = window.fetch;
  
  window.fetch = async (...args) => {
    try {
      const response = await originalFetch(...args);
      
      // Handle HTTP error status
      if (!response.ok) {
        if (response.status === 401) {
          toast.error({
            title: "Sitzung abgelaufen",
            description: "Bitte melden Sie sich erneut an",
            action: (
              <button
                onClick={() => window.location.href = '/login'}
                className="text-sm font-medium underline"
              >
                Zur Anmeldung
              </button>
            ),
          });
        } else if (response.status === 403) {
          toast.error({
            title: "Zugriff verweigert",
            description: "Sie haben keine Berechtigung für diese Aktion",
          });
        } else if (response.status >= 500) {
          toast.error({
            title: "Serverfehler",
            description: "Der Server ist momentan nicht erreichbar",
          });
        }
      }
      
      return response;
    } catch (error) {
      // Network errors
      if (error instanceof TypeError && error.message === 'Failed to fetch') {
        toast.error({
          title: "Netzwerkfehler",
          description: "Keine Verbindung zum Server",
        });
      }
      throw error;
    }
  };
}
```

## Verwendung

### Beispiel 1: In React Component
```tsx
import { useErrorToast } from '@/hooks/use-error-toast';

function MyComponent() {
  const { showError, showSuccess, withToast } = useErrorToast();
  
  const handleSubmit = async () => {
    try {
      await api.user.create({ ... });
      showSuccess("Benutzer erfolgreich erstellt");
    } catch (error) {
      showError(error);
    }
  };
  
  // Oder mit Promise wrapper
  const handleSubmitWithToast = () => {
    withToast(
      api.user.create({ ... }),
      {
        loading: "Benutzer wird erstellt...",
        success: "Benutzer erfolgreich erstellt",
      }
    );
  };
}
```

### Beispiel 2: Global Error Listener
```tsx
// In app/layout.tsx
import { useGlobalErrorListener } from '@/hooks/use-error-toast';

function RootLayout({ children }) {
  useGlobalErrorListener();
  return <>{children}</>;
}
```

### Beispiel 3: Form Errors
```tsx
import { useFormError } from '@/hooks/use-form-error';

function MyForm() {
  const { handleFormError } = useFormError();
  const [errors, setErrors] = useState({});
  
  const onSubmit = async (data) => {
    try {
      await api.submit(data);
    } catch (error) {
      handleFormError(error, (field, message) => {
        setErrors(prev => ({ ...prev, [field]: message }));
      });
    }
  };
}
```

## Verifizierung

### Test 1: oRPC Error
```typescript
// Simuliere oRPC Error
const error = { 
  code: 'VALIDATION_ERROR', 
  message: 'Test', 
  data: { field: 'email' } 
};
showError(error);
// Sollte "Validierungsfehler" mit Feld anzeigen
```

### Test 2: Promise mit Toast
```typescript
const promise = new Promise((resolve) => 
  setTimeout(() => resolve('done'), 2000)
);
withToast(promise, { loading: "Laden..." });
// Sollte Loading -> Success Toast zeigen
```

### Test 3: Global Error
```typescript
throw new Error("Unhandled error");
// Sollte automatisch Toast zeigen (mit Global Listener)
```

## Erfolgskriterien
- [ ] Error Toast Hook implementiert
- [ ] oRPC Error Mapping
- [ ] Form Error Handler
- [ ] Promise Wrapper
- [ ] Global Error Listener
- [ ] Deutsche Fehlermeldungen

## Potentielle Probleme

### Problem: Duplicate Toasts
**Lösung**: Toast deduplication in Hook

### Problem: Memory Leaks mit Event Listeners
**Lösung**: Cleanup in useEffect return

## Zeitschätzung
- Error Toast Hook: 10 Minuten
- Form Error Handler: 5 Minuten
- Error Interceptor: 5 Minuten
- Total: 20 Minuten