# Arbeitspaket 03.07: Migration & Testing

## Ziel
Durchf√ºhrung der initialen Migration und umfassende Tests zur Verifizierung der Database Implementation.

## Kontext
- **Package**: `@starter-kit/db`
- **Database**: PostgreSQL (lokal) / Neon (production)
- **Testing**: Vitest mit Prisma Test Utilities

## Implementierung

### Step-by-Step Migration Process

#### 1. Environment Setup
```bash
# Navigate to database package
cd packages/db

# Copy environment template
cp .env.example .env

# Edit .env with your database credentials
# For local development:
DATABASE_URL="postgresql://postgres:password@localhost:5432/starter_kit_dev"

# For Neon (production):
# DATABASE_URL="postgresql://user:password@your-host.neon.tech/dbname?sslmode=require"
```

#### 2. Install Dependencies
```bash
# Install all dependencies
npm install

# Verify Prisma installation
npx prisma --version
```

#### 3. Validate Schema
```bash
# Format and validate schema
npm run schema:format
npm run schema:validate

# Expected output:
# ‚úî Schema formatted successfully
# ‚úî Schema is valid
```

#### 4. Generate Prisma Client
```bash
# Generate Prisma Client
npm run db:generate

# Verify generated files
ls -la generated/prisma/

# Expected files:
# - index.js
# - index.d.ts
# - schema.prisma
# - package.json
```

#### 5. Create Initial Migration
```bash
# Create and apply initial migration
npm run db:migrate -- --name initial_schema

# Expected output:
# ‚úî Migration created successfully
# ‚úî Migration applied successfully
# ‚úî Generating Prisma Client
```

#### 6. Seed Database
```bash
# Run seed script
npm run db:seed

# Expected output:
# üå± Starting database seed...
# üßπ Clearing existing data...
# ‚úÖ Database cleared
# üë§ Creating users...
# ‚úÖ Created 7 users
# üè∑Ô∏è Creating tags...
# ‚úÖ Created 10 tags
# üìù Creating posts...
# ‚úÖ Created 5 posts
# üí¨ Creating comments...
# ‚úÖ Created 17 comments
# üîê Creating sessions...
# ‚úÖ Created 3 sessions
# üîë Creating API keys...
# ‚úÖ Created 3 API keys
# üìã Creating audit logs...
# ‚úÖ Created 3 audit logs
# ü™ù Creating webhook events...
# ‚úÖ Created 2 webhook events
# üéâ Database seeding completed successfully!
```

#### 7. Test Connection
```bash
# Test database connection
npm run test:db

# Expected output:
# üîç Testing database connection...
# ‚úÖ Database connection successful
# üìä Database: PostgreSQL
# üìÅ Tables found: 10
# üìã Testing models:
#    User: 7 records
#    Profile: 7 records
#    Post: 5 records
#    Comment: 17 records
#    Tag: 10 records
#    Session: 3 records
#    AuditLog: 3 records
#    ApiKey: 3 records
#    WebhookEvent: 2 records
# ‚úÖ All models accessible
# üéâ Database connection test completed successfully!
```

#### 8. Open Prisma Studio
```bash
# Open visual database browser
npm run db:studio

# Opens at: http://localhost:5555
# Browse and edit data visually
```

### Test Suite Implementation

Erstelle `packages/db/src/__tests__/client.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { getPrismaClient } from '../client';
import { UserRole, UserStatus, AuditAction } from '../../generated/prisma';

describe('Database Client', () => {
  const prisma = getPrismaClient();
  
  beforeAll(async () => {
    // Clean up test data
    await prisma.user.deleteMany({
      where: { email: { contains: 'test-' } }
    });
  });
  
  afterAll(async () => {
    // Cleanup
    await prisma.user.deleteMany({
      where: { email: { contains: 'test-' } }
    });
    await prisma.$disconnect();
  });
  
  describe('Soft Delete', () => {
    it('should soft delete a user', async () => {
      // Create test user
      const user = await prisma.user.create({
        data: {
          email: 'test-soft-delete@example.com',
          name: 'Test User',
          role: UserRole.USER,
          status: UserStatus.ACTIVE,
        }
      });
      
      // Soft delete
      await prisma.user.delete({ where: { id: user.id } });
      
      // Should not find in normal query
      const found = await prisma.user.findUnique({
        where: { id: user.id }
      });
      expect(found).toBeNull();
      
      // Should find with special method
      const deleted = await prisma.user.findWithDeleted(user.id);
      expect(deleted).toBeDefined();
      expect(deleted?.deletedAt).toBeDefined();
    });
    
    it('should restore a soft deleted user', async () => {
      // Create and delete user
      const user = await prisma.user.create({
        data: {
          email: 'test-restore@example.com',
          name: 'Test User',
          role: UserRole.USER,
          status: UserStatus.ACTIVE,
        }
      });
      
      await prisma.user.delete({ where: { id: user.id } });
      
      // Restore
      await prisma.user.restore(user.id);
      
      // Should find in normal query
      const restored = await prisma.user.findUnique({
        where: { id: user.id }
      });
      expect(restored).toBeDefined();
      expect(restored?.deletedAt).toBeNull();
    });
  });
  
  describe('Extended Methods', () => {
    it('should hard delete a user', async () => {
      // Create test user
      const user = await prisma.user.create({
        data: {
          email: 'test-hard-delete@example.com',
          name: 'Test User',
          role: UserRole.USER,
          status: UserStatus.ACTIVE,
        }
      });
      
      // Hard delete
      await prisma.user.hardDelete(user.id);
      
      // Should not exist at all
      const deleted = await prisma.user.findWithDeleted(user.id);
      expect(deleted).toBeNull();
    });
  });
});
```

Erstelle `packages/db/src/__tests__/utils.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  getPaginationParams,
  buildSearchConditions,
  buildDateRangeFilter,
  hasPermission,
  isOwner,
  getCacheKey,
} from '../utils';
import { UserRole, UserStatus } from '../../generated/prisma';

describe('Database Utilities', () => {
  describe('Pagination', () => {
    it('should calculate pagination params correctly', () => {
      const params = getPaginationParams({ page: 2, limit: 20 });
      
      expect(params.skip).toBe(20);
      expect(params.take).toBe(20);
      expect(params.orderBy).toEqual({ createdAt: 'desc' });
    });
    
    it('should enforce max limit', () => {
      const params = getPaginationParams({ page: 1, limit: 200 });
      
      expect(params.take).toBe(100); // Max limit
    });
    
    it('should handle invalid values', () => {
      const params = getPaginationParams({ page: -1, limit: 0 });
      
      expect(params.skip).toBe(0);
      expect(params.take).toBe(1); // Min limit
    });
  });
  
  describe('Search Conditions', () => {
    it('should build OR conditions for multiple fields', () => {
      const conditions = buildSearchConditions({
        query: 'test',
        fields: ['title', 'content'],
        mode: 'insensitive',
      });
      
      expect(conditions).toEqual({
        OR: [
          { title: { contains: 'test', mode: 'insensitive' } },
          { content: { contains: 'test', mode: 'insensitive' } },
        ]
      });
    });
    
    it('should return undefined for empty query', () => {
      const conditions = buildSearchConditions({
        query: '',
        fields: ['title'],
      });
      
      expect(conditions).toBeUndefined();
    });
  });
  
  describe('Date Range Filter', () => {
    it('should build date range filter', () => {
      const from = '2024-01-01';
      const to = '2024-12-31';
      
      const filter = buildDateRangeFilter('createdAt', from, to);
      
      expect(filter).toEqual({
        createdAt: {
          gte: new Date(from),
          lte: new Date(to),
        }
      });
    });
    
    it('should handle only from date', () => {
      const filter = buildDateRangeFilter('createdAt', '2024-01-01');
      
      expect(filter).toEqual({
        createdAt: {
          gte: new Date('2024-01-01'),
        }
      });
    });
  });
  
  describe('Permissions', () => {
    it('should grant admin all permissions', () => {
      const user = { role: UserRole.ADMIN, status: UserStatus.ACTIVE };
      
      expect(hasPermission(user, 'delete', 'post')).toBe(true);
      expect(hasPermission(user, 'anything', 'anywhere')).toBe(true);
    });
    
    it('should grant moderator specific permissions', () => {
      const user = { role: UserRole.MODERATOR, status: UserStatus.ACTIVE };
      
      expect(hasPermission(user, 'delete', 'comment')).toBe(true);
      expect(hasPermission(user, 'delete', 'user')).toBe(false);
    });
    
    it('should deny inactive users all permissions', () => {
      const user = { role: UserRole.ADMIN, status: UserStatus.INACTIVE };
      
      expect(hasPermission(user, 'read', 'post')).toBe(false);
    });
  });
  
  describe('Ownership', () => {
    it('should validate ownership correctly', () => {
      const userId = 'user-123';
      
      expect(isOwner(userId, { userId })).toBe(true);
      expect(isOwner(userId, { authorId: userId })).toBe(true);
      expect(isOwner(userId, { ownerId: userId })).toBe(true);
      expect(isOwner(userId, { userId: 'other-user' })).toBe(false);
    });
  });
  
  describe('Cache Key', () => {
    it('should generate consistent cache keys', () => {
      const key1 = getCacheKey('user', 'findMany', { where: { id: '123' } });
      const key2 = getCacheKey('user', 'findMany', { where: { id: '123' } });
      
      expect(key1).toBe(key2);
    });
    
    it('should handle missing params', () => {
      const key = getCacheKey('user', 'count');
      
      expect(key).toBe('user:count:');
    });
  });
});
```

### Vitest Configuration
Erstelle `packages/db/vitest.config.ts`:

```typescript
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./src/__tests__/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules',
        'generated',
        'prisma',
        'scripts',
        '*.config.ts',
      ],
    },
    testTimeout: 30000,
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
      '@generated': resolve(__dirname, './generated'),
    },
  },
});
```

Erstelle `packages/db/src/__tests__/setup.ts`:

```typescript
import { config } from 'dotenv';
import { resolve } from 'path';

// Load test environment
config({ path: resolve(__dirname, '../../.env.test') });

// Set test environment
process.env.NODE_ENV = 'test';

// Suppress Prisma logs in tests
process.env.PRISMA_QUERY_LOG = '';
```

### Migration Scripts

Erstelle `packages/db/scripts/migrate-prod.sh`:

```bash
#!/bin/bash

echo "üöÄ Starting production migration..."

# Check environment
if [ "$NODE_ENV" != "production" ]; then
  echo "‚ùå This script must be run in production environment"
  exit 1
fi

# Run migration
echo "üì¶ Deploying migrations..."
npx prisma migrate deploy

# Check status
echo "üìä Checking migration status..."
npx prisma migrate status

echo "‚úÖ Migration completed successfully"
```

### Rollback Plan

Erstelle `packages/db/scripts/rollback.ts`:

```typescript
#!/usr/bin/env tsx

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function rollback() {
  console.log('‚ö†Ô∏è  Starting rollback process...\n');
  
  try {
    // Get migration status
    const { stdout: status } = await execAsync('npx prisma migrate status');
    console.log('Current status:', status);
    
    // Resolve as rolled back
    console.log('üîÑ Rolling back last migration...');
    await execAsync('npx prisma migrate resolve --rolled-back');
    
    console.log('‚úÖ Rollback completed');
    
  } catch (error) {
    console.error('‚ùå Rollback failed:', error);
    console.log('\nüí° For complete reset, run: npm run db:migrate:reset');
    process.exit(1);
  }
}

rollback().catch(console.error);
```

## Testing Commands

### Run Full Test Suite
```bash
cd packages/db

# Run all tests
npm test

# Watch mode
npm run test:watch

# With coverage
npm run test:coverage
```

### Manual Testing
```bash
# 1. Test connection
npm run test:db

# 2. Open Prisma Studio
npm run db:studio

# 3. Check migration status
npm run db:migrate:status

# 4. Validate schema
npm run schema:validate
```

## Troubleshooting

### Common Issues

#### Database Connection Error
```bash
# Check PostgreSQL is running
pg_isready -h localhost -p 5432

# Check credentials
psql -U postgres -h localhost -d starter_kit_dev
```

#### Migration Lock
```bash
# Remove lock if stuck
rm packages/db/prisma/migrations/migration_lock.toml
```

#### Generated Files Missing
```bash
# Regenerate
cd packages/db
rm -rf generated/
npm run db:generate
```

#### Seed Fails
```bash
# Reset and retry
npm run db:migrate:reset
npm run db:seed
```

## Verifizierung Checkliste

### Schema & Migration
- [ ] Schema validates without errors
- [ ] Initial migration created
- [ ] Migration applies successfully
- [ ] All tables created

### Seed Data
- [ ] Seed script runs without errors
- [ ] All test data created
- [ ] Relations properly linked
- [ ] Can login with test credentials

### Client & Features
- [ ] Prisma Client generates
- [ ] Soft delete works
- [ ] Restore function works
- [ ] Hard delete works
- [ ] Extended methods accessible

### Testing
- [ ] Connection test passes
- [ ] Unit tests pass
- [ ] Prisma Studio opens
- [ ] Can query all models

### Production Ready
- [ ] Environment variables documented
- [ ] Migration scripts ready
- [ ] Rollback plan tested
- [ ] Performance acceptable

## Erfolgskriterien
- [ ] Vollst√§ndige Migration durchgef√ºhrt
- [ ] Alle Tests gr√ºn
- [ ] Seed Data erfolgreich
- [ ] Prisma Studio funktioniert
- [ ] Connection Test erfolgreich
- [ ] Soft Delete verifiziert
- [ ] Utilities getestet
- [ ] Production Scripts bereit