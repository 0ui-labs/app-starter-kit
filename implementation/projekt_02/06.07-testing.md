# Sub-Task 06.07: Tests und Verifizierung

## Ziel
Comprehensive Testing der API Validation Implementation mit Unit und Integration Tests.

## Test Framework
- Vitest für Unit Tests
- Supertest für API Integration Tests
- Testing Library für Component Tests

## Test 1: Schema Validation Tests
`packages/api/src/schemas/__tests__/user.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { 
  userSchema, 
  createUserSchema, 
  updateUserSchema,
  userFiltersSchema 
} from '../user';

describe('User Schemas', () => {
  describe('createUserSchema', () => {
    it('should validate valid user input', () => {
      const input = {
        email: 'test@example.com',
        name: 'Test User',
        password: 'SecurePass123',
      };
      
      const result = createUserSchema.safeParse(input);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.email).toBe('test@example.com');
      }
    });
    
    it('should reject invalid email', () => {
      const input = {
        email: 'invalid-email',
        name: 'Test User',
        password: 'SecurePass123',
      };
      
      const result = createUserSchema.safeParse(input);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0].path).toContain('email');
      }
    });
    
    it('should reject weak password', () => {
      const input = {
        email: 'test@example.com',
        name: 'Test User',
        password: 'weak',
      };
      
      const result = createUserSchema.safeParse(input);
      expect(result.success).toBe(false);
      if (!result.success) {
        const passwordErrors = result.error.issues.filter(
          issue => issue.path.includes('password')
        );
        expect(passwordErrors.length).toBeGreaterThan(0);
      }
    });
    
    it('should convert email to lowercase', () => {
      const input = {
        email: 'TEST@EXAMPLE.COM',
        name: 'Test User',
        password: 'SecurePass123',
      };
      
      const result = createUserSchema.safeParse(input);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.email).toBe('test@example.com');
      }
    });
  });
  
  describe('updateUserSchema', () => {
    it('should allow partial updates', () => {
      const input = {
        name: 'Updated Name',
      };
      
      const result = updateUserSchema.safeParse(input);
      expect(result.success).toBe(true);
    });
    
    it('should allow empty object', () => {
      const input = {};
      
      const result = updateUserSchema.safeParse(input);
      expect(result.success).toBe(true);
    });
  });
  
  describe('userFiltersSchema', () => {
    it('should validate filter parameters', () => {
      const input = {
        email: 'test@example.com',
        role: 'admin',
        search: 'john',
      };
      
      const result = userFiltersSchema.safeParse(input);
      expect(result.success).toBe(true);
    });
    
    it('should reject invalid role', () => {
      const input = {
        role: 'superuser', // Invalid role
      };
      
      const result = userFiltersSchema.safeParse(input);
      expect(result.success).toBe(false);
    });
  });
});
```

## Test 2: Error Handler Tests
`packages/api/src/__tests__/error-handler.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { z } from 'zod';
import { ORPCError } from '@orpc/server';
import { handleAPIError } from '../error-handler';

describe('Error Handler', () => {
  it('should handle Zod validation errors', () => {
    const schema = z.object({
      email: z.string().email(),
    });
    
    try {
      schema.parse({ email: 'invalid' });
    } catch (error) {
      const result = handleAPIError(error);
      expect(result).toBeInstanceOf(ORPCError);
      expect(result.status).toBe(400);
      expect(result.data).toHaveProperty('fieldErrors');
    }
  });
  
  it('should pass through ORPC errors', () => {
    const originalError = new ORPCError('NOT_FOUND', {
      status: 404,
      message: 'User not found',
    });
    
    const result = handleAPIError(originalError);
    expect(result).toBe(originalError);
  });
  
  it('should handle Prisma unique constraint errors', () => {
    const prismaError = {
      code: 'P2002',
      meta: { target: ['email'] },
    };
    
    const result = handleAPIError(prismaError);
    expect(result.status).toBe(409);
    expect(result.code).toBe('CONFLICT');
  });
  
  it('should handle unknown errors', () => {
    const result = handleAPIError('Unknown error');
    expect(result.status).toBe(500);
    expect(result.code).toBe('INTERNAL_SERVER_ERROR');
  });
});
```

## Test 3: API Integration Tests
`apps/web/src/__tests__/api-integration.test.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createORPCClient } from '@orpc/client';
import type { AppRouter } from '@starter-kit/api';

const testClient = createORPCClient<AppRouter>({
  baseURL: 'http://localhost:3004/api',
});

describe('API Integration Tests', () => {
  let testUserId: string;
  
  describe('User API', () => {
    it('should create a new user', async () => {
      const input = {
        email: `test-${Date.now()}@example.com`,
        name: 'Test User',
        password: 'SecurePass123',
      };
      
      const result = await testClient.user.create(input);
      
      expect(result.success).toBe(true);
      expect(result.data.email).toBe(input.email);
      expect(result.data.name).toBe(input.name);
      
      testUserId = result.data.id;
    });
    
    it('should reject duplicate email', async () => {
      const input = {
        email: 'duplicate@example.com',
        name: 'Test User',
        password: 'SecurePass123',
      };
      
      // Create first user
      await testClient.user.create(input);
      
      // Try to create duplicate
      await expect(testClient.user.create(input)).rejects.toThrow();
    });
    
    it('should validate input on creation', async () => {
      const input = {
        email: 'invalid-email',
        name: '',
        password: 'weak',
      };
      
      await expect(testClient.user.create(input)).rejects.toThrow();
    });
    
    it('should list users with pagination', async () => {
      const result = await testClient.user.list({
        page: 1,
        limit: 10,
      });
      
      expect(result.success).toBe(true);
      expect(result.data).toHaveProperty('users');
      expect(result.data).toHaveProperty('total');
      expect(result.data).toHaveProperty('totalPages');
      expect(Array.isArray(result.data.users)).toBe(true);
    });
    
    it('should filter users by search term', async () => {
      const result = await testClient.user.list({
        search: 'test',
        page: 1,
        limit: 10,
      });
      
      expect(result.success).toBe(true);
      // All returned users should match search criteria
      result.data.users.forEach(user => {
        const matchesSearch = 
          user.name.toLowerCase().includes('test') ||
          user.email.toLowerCase().includes('test');
        expect(matchesSearch).toBe(true);
      });
    });
  });
});
```

## Test 4: SQL Injection Tests
`packages/api/src/__tests__/security.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { testClient } from './setup';

describe('SQL Injection Prevention', () => {
  it('should safely handle SQL injection in search', async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    
    const result = await testClient.user.list({
      search: maliciousInput,
    });
    
    // Should return empty results, not execute SQL
    expect(result.success).toBe(true);
    expect(result.data.users).toEqual([]);
  });
  
  it('should safely handle SQL injection in email filter', async () => {
    const maliciousInput = "admin@example.com' OR '1'='1";
    
    const result = await testClient.user.list({
      email: maliciousInput,
    });
    
    // Should validate email format and reject
    expect(result.success).toBe(false);
  });
  
  it('should prevent NoSQL injection attempts', async () => {
    const maliciousInput = {
      email: { $ne: null }, // MongoDB injection attempt
      name: 'Test',
      password: 'SecurePass123',
    };
    
    await expect(
      testClient.user.create(maliciousInput as any)
    ).rejects.toThrow();
  });
});
```

## Test 5: Component Integration Tests
`apps/web/src/components/__tests__/user-form.test.tsx`

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';
import { UserForm } from '../user-form';
import * as apiClient from '@/lib/api-client';

vi.mock('@/lib/api-client');

describe('UserForm', () => {
  it('should show validation errors from server', async () => {
    const mockCreateUser = vi.spyOn(apiClient.userAPI, 'createUser');
    mockCreateUser.mockResolvedValueOnce({
      error: {
        email: ['Email already exists'],
      },
    });
    
    render(<UserForm />);
    
    await userEvent.type(screen.getByPlaceholderText('Email'), 'test@example.com');
    await userEvent.type(screen.getByPlaceholderText('Name'), 'Test User');
    await userEvent.type(screen.getByPlaceholderText('Password'), 'Pass123');
    
    await userEvent.click(screen.getByText('Create User'));
    
    await waitFor(() => {
      expect(screen.getByText('Email already exists')).toBeInTheDocument();
    });
  });
  
  it('should show client-side validation errors', async () => {
    render(<UserForm />);
    
    await userEvent.type(screen.getByPlaceholderText('Email'), 'invalid');
    await userEvent.click(screen.getByText('Create User'));
    
    await waitFor(() => {
      expect(screen.getByText(/Invalid email/)).toBeInTheDocument();
    });
  });
});
```

## Test Runner Configuration
`vitest.config.ts`

```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@starter-kit/api': path.resolve(__dirname, '../../packages/api/src'),
    },
  },
});
```

## Test Setup File
`src/test/setup.ts`

```typescript
import { beforeAll, afterAll, afterEach } from 'vitest';
import { server } from './mocks/server';

// Mock Service Worker setup for API mocking
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Global test utilities
global.testHelpers = {
  async waitForLoadingToFinish() {
    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });
  },
};
```

## Test Commands
`package.json`

```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest watch",
    "test:api": "vitest run packages/api",
    "test:integration": "vitest run --config vitest.integration.config.ts"
  }
}
```

## Manual Testing Checklist

### ✅ Validation Tests
- [ ] Valid input accepts correctly
- [ ] Invalid email rejected
- [ ] Weak password rejected
- [ ] Missing required fields rejected
- [ ] Too long inputs truncated/rejected

### ✅ Security Tests
- [ ] SQL injection attempts blocked
- [ ] XSS attempts sanitized
- [ ] Auth tokens validated
- [ ] Role permissions enforced

### ✅ Error Handling
- [ ] Validation errors return 422
- [ ] Not found returns 404
- [ ] Unauthorized returns 401
- [ ] Conflicts return 409
- [ ] Server errors return 500

### ✅ Performance Tests
- [ ] Pagination limits enforced
- [ ] Query timeouts work
- [ ] Rate limiting active
- [ ] Large payloads rejected

### ✅ Integration Tests
- [ ] Create → Read → Update → Delete flow
- [ ] Filters and search work
- [ ] Pagination works
- [ ] Error recovery works

## Erfolgskriterien
- [ ] Unit Tests für alle Schemas
- [ ] Integration Tests für API Endpoints
- [ ] Security Tests bestanden
- [ ] Component Tests mit API Integration
- [ ] Coverage > 80%
- [ ] Alle manuellen Tests bestanden

## Geschätzte Zeit
15 Minuten für Test-Setup
30 Minuten für Test-Durchführung