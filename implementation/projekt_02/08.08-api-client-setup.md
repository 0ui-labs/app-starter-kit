# Arbeitspaket 08.08: API Client mit Safe Client fÃ¼r Error Handling

## Ziel
Einrichtung eines type-safe API Clients mit automatischem Error Handling unter Verwendung von oRPC's Safe Client Features.

## Kontext
- **Framework**: oRPC Client
- **Ziel**: Type-safe Error Handling mit [error, data] Pattern
- **Integration**: Mit Toast System und Error Types

## Implementierung

### Schritt 1: Base API Client
Erstelle `apps/web/src/lib/api-client.ts`:

```typescript
import { createClient, createSafeClient } from '@orpc/client';
import { createNextClient } from '@orpc/next/client';
import type { appRouter } from '@starter-kit/api';
import { getAuth } from '@starter-kit/auth/client';

// Get base URL for API
function getBaseURL() {
  if (typeof window !== 'undefined') {
    // Browser should use relative URL
    return '/api/rpc';
  }
  
  // SSR should use absolute URL
  if (process.env.VERCEL_URL) {
    return `https://${process.env.VERCEL_URL}/api/rpc`;
  }
  
  return `http://localhost:${process.env.PORT ?? 3004}/api/rpc`;
}

// Standard client with error throwing
export const apiClient = createClient<typeof appRouter>({
  baseURL: getBaseURL(),
  headers: async () => {
    const auth = await getAuth();
    const headers: Record<string, string> = {};
    
    if (auth?.token) {
      headers['Authorization'] = `Bearer ${auth.token}`;
    }
    
    // Add request ID for tracing
    headers['X-Request-Id'] = crypto.randomUUID();
    
    return headers;
  },
  // Add timeout
  timeout: 30000, // 30 seconds
});

// Safe client that returns [error, data] tuple
export const safeApiClient = createSafeClient(apiClient);

// Next.js optimized client for RSC
export const nextClient = createNextClient<typeof appRouter>({
  baseURL: getBaseURL(),
  headers: async () => {
    const auth = await getAuth();
    const headers: Record<string, string> = {};
    
    if (auth?.token) {
      headers['Authorization'] = `Bearer ${auth.token}`;
    }
    
    return headers;
  },
});

// Type exports for client usage
export type ApiClient = typeof apiClient;
export type SafeApiClient = typeof safeApiClient;
export type ApiError = {
  code: string;
  message: string;
  data?: any;
};
```

### Schritt 2: Request Interceptors
Erweitere `apps/web/src/lib/api-client.ts`:

```typescript
// Request/Response interceptors
class ApiInterceptor {
  private static requestInterceptors: Array<(config: any) => any> = [];
  private static responseInterceptors: Array<(response: any) => any> = [];
  private static errorInterceptors: Array<(error: any) => any> = [];

  static addRequestInterceptor(interceptor: (config: any) => any) {
    this.requestInterceptors.push(interceptor);
  }

  static addResponseInterceptor(interceptor: (response: any) => any) {
    this.responseInterceptors.push(interceptor);
  }

  static addErrorInterceptor(interceptor: (error: any) => any) {
    this.errorInterceptors.push(interceptor);
  }

  static async processRequest(config: any) {
    let processedConfig = config;
    for (const interceptor of this.requestInterceptors) {
      processedConfig = await interceptor(processedConfig);
    }
    return processedConfig;
  }

  static async processResponse(response: any) {
    let processedResponse = response;
    for (const interceptor of this.responseInterceptors) {
      processedResponse = await interceptor(processedResponse);
    }
    return processedResponse;
  }

  static async processError(error: any) {
    let processedError = error;
    for (const interceptor of this.errorInterceptors) {
      try {
        processedError = await interceptor(processedError);
      } catch (e) {
        // If interceptor throws, use that error
        processedError = e;
      }
    }
    throw processedError;
  }
}

// Add default interceptors
ApiInterceptor.addRequestInterceptor((config) => {
  // Add timestamp
  config.timestamp = Date.now();
  
  // Log in development
  if (process.env.NODE_ENV === 'development') {
    console.log('ðŸ”µ API Request:', config);
  }
  
  return config;
});

ApiInterceptor.addResponseInterceptor((response) => {
  // Log in development
  if (process.env.NODE_ENV === 'development') {
    console.log('ðŸŸ¢ API Response:', response);
  }
  
  return response;
});

ApiInterceptor.addErrorInterceptor((error) => {
  // Log errors
  console.error('ðŸ”´ API Error:', error);
  
  // Track error metrics
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', 'api_error', {
      error_code: error.code,
      error_message: error.message,
    });
  }
  
  return error;
});

export { ApiInterceptor };
```

### Schritt 3: Typed API Hooks
Erstelle `apps/web/src/hooks/use-api.ts`:

```typescript
'use client';

import { useCallback, useState } from 'react';
import { apiClient, safeApiClient } from '@/lib/api-client';
import { useErrorToast } from './use-error-toast';
import { isDefinedError } from '@orpc/client';

// Loading state manager
interface LoadingState {
  [key: string]: boolean;
}

export function useApi() {
  const [loading, setLoading] = useState<LoadingState>({});
  const { showError, showSuccess, withToast } = useErrorToast();

  // Generic API call wrapper with loading state
  const callApi = useCallback(async <T,>(
    apiCall: Promise<T>,
    options?: {
      loadingKey?: string;
      successMessage?: string;
      errorMessage?: string;
      showErrorToast?: boolean;
      onSuccess?: (data: T) => void;
      onError?: (error: any) => void;
    }
  ): Promise<T | null> => {
    const {
      loadingKey,
      successMessage,
      errorMessage,
      showErrorToast = true,
      onSuccess,
      onError,
    } = options || {};

    // Set loading state
    if (loadingKey) {
      setLoading(prev => ({ ...prev, [loadingKey]: true }));
    }

    try {
      const result = await apiCall;
      
      // Show success message if provided
      if (successMessage) {
        showSuccess(successMessage);
      }
      
      // Call success callback
      onSuccess?.(result);
      
      return result;
    } catch (error) {
      // Show error toast if enabled
      if (showErrorToast) {
        showError(error, errorMessage);
      }
      
      // Call error callback
      onError?.(error);
      
      return null;
    } finally {
      // Clear loading state
      if (loadingKey) {
        setLoading(prev => ({ ...prev, [loadingKey]: false }));
      }
    }
  }, [showError, showSuccess]);

  // Safe API call that returns [error, data]
  const safeCallApi = useCallback(async <T,>(
    apiCall: () => Promise<[any, T | undefined, boolean]>,
    options?: {
      loadingKey?: string;
      successMessage?: string;
    }
  ): Promise<{ error: any; data: T | null; isDefined: boolean }> => {
    const { loadingKey, successMessage } = options || {};

    // Set loading state
    if (loadingKey) {
      setLoading(prev => ({ ...prev, [loadingKey]: true }));
    }

    try {
      const [error, data, isDefined] = await apiCall();
      
      if (error) {
        return { error, data: null, isDefined };
      }
      
      // Show success message if provided
      if (successMessage && data) {
        showSuccess(successMessage);
      }
      
      return { error: null, data: data as T, isDefined: false };
    } finally {
      // Clear loading state
      if (loadingKey) {
        setLoading(prev => ({ ...prev, [loadingKey]: false }));
      }
    }
  }, [showSuccess]);

  // Check if specific operation is loading
  const isLoading = useCallback((key: string) => {
    return loading[key] || false;
  }, [loading]);

  // Check if any operation is loading
  const isAnyLoading = useCallback(() => {
    return Object.values(loading).some(Boolean);
  }, [loading]);

  return {
    apiClient,
    safeApiClient,
    callApi,
    safeCallApi,
    loading,
    isLoading,
    isAnyLoading,
  };
}
```

### Schritt 4: Resource-specific Hooks
Erstelle `apps/web/src/hooks/use-user-api.ts`:

```typescript
'use client';

import { useApi } from './use-api';
import { useCallback } from 'react';
import { useErrorToast } from './use-error-toast';

interface CreateUserData {
  email: string;
  name: string;
  role?: 'USER' | 'ADMIN';
}

interface UpdateUserData {
  name?: string;
  email?: string;
  role?: 'USER' | 'ADMIN';
}

export function useUserApi() {
  const { callApi, safeCallApi, isLoading } = useApi();
  const { showError } = useErrorToast();

  const createUser = useCallback(async (data: CreateUserData) => {
    return callApi(
      apiClient.user.create(data),
      {
        loadingKey: 'createUser',
        successMessage: 'Benutzer erfolgreich erstellt',
      }
    );
  }, [callApi]);

  const getUser = useCallback(async (id: string) => {
    const result = await safeCallApi(
      () => safeApiClient.user.get({ id }),
      {
        loadingKey: 'getUser',
      }
    );

    if (result.error) {
      if (result.isDefined && result.error.code === 'NOT_FOUND') {
        showError('Benutzer wurde nicht gefunden');
      } else {
        showError(result.error);
      }
      return null;
    }

    return result.data;
  }, [safeCallApi, showError]);

  const updateUser = useCallback(async (id: string, data: UpdateUserData) => {
    return callApi(
      apiClient.user.update({ id, data }),
      {
        loadingKey: 'updateUser',
        successMessage: 'Benutzer erfolgreich aktualisiert',
      }
    );
  }, [callApi]);

  const deleteUser = useCallback(async (id: string) => {
    return callApi(
      apiClient.user.delete({ id }),
      {
        loadingKey: 'deleteUser',
        successMessage: 'Benutzer erfolgreich gelÃ¶scht',
        errorMessage: 'Benutzer konnte nicht gelÃ¶scht werden',
      }
    );
  }, [callApi]);

  const listUsers = useCallback(async (params?: { 
    page?: number; 
    limit?: number; 
    search?: string;
  }) => {
    return callApi(
      apiClient.user.list(params || {}),
      {
        loadingKey: 'listUsers',
        showErrorToast: false, // Don't show error for list operations
      }
    );
  }, [callApi]);

  return {
    createUser,
    getUser,
    updateUser,
    deleteUser,
    listUsers,
    isCreatingUser: isLoading('createUser'),
    isLoadingUser: isLoading('getUser'),
    isUpdatingUser: isLoading('updateUser'),
    isDeletingUser: isLoading('deleteUser'),
    isLoadingUsers: isLoading('listUsers'),
  };
}
```

## Verwendung

### Beispiel 1: Mit Standard Client
```typescript
import { apiClient } from '@/lib/api-client';

// Throws on error
try {
  const user = await apiClient.user.create({
    email: 'test@test.com',
    name: 'Test User',
  });
  console.log('Created user:', user);
} catch (error) {
  console.error('Failed to create user:', error);
}
```

### Beispiel 2: Mit Safe Client
```typescript
import { safeApiClient } from '@/lib/api-client';

// Returns [error, data, isDefined] tuple
const [error, user, isDefined] = await safeApiClient.user.create({
  email: 'test@test.com',
  name: 'Test User',
});

if (error) {
  if (isDefined) {
    // Handle known error
    console.log('Known error:', error.code);
  } else {
    // Handle unknown error
    console.log('Unknown error:', error);
  }
} else {
  console.log('Created user:', user);
}
```

### Beispiel 3: Mit Hooks
```typescript
import { useUserApi } from '@/hooks/use-user-api';

function UserComponent() {
  const { 
    createUser, 
    isCreatingUser,
    listUsers,
    isLoadingUsers 
  } = useUserApi();

  const handleCreate = async () => {
    const user = await createUser({
      email: 'new@user.com',
      name: 'New User',
    });
    
    if (user) {
      // Success - toast already shown
      await listUsers(); // Refresh list
    }
  };

  return (
    <Button 
      onClick={handleCreate}
      disabled={isCreatingUser}
    >
      {isCreatingUser ? 'Creating...' : 'Create User'}
    </Button>
  );
}
```

## Verifizierung

### Test 1: Error Handling
```typescript
const [error, data] = await safeApiClient.user.get({ 
  id: 'non-existent' 
});
// error sollte definiert sein mit code NOT_FOUND
```

### Test 2: Loading States
```typescript
const { isLoadingUser, getUser } = useUserApi();
// isLoadingUser sollte true wÃ¤hrend API call sein
```

### Test 3: Interceptors
```typescript
ApiInterceptor.addErrorInterceptor((error) => {
  console.log('Intercepted:', error);
  return error;
});
// Sollte bei jedem Error aufgerufen werden
```

## Erfolgskriterien
- [ ] Base API Client konfiguriert
- [ ] Safe Client implementiert
- [ ] Request/Response Interceptors
- [ ] Typed API Hooks
- [ ] Loading State Management
- [ ] Resource-specific Hooks

## Potentielle Probleme

### Problem: Type Inference bei Safe Client
**LÃ¶sung**: Explicit type annotations verwenden

### Problem: Memory Leaks mit Loading States
**LÃ¶sung**: Cleanup in useEffect wenn Component unmounted

## ZeitschÃ¤tzung
- API Client Setup: 5 Minuten
- Interceptors: 5 Minuten
- Hooks: 5 Minuten
- Total: 15 Minuten