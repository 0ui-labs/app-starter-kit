# 11.06 Error Handling & Retry Logic

## Ziel
Implementierung einer robusten Fehlerbehandlung und intelligenten Retry-Mechanismen für alle AI Provider.

## Umfang
- Structured error hierarchy
- Exponential backoff retry strategy
- Circuit breaker pattern
- Provider fallback mechanism
- Error telemetry and logging

## Tasks

### 1. Error Hierarchy
```typescript
// packages/ai-adapter/src/errors/types.ts
export abstract class AIError extends Error {
  abstract readonly code: string;
  abstract readonly retryable: boolean;
  abstract readonly provider?: string;
  
  constructor(message: string) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class ProviderError extends AIError {
  code = 'PROVIDER_ERROR';
  retryable = false;
  
  constructor(
    public provider: string,
    message: string,
    public originalError?: unknown
  ) {
    super(message);
  }
}

export class RateLimitError extends AIError {
  code = 'RATE_LIMIT';
  retryable = true;
  
  constructor(
    public provider: string,
    public retryAfter?: number,
    message = 'Rate limit exceeded'
  ) {
    super(message);
  }
}

export class TokenLimitError extends AIError {
  code = 'TOKEN_LIMIT';
  retryable = false;
  
  constructor(
    public provider: string,
    public tokensUsed: number,
    public maxTokens: number
  ) {
    super(`Token limit exceeded: ${tokensUsed}/${maxTokens}`);
  }
}

export class AuthenticationError extends AIError {
  code = 'AUTH_ERROR';
  retryable = false;
  
  constructor(public provider: string, message = 'Authentication failed') {
    super(message);
  }
}

export class NetworkError extends AIError {
  code = 'NETWORK_ERROR';
  retryable = true;
  
  constructor(message = 'Network request failed') {
    super(message);
  }
}

export class TimeoutError extends AIError {
  code = 'TIMEOUT';
  retryable = true;
  
  constructor(public timeoutMs: number) {
    super(`Request timed out after ${timeoutMs}ms`);
  }
}

export class ValidationError extends AIError {
  code = 'VALIDATION_ERROR';
  retryable = false;
  
  constructor(
    public field: string,
    public value: unknown,
    message: string
  ) {
    super(message);
  }
}
```

### 2. Retry Strategy Implementation
```typescript
// packages/ai-adapter/src/retry/strategy.ts
export interface RetryConfig {
  maxRetries: number;
  initialDelay: number;
  maxDelay: number;
  backoffFactor: number;
  jitter: boolean;
  retryCondition?: (error: AIError) => boolean;
}

export class RetryStrategy {
  private static DEFAULT_CONFIG: RetryConfig = {
    maxRetries: 3,
    initialDelay: 1000,
    maxDelay: 30000,
    backoffFactor: 2,
    jitter: true,
    retryCondition: (error) => error.retryable,
  };
  
  constructor(private config: Partial<RetryConfig> = {}) {
    this.config = { ...RetryStrategy.DEFAULT_CONFIG, ...config };
  }
  
  async execute<T>(
    fn: () => Promise<T>,
    context?: { provider?: string; operation?: string }
  ): Promise<T> {
    let lastError: AIError;
    
    for (let attempt = 0; attempt <= this.config.maxRetries!; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = this.wrapError(error);
        
        // Check if we should retry
        if (!this.shouldRetry(lastError, attempt)) {
          throw lastError;
        }
        
        // Calculate delay
        const delay = this.calculateDelay(attempt, lastError);
        
        // Log retry attempt
        console.log(`Retry attempt ${attempt + 1}/${this.config.maxRetries}`, {
          provider: context?.provider,
          operation: context?.operation,
          delay,
          error: lastError.message,
        });
        
        // Wait before retrying
        await this.sleep(delay);
      }
    }
    
    throw lastError!;
  }
  
  private shouldRetry(error: AIError, attempt: number): boolean {
    if (attempt >= this.config.maxRetries!) {
      return false;
    }
    
    if (this.config.retryCondition) {
      return this.config.retryCondition(error);
    }
    
    return error.retryable;
  }
  
  private calculateDelay(attempt: number, error: AIError): number {
    // Use retry-after header if available
    if (error instanceof RateLimitError && error.retryAfter) {
      return error.retryAfter * 1000;
    }
    
    // Exponential backoff
    let delay = this.config.initialDelay! * 
      Math.pow(this.config.backoffFactor!, attempt);
    
    // Apply max delay cap
    delay = Math.min(delay, this.config.maxDelay!);
    
    // Add jitter to prevent thundering herd
    if (this.config.jitter) {
      delay = delay * (0.5 + Math.random() * 0.5);
    }
    
    return Math.floor(delay);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  private wrapError(error: unknown): AIError {
    if (error instanceof AIError) {
      return error;
    }
    
    if (error instanceof Error) {
      return new ProviderError('unknown', error.message, error);
    }
    
    return new ProviderError('unknown', String(error), error);
  }
}
```

### 3. Circuit Breaker Pattern
```typescript
// packages/ai-adapter/src/retry/circuit-breaker.ts
export enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN',
}

export interface CircuitBreakerConfig {
  failureThreshold: number;
  resetTimeout: number;
  monitoringPeriod: number;
  halfOpenRequests: number;
}

export class CircuitBreaker {
  private state = CircuitState.CLOSED;
  private failures = 0;
  private successes = 0;
  private lastFailTime?: number;
  private halfOpenTests = 0;
  
  constructor(
    private name: string,
    private config: CircuitBreakerConfig = {
      failureThreshold: 5,
      resetTimeout: 60000, // 1 minute
      monitoringPeriod: 60000,
      halfOpenRequests: 3,
    }
  ) {}
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    // Check circuit state
    if (!this.canExecute()) {
      throw new Error(`Circuit breaker ${this.name} is OPEN`);
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private canExecute(): boolean {
    switch (this.state) {
      case CircuitState.CLOSED:
        return true;
        
      case CircuitState.OPEN:
        // Check if enough time has passed to try again
        if (Date.now() - this.lastFailTime! > this.config.resetTimeout) {
          this.state = CircuitState.HALF_OPEN;
          this.halfOpenTests = 0;
          return true;
        }
        return false;
        
      case CircuitState.HALF_OPEN:
        // Allow limited requests in half-open state
        return this.halfOpenTests < this.config.halfOpenRequests;
    }
  }
  
  private onSuccess(): void {
    switch (this.state) {
      case CircuitState.HALF_OPEN:
        this.successes++;
        if (this.successes >= this.config.halfOpenRequests) {
          this.reset();
        }
        break;
        
      case CircuitState.CLOSED:
        this.failures = Math.max(0, this.failures - 1);
        break;
    }
  }
  
  private onFailure(): void {
    this.lastFailTime = Date.now();
    
    switch (this.state) {
      case CircuitState.HALF_OPEN:
        this.open();
        break;
        
      case CircuitState.CLOSED:
        this.failures++;
        if (this.failures >= this.config.failureThreshold) {
          this.open();
        }
        break;
    }
  }
  
  private open(): void {
    this.state = CircuitState.OPEN;
    console.error(`Circuit breaker ${this.name} opened`);
  }
  
  private reset(): void {
    this.state = CircuitState.CLOSED;
    this.failures = 0;
    this.successes = 0;
    this.halfOpenTests = 0;
    console.info(`Circuit breaker ${this.name} reset`);
  }
  
  getState(): CircuitState {
    return this.state;
  }
  
  getStats() {
    return {
      state: this.state,
      failures: this.failures,
      successes: this.successes,
      lastFailTime: this.lastFailTime,
    };
  }
}
```

### 4. Provider Fallback Mechanism
```typescript
// packages/ai-adapter/src/retry/fallback.ts
export interface FallbackConfig {
  providers: string[];
  strategy: 'sequential' | 'random' | 'weighted';
  weights?: Record<string, number>;
}

export class FallbackManager {
  private providerStats = new Map<string, {
    failures: number;
    successes: number;
    avgLatency: number;
  }>();
  
  constructor(
    private registry: ProviderRegistry,
    private config: FallbackConfig
  ) {}
  
  async executeWithFallback<T>(
    operation: (provider: AIProvider) => Promise<T>,
    context?: { preferredProvider?: string }
  ): Promise<T> {
    const providers = this.getProviderSequence(context?.preferredProvider);
    let lastError: AIError | undefined;
    
    for (const providerName of providers) {
      const provider = this.registry.get(providerName);
      if (!provider) continue;
      
      const startTime = Date.now();
      
      try {
        const result = await operation(provider);
        this.recordSuccess(providerName, Date.now() - startTime);
        return result;
      } catch (error) {
        lastError = error instanceof AIError ? error : 
          new ProviderError(providerName, String(error));
        
        this.recordFailure(providerName);
        
        // Don't fallback for non-retryable errors
        if (!lastError.retryable) {
          throw lastError;
        }
        
        console.warn(`Provider ${providerName} failed, trying fallback`, {
          error: lastError.message,
        });
      }
    }
    
    throw lastError || new Error('No providers available');
  }
  
  private getProviderSequence(preferred?: string): string[] {
    const providers = [...this.config.providers];
    
    // Put preferred provider first if specified
    if (preferred && providers.includes(preferred)) {
      providers.splice(providers.indexOf(preferred), 1);
      providers.unshift(preferred);
    }
    
    // Apply strategy
    switch (this.config.strategy) {
      case 'random':
        return this.shuffle(providers);
        
      case 'weighted':
        return this.weightedSort(providers);
        
      case 'sequential':
      default:
        return providers;
    }
  }
  
  private shuffle<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  private weightedSort(providers: string[]): string[] {
    return providers.sort((a, b) => {
      const weightA = this.config.weights?.[a] ?? 1;
      const weightB = this.config.weights?.[b] ?? 1;
      
      // Factor in recent performance
      const statsA = this.providerStats.get(a);
      const statsB = this.providerStats.get(b);
      
      if (statsA && statsB) {
        const scoreA = weightA * (statsA.successes / (statsA.failures + 1));
        const scoreB = weightB * (statsB.successes / (statsB.failures + 1));
        return scoreB - scoreA;
      }
      
      return weightB - weightA;
    });
  }
  
  private recordSuccess(provider: string, latency: number): void {
    const stats = this.providerStats.get(provider) || {
      failures: 0,
      successes: 0,
      avgLatency: 0,
    };
    
    stats.successes++;
    stats.avgLatency = (stats.avgLatency * (stats.successes - 1) + latency) / 
      stats.successes;
    
    this.providerStats.set(provider, stats);
  }
  
  private recordFailure(provider: string): void {
    const stats = this.providerStats.get(provider) || {
      failures: 0,
      successes: 0,
      avgLatency: 0,
    };
    
    stats.failures++;
    this.providerStats.set(provider, stats);
  }
}
```

### 5. Error Telemetry
```typescript
// packages/ai-adapter/src/errors/telemetry.ts
export interface ErrorTelemetry {
  timestamp: number;
  provider: string;
  operation: string;
  error: {
    code: string;
    message: string;
    retryable: boolean;
  };
  context: Record<string, unknown>;
  retryAttempt?: number;
  duration?: number;
}

export class ErrorReporter {
  private errors: ErrorTelemetry[] = [];
  private listeners: ((error: ErrorTelemetry) => void)[] = [];
  
  report(telemetry: ErrorTelemetry): void {
    this.errors.push(telemetry);
    
    // Notify listeners
    this.listeners.forEach(listener => listener(telemetry));
    
    // Keep only recent errors (last 1000)
    if (this.errors.length > 1000) {
      this.errors = this.errors.slice(-1000);
    }
  }
  
  onError(listener: (error: ErrorTelemetry) => void): () => void {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  getErrorStats(timeWindow?: number) {
    const now = Date.now();
    const relevantErrors = timeWindow 
      ? this.errors.filter(e => now - e.timestamp < timeWindow)
      : this.errors;
    
    const byProvider = new Map<string, number>();
    const byCode = new Map<string, number>();
    
    for (const error of relevantErrors) {
      byProvider.set(error.provider, (byProvider.get(error.provider) || 0) + 1);
      byCode.set(error.error.code, (byCode.get(error.error.code) || 0) + 1);
    }
    
    return {
      total: relevantErrors.length,
      byProvider: Object.fromEntries(byProvider),
      byCode: Object.fromEntries(byCode),
      retryableRate: relevantErrors.filter(e => e.error.retryable).length / 
        relevantErrors.length,
    };
  }
}
```

## Dateien zu erstellen/ändern
- `packages/ai-adapter/src/errors/types.ts` - Error hierarchy
- `packages/ai-adapter/src/retry/strategy.ts` - Retry logic
- `packages/ai-adapter/src/retry/circuit-breaker.ts` - Circuit breaker
- `packages/ai-adapter/src/retry/fallback.ts` - Provider fallback
- `packages/ai-adapter/src/errors/telemetry.ts` - Error reporting

## Akzeptanzkriterien
- [ ] Strukturierte error hierarchy implementiert
- [ ] Exponential backoff retry funktioniert
- [ ] Circuit breaker pattern implementiert
- [ ] Provider fallback mechanism funktioniert
- [ ] Error telemetry und reporting
- [ ] Retry-after header support
- [ ] Konfigurierbare retry strategies
- [ ] Tests für alle error scenarios

## Abhängigkeiten
- Tasks 11.01-11.04 (Provider implementations)
- Logging infrastructure (optional)

## Geschätzter Aufwand
60-75 Minuten