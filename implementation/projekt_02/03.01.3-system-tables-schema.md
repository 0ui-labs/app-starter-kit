# Arbeitspaket 03.01.3: System Tables Schema

## Ziel
Implementierung der System-Tabellen im Prisma Schema mit AuditLog, ApiKey und WebhookEvent Models für Monitoring, Security und Integration.

## Kontext
- **Package**: `@starter-kit/db`
- **Schema Location**: `packages/db/prisma/schema.prisma`
- **Database**: PostgreSQL (Neon in Production)
- **Teil von**: Arbeitspaket 03.01 - Prisma Schema Implementation
- **Abhängigkeit**: User Management Schema (03.01.1)

## Implementierung

### 1. Audit Action Enum

```prisma
enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  PERMISSION_CHANGE
}
```

### 2. AuditLog Model

```prisma
model AuditLog {
  id              String      @id @default(uuid())
  userId          String?
  user            User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Audit Information
  action          AuditAction
  entity          String      // Table/Model name (z.B. "User", "Post")
  entityId        String?     // ID des betroffenen Records
  
  // Change Tracking
  oldValues       Json?       // Vorherige Werte als JSON
  newValues       Json?       // Neue Werte als JSON
  
  // Request Context
  ip              String?
  userAgent       String?
  
  // Timestamp (nur created, kein update)
  createdAt       DateTime    @default(now())
  
  // Performance Indexes
  @@index([userId])
  @@index([entity])
  @@index([entityId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}
```

### 3. ApiKey Model

```prisma
model ApiKey {
  id              String      @id @default(uuid())
  name            String      // Beschreibender Name
  key             String      @unique // Der eigentliche API Key
  
  // Permissions & Scopes
  scopes          String[]    @default([]) // Array von Berechtigungen
  
  // Rate Limiting
  rateLimit       Int         @default(1000) // Requests pro Stunde
  
  // Usage Tracking
  lastUsedAt      DateTime?
  usageCount      Int         @default(0)
  
  // Validity Management
  expiresAt       DateTime?   // Optional: Ablaufdatum
  revokedAt       DateTime?   // Soft Revoke
  
  // Timestamps
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Indexes für Performance
  @@index([key])
  @@index([expiresAt])
  @@map("api_keys")
}
```

### 4. WebhookEvent Model

```prisma
model WebhookEvent {
  id              String      @id @default(uuid())
  
  // Event Information
  event           String      // Event Type (z.B. "user.created", "post.published")
  payload         Json        // Event Payload als JSON
  
  // Delivery Configuration
  url             String      // Webhook Endpoint URL
  headers         Json?       // Custom Headers als JSON
  
  // Delivery Status
  delivered       Boolean     @default(false)
  attempts        Int         @default(0)
  lastAttemptAt   DateTime?
  deliveredAt     DateTime?
  
  // Error Tracking
  lastError       String?     // Letzter Fehler bei Delivery
  
  // Timestamp
  createdAt       DateTime    @default(now())
  
  // Indexes für Queue Processing
  @@index([event])
  @@index([delivered])
  @@index([createdAt])
  @@map("webhook_events")
}
```

## Key Features

### AuditLog Features
- **Comprehensive Tracking**: Alle wichtigen Aktionen werden geloggt
- **Change History**: Old/New Values als JSON für flexible Speicherung
- **User Context**: Optional (SetNull bei User-Löschung)
- **Request Metadata**: IP und User Agent für Security Analysis
- **Immutable**: Nur CREATE, kein UPDATE

### ApiKey Management
- **Scope-based Permissions**: Flexible Berechtigungsvergabe
- **Rate Limiting**: Built-in Rate Limit Support
- **Usage Tracking**: Monitoring der API-Nutzung
- **Key Rotation**: Expiry und Revoke Support
- **Named Keys**: Beschreibende Namen für bessere Verwaltung

### Webhook System
- **Event Queue**: Persistente Event-Speicherung
- **Retry Logic**: Attempt Counter für Retry-Mechanismus
- **Error Tracking**: Fehler-Logging für Debugging
- **Flexible Payload**: JSON für verschiedene Event-Typen
- **Custom Headers**: Support für Authentication Headers

## Use Cases

### AuditLog Use Cases
- Compliance und Regulatory Requirements
- Security Incident Investigation
- User Activity Tracking
- Change History für kritische Daten
- Login/Logout Monitoring

### ApiKey Use Cases
- Third-Party Integrations
- Mobile App Authentication
- Service-to-Service Communication
- Rate Limiting pro Client
- Temporary Access Tokens

### WebhookEvent Use Cases
- Real-time Notifications
- Integration mit externen Systemen
- Event-Driven Architecture
- Async Processing Queue
- Failed Delivery Retry

## Implementation Details

### JSON Field Usage
```typescript
// AuditLog oldValues/newValues Beispiel
{
  "name": "John Doe",
  "email": "john@example.com",
  "role": "USER"
}

// ApiKey scopes Beispiel
["read:users", "write:posts", "admin:settings"]

// WebhookEvent payload Beispiel
{
  "userId": "uuid",
  "action": "user.created",
  "timestamp": "2024-01-01T00:00:00Z",
  "data": { /* event specific data */ }
}
```

### Security Considerations
- API Keys sollten gehashed gespeichert werden (Implementation-Detail)
- Audit Logs sind immutable (kein UPDATE/DELETE)
- Sensitive Daten in JSON Fields sollten encrypted werden
- Rate Limiting auf Database-Level vorbereitet

## Verifizierung

```bash
# Schema validieren
cd packages/db
npx prisma validate

# Migration erstellen (nur dieser Teil)
npx prisma migrate dev --name add-system-tables

# Prisma Studio für manuelle Inspektion
npx prisma studio
```

## Performance Überlegungen

### Index-Strategie
- `createdAt`: Für Time-based Queries und Cleanup
- `entity` + `entityId`: Für Entity-spezifische Audit Trails
- `key`: Für schnelle API Key Validation
- `delivered`: Für Webhook Queue Processing

### Datenbank-Wartung
- Regelmäßiges Cleanup alter Audit Logs
- Archivierung von delivered WebhookEvents
- Monitoring der Table Sizes
- Partitionierung bei großen Datenmengen

## Integration Points

### Mit User Management
- AuditLog referenziert User (optional)
- User Actions werden geloggt

### Mit Application Logic
- Middleware für automatisches Audit Logging
- API Key Validation in Auth Layer
- Webhook Trigger bei Business Events

## Erfolgskriterien
- [ ] AuditLog Model mit Change Tracking
- [ ] ApiKey Model mit Scopes und Rate Limiting
- [ ] WebhookEvent Model für Event Queue
- [ ] Alle Enums definiert
- [ ] JSON Fields für flexible Datenstrukturen
- [ ] Performance Indexes gesetzt
- [ ] Soft Delete/Revoke Support wo sinnvoll
- [ ] Schema Validation erfolgreich