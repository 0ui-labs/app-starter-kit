# Arbeitspaket 07.01: Context und Error Handling

## Ziel
Implementierung des API Context und eines robusten Error Handling Systems für alle API Procedures.

## Kontext
- Basis für alle API Procedures
- Integration mit Clerk Authentication
- Strukturierte Fehlerbehandlung
- Type-safe Context für alle Handler

## Implementierung

### Schritt 1: API Context erstellen
Erstelle `packages/api/src/context.ts`:

```typescript
import { db } from '@starter-kit/db';
import { auth, currentUser } from '@clerk/nextjs/server';

export async function createContext(req?: Request) {
  const { userId } = await auth();
  const user = userId ? await currentUser() : null;
  
  return {
    db,
    userId,
    user,
    isAdmin: user?.publicMetadata?.role === 'admin',
    ip: req?.headers?.get('x-forwarded-for') || undefined,
    userAgent: req?.headers?.get('user-agent') || undefined,
    req,
  };
}

export type Context = Awaited<ReturnType<typeof createContext>>;
```

### Schritt 2: Error Handling System
Erstelle `packages/api/src/errors/app-error.ts`:

```typescript
import { ORPCError } from '@orpc/server';

export enum ErrorCode {
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  NOT_FOUND = 'NOT_FOUND',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  BAD_REQUEST = 'BAD_REQUEST',
  CONFLICT = 'CONFLICT',
}

export class AppError extends ORPCError {
  constructor(
    public code: ErrorCode,
    message: string,
    public statusCode: number = 500,
    public isOperational: boolean = true,
    public details?: any
  ) {
    super(code, message, details);
  }
}

// Helper functions
export const createError = {
  unauthorized: (message = 'Authentication required') =>
    new AppError(ErrorCode.UNAUTHORIZED, message, 401),
  
  forbidden: (message = 'Access denied') =>
    new AppError(ErrorCode.FORBIDDEN, message, 403),
  
  notFound: (resource = 'Resource', message?: string) =>
    new AppError(
      ErrorCode.NOT_FOUND,
      message || `${resource} not found`,
      404
    ),
  
  badRequest: (message = 'Invalid request') =>
    new AppError(ErrorCode.BAD_REQUEST, message, 400),
  
  conflict: (message = 'Resource conflict') =>
    new AppError(ErrorCode.CONFLICT, message, 409),
  
  rateLimit: (reset?: number, limit?: number) =>
    new AppError(
      ErrorCode.RATE_LIMIT_EXCEEDED,
      `Rate limit exceeded. Try again in ${reset ? reset - Date.now() : 'a few'} ms`,
      429,
      true,
      { limit, reset }
    ),
  
  validation: (errors: any) =>
    new AppError(
      ErrorCode.VALIDATION_ERROR,
      'Validation failed',
      400,
      true,
      errors
    ),
  
  internal: (message = 'Internal server error') =>
    new AppError(ErrorCode.INTERNAL_ERROR, message, 500),
};
```

### Schritt 3: Audit Logging Helper
Erstelle `packages/api/src/utils/audit-log.ts`:

```typescript
import { PrismaClient } from '@starter-kit/db';

interface AuditLogData {
  userId: string;
  action: string;
  entity: string;
  entityId?: string;
  oldValues?: any;
  newValues?: any;
  ip?: string;
  userAgent?: string;
}

export async function createAuditLog(
  db: PrismaClient,
  data: AuditLogData
): Promise<void> {
  try {
    await db.auditLog.create({
      data: {
        userId: data.userId,
        action: data.action,
        entity: data.entity,
        entityId: data.entityId,
        oldValues: data.oldValues ? JSON.stringify(data.oldValues) : null,
        newValues: data.newValues ? JSON.stringify(data.newValues) : null,
        ip: data.ip,
        userAgent: data.userAgent,
        timestamp: new Date(),
      },
    });
  } catch (error) {
    // Log to monitoring service but don't fail the request
    console.error('Failed to create audit log:', error);
  }
}
```

### Schritt 4: Response Schema Helpers
Erstelle `packages/api/src/utils/schemas.ts`:

```typescript
import { z } from 'zod';

// Success response wrapper
export const successSchema = <T extends z.ZodType>(dataSchema: T) =>
  z.object({
    success: z.literal(true),
    data: dataSchema,
  });

// Error response schema
export const errorSchema = z.object({
  success: z.literal(false),
  error: z.object({
    code: z.string(),
    message: z.string(),
    statusCode: z.number(),
    details: z.any().optional(),
  }),
});

// Pagination schema
export const paginationSchema = z.object({
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(10),
});

// Common query params
export const listQuerySchema = paginationSchema.extend({
  search: z.string().optional(),
  orderBy: z.string().optional(),
  order: z.enum(['asc', 'desc']).default('desc'),
});

// Pagination response
export const paginatedResponseSchema = <T extends z.ZodType>(itemSchema: T) =>
  z.object({
    items: z.array(itemSchema),
    total: z.number(),
    page: z.number(),
    totalPages: z.number(),
    hasMore: z.boolean(),
  });
```

### Schritt 5: Export Index
Update `packages/api/src/index.ts`:

```typescript
// Context
export { createContext, type Context } from './context';

// Errors
export { 
  AppError, 
  ErrorCode, 
  createError 
} from './errors/app-error';

// Utils
export { createAuditLog } from './utils/audit-log';
export {
  successSchema,
  errorSchema,
  paginationSchema,
  listQuerySchema,
  paginatedResponseSchema,
} from './utils/schemas';

// Router (will be added in later steps)
// export { router, type AppRouter } from './router';
```

## Verifizierung

### Test 1: Context Creation
```typescript
const context = await createContext(request);
console.log(context.userId); // Should be Clerk user ID or null
console.log(context.isAdmin); // Should be boolean
```

### Test 2: Error Handling
```typescript
try {
  throw createError.notFound('User');
} catch (error) {
  console.log(error.code); // NOT_FOUND
  console.log(error.statusCode); // 404
}
```

### Test 3: Schema Validation
```typescript
const UserResponse = successSchema(z.object({
  id: z.string(),
  name: z.string(),
}));

const valid = UserResponse.parse({
  success: true,
  data: { id: '123', name: 'Test' }
});
```

## Erfolgskriterien
- [ ] Context mit Clerk Auth funktioniert
- [ ] Error System implementiert
- [ ] Audit Logging vorbereitet
- [ ] Schema Helpers verfügbar
- [ ] TypeScript kompiliert ohne Fehler

## Nächste Schritte
- Weiter mit 07.02: Base Procedures mit Middleware