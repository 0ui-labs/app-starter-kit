# Arbeitspaket 07.05: Router Assembly

## Ziel
Zusammenführung aller Procedures zu einem zentralen API Router mit Type Export für End-to-End Type Safety.

## Kontext
- Vereint alle vorherigen Procedures (User, Post, etc.)
- Zentrale Router Definition
- Type Export für Client SDK
- Health Check und System Endpoints

## Implementierung

### Schritt 1: Comment Procedures (Zusatz)
Erstelle `packages/api/src/procedures/comment.ts`:

```typescript
import { z } from 'zod';
import {
  publicProcedure,
  authedProcedure,
  moderatorProcedure,
  withRateLimit,
  withOwnership,
  withCache,
} from './base';
import { createError } from '../errors/app-error';
import { createAuditLog } from '../utils/audit-log';
import {
  successSchema,
  paginationSchema,
  paginatedResponseSchema,
} from '../utils/schemas';
import {
  commentSchema,
  commentWithAuthorSchema,
  createCommentSchema,
} from '../schemas/post';

export const commentProcedures = {
  // Create comment
  create: authedProcedure
    .use(withRateLimit({ limit: 'default' }))
    .input(z.object({
      postId: z.string().uuid(),
    }).merge(createCommentSchema))
    .output(successSchema(commentWithAuthorSchema))
    .handler(async ({ input, context }) => {
      const { postId, content, parentId } = input;
      
      // Check if post exists and allows comments
      const post = await context.db.post.findUnique({
        where: { id: postId },
        select: { 
          id: true, 
          allowComments: true,
          published: true,
        },
      });
      
      if (!post) {
        throw createError.notFound('Post');
      }
      
      if (!post.allowComments) {
        throw createError.forbidden('Comments are disabled for this post');
      }
      
      if (!post.published) {
        throw createError.forbidden('Cannot comment on unpublished posts');
      }
      
      // If replying, check parent exists
      if (parentId) {
        const parent = await context.db.comment.findUnique({
          where: { id: parentId, postId },
        });
        
        if (!parent) {
          throw createError.notFound('Parent comment');
        }
      }
      
      // Create comment
      const comment = await context.db.comment.create({
        data: {
          content,
          postId,
          authorId: context.userId!,
          parentId,
        },
        include: {
          author: {
            select: {
              id: true,
              name: true,
              image: true,
              profile: {
                select: { bio: true },
              },
            },
          },
        },
      });
      
      // Format response
      const formattedComment = {
        ...comment,
        author: {
          id: comment.author.id,
          name: comment.author.name,
          image: comment.author.image,
          bio: comment.author.profile?.bio || null,
        },
        replies: [],
      };
      
      return { success: true, data: formattedComment };
    }),

  // List comments for post
  listByPost: publicProcedure
    .use(withCache({
      key: (input) => `comments:post:${input.postId}:${input.page}`,
      ttl: 60,
    }))
    .input(paginationSchema.extend({
      postId: z.string().uuid(),
      parentId: z.string().uuid().nullable().optional(),
      orderBy: z.enum(['createdAt', 'likes']).default('createdAt'),
      order: z.enum(['asc', 'desc']).default('asc'),
    }))
    .output(successSchema(paginatedResponseSchema(commentWithAuthorSchema)))
    .handler(async ({ input, context }) => {
      const { postId, parentId = null, page, limit, orderBy, order } = input;
      const skip = (page - 1) * limit;
      
      const where = {
        postId,
        parentId,
        deletedAt: null,
      };
      
      const [comments, total] = await Promise.all([
        context.db.comment.findMany({
          where,
          skip,
          take: limit,
          orderBy: { [orderBy]: order },
          include: {
            author: {
              select: {
                id: true,
                name: true,
                image: true,
                profile: {
                  select: { bio: true },
                },
              },
            },
          },
        }),
        context.db.comment.count({ where }),
      ]);
      
      // Format comments
      const formattedComments = comments.map(comment => ({
        ...comment,
        author: {
          id: comment.author.id,
          name: comment.author.name,
          image: comment.author.image,
          bio: comment.author.profile?.bio || null,
        },
        replies: [],
      }));
      
      const totalPages = Math.ceil(total / limit);
      
      return {
        success: true,
        data: {
          items: formattedComments,
          total,
          page,
          totalPages,
          hasMore: page < totalPages,
        },
      };
    }),

  // Update comment (owner only)
  update: authedProcedure
    .use(withOwnership({
      getResource: async (input, ctx) =>
        ctx.db.comment.findUnique({
          where: { id: input.id },
        }),
      ownerField: 'authorId',
    }))
    .use(withRateLimit({ limit: 'strict' }))
    .input(z.object({
      id: z.string().uuid(),
      content: z.string().min(1).max(1000),
    }))
    .output(successSchema(commentSchema))
    .handler(async ({ input, context }) => {
      const comment = await context.db.comment.update({
        where: { id: input.id },
        data: {
          content: input.content,
          editedAt: new Date(),
        },
      });
      
      return { success: true, data: comment };
    }),

  // Delete comment (owner or moderator)
  delete: authedProcedure
    .use(withOwnership({
      getResource: async (input, ctx) =>
        ctx.db.comment.findUnique({
          where: { id: input.id },
        }),
      ownerField: 'authorId',
      allowAdmin: true,
    }))
    .input(z.object({
      id: z.string().uuid(),
    }))
    .output(successSchema(z.object({ deleted: z.boolean() })))
    .handler(async ({ input, context }) => {
      // Soft delete comment and replies
      await context.db.comment.updateMany({
        where: {
          OR: [
            { id: input.id },
            { parentId: input.id },
          ],
        },
        data: { deletedAt: new Date() },
      });
      
      return { success: true, data: { deleted: true } };
    }),
};
```

### Schritt 2: Tag Procedures
Erstelle `packages/api/src/procedures/tag.ts`:

```typescript
import { z } from 'zod';
import {
  publicProcedure,
  adminProcedure,
  withCache,
} from './base';
import { createError } from '../errors/app-error';
import {
  successSchema,
  paginationSchema,
  paginatedResponseSchema,
} from '../utils/schemas';
import { tagSchema } from '../schemas/post';

export const tagProcedures = {
  // List all tags
  list: publicProcedure
    .use(withCache({
      key: () => 'tags:all',
      ttl: 3600, // 1 hour
    }))
    .input(z.object({
      search: z.string().optional(),
      limit: z.number().min(1).max(100).default(20),
    }))
    .output(successSchema(z.array(tagSchema.extend({
      postCount: z.number(),
    }))))
    .handler(async ({ input, context }) => {
      const { search, limit } = input;
      
      const tags = await context.db.tag.findMany({
        where: search ? {
          OR: [
            { name: { contains: search, mode: 'insensitive' } },
            { slug: { contains: search, mode: 'insensitive' } },
          ],
        } : undefined,
        take: limit,
        orderBy: {
          posts: {
            _count: 'desc',
          },
        },
        include: {
          _count: {
            select: { posts: true },
          },
        },
      });
      
      const formattedTags = tags.map(tag => ({
        ...tag,
        postCount: tag._count.posts,
      }));
      
      return { success: true, data: formattedTags };
    }),

  // Get popular tags
  popular: publicProcedure
    .use(withCache({
      key: () => 'tags:popular',
      ttl: 3600, // 1 hour
    }))
    .input(z.object({
      limit: z.number().min(1).max(20).default(10),
    }))
    .output(successSchema(z.array(tagSchema.extend({
      postCount: z.number(),
    }))))
    .handler(async ({ input, context }) => {
      const tags = await context.db.tag.findMany({
        take: input.limit,
        orderBy: {
          posts: {
            _count: 'desc',
          },
        },
        where: {
          posts: {
            some: {
              published: true,
              deletedAt: null,
            },
          },
        },
        include: {
          _count: {
            select: { 
              posts: {
                where: {
                  published: true,
                  deletedAt: null,
                },
              },
            },
          },
        },
      });
      
      const formattedTags = tags.map(tag => ({
        ...tag,
        postCount: tag._count.posts,
      }));
      
      return { success: true, data: formattedTags };
    }),

  // Update tag (admin only)
  update: adminProcedure
    .input(z.object({
      id: z.string().uuid(),
      name: z.string().optional(),
      description: z.string().nullable().optional(),
    }))
    .output(successSchema(tagSchema))
    .handler(async ({ input, context }) => {
      const { id, ...data } = input;
      
      const tag = await context.db.tag.update({
        where: { id },
        data,
      });
      
      return { success: true, data: tag };
    }),

  // Delete tag (admin only)
  delete: adminProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .output(successSchema(z.object({ deleted: z.boolean() })))
    .handler(async ({ input, context }) => {
      await context.db.tag.delete({
        where: { id: input.id },
      });
      
      return { success: true, data: { deleted: true } };
    }),
};
```

### Schritt 3: System Procedures
Erstelle `packages/api/src/procedures/system.ts`:

```typescript
import { z } from 'zod';
import { publicProcedure, adminProcedure } from './base';
import { successSchema } from '../utils/schemas';

export const systemProcedures = {
  // Health check
  health: publicProcedure
    .output(successSchema(z.object({
      status: z.literal('ok'),
      timestamp: z.string(),
      version: z.string(),
      uptime: z.number(),
    })))
    .handler(() => ({
      success: true,
      data: {
        status: 'ok' as const,
        timestamp: new Date().toISOString(),
        version: process.env.npm_package_version || '1.0.0',
        uptime: process.uptime(),
      },
    })),

  // Database health (admin only)
  dbHealth: adminProcedure
    .output(successSchema(z.object({
      connected: z.boolean(),
      latency: z.number(),
    })))
    .handler(async ({ context }) => {
      const start = Date.now();
      
      try {
        // Simple query to test connection
        await context.db.$queryRaw`SELECT 1`;
        
        return {
          success: true,
          data: {
            connected: true,
            latency: Date.now() - start,
          },
        };
      } catch (error) {
        return {
          success: true,
          data: {
            connected: false,
            latency: -1,
          },
        };
      }
    }),

  // Stats (admin only)
  stats: adminProcedure
    .output(successSchema(z.object({
      users: z.number(),
      posts: z.number(),
      comments: z.number(),
      tags: z.number(),
    })))
    .handler(async ({ context }) => {
      const [users, posts, comments, tags] = await Promise.all([
        context.db.user.count({ where: { deletedAt: null } }),
        context.db.post.count({ where: { deletedAt: null } }),
        context.db.comment.count({ where: { deletedAt: null } }),
        context.db.tag.count(),
      ]);
      
      return {
        success: true,
        data: { users, posts, comments, tags },
      };
    }),

  // Clear cache (admin only)
  clearCache: adminProcedure
    .output(successSchema(z.object({
      cleared: z.boolean(),
      message: z.string(),
    })))
    .handler(async ({ context }) => {
      // Clear in-memory cache (from base.ts)
      // This would need to be exported from base.ts
      // For now, just return success
      
      return {
        success: true,
        data: {
          cleared: true,
          message: 'Cache cleared successfully',
        },
      };
    }),
};
```

### Schritt 4: Main Router Assembly
Update `packages/api/src/router.ts`:

```typescript
import { userProcedures } from './procedures/user';
import { postProcedures } from './procedures/post';
import { commentProcedures } from './procedures/comment';
import { tagProcedures } from './procedures/tag';
import { systemProcedures } from './procedures/system';

/**
 * Main API Router
 * 
 * This is the central router that combines all API procedures.
 * It's exported as a plain object for oRPC compatibility.
 */
export const router = {
  // System endpoints
  health: systemProcedures.health,
  system: systemProcedures,
  
  // Feature endpoints
  user: userProcedures,
  post: postProcedures,
  comment: commentProcedures,
  tag: tagProcedures,
};

/**
 * Router type export for client SDK
 */
export type AppRouter = typeof router;

/**
 * Helper type for extracting procedure types
 */
export type RouterOutput<
  TRouter = AppRouter,
  TPath extends string = ''
> = TPath extends keyof TRouter
  ? TRouter[TPath] extends { handler: (...args: any[]) => infer R }
    ? Awaited<R>
    : never
  : TPath extends `${infer K}.${infer Rest}`
  ? K extends keyof TRouter
    ? RouterOutput<TRouter[K], Rest>
    : never
  : never;

/**
 * Helper type for extracting input types
 */
export type RouterInput<
  TRouter = AppRouter,
  TPath extends string = ''
> = TPath extends keyof TRouter
  ? TRouter[TPath] extends { input: infer I }
    ? I
    : never
  : TPath extends `${infer K}.${infer Rest}`
  ? K extends keyof TRouter
    ? RouterInput<TRouter[K], Rest>
    : never
  : never;
```

### Schritt 5: Export Index Update
Update `packages/api/src/index.ts`:

```typescript
// Context
export { createContext, type Context } from './context';

// Router
export { router, type AppRouter, type RouterOutput, type RouterInput } from './router';

// Errors
export { 
  AppError, 
  ErrorCode, 
  createError 
} from './errors/app-error';

// Schemas (for external use)
export {
  userSchema,
  userWithProfileSchema,
  publicUserSchema,
  UserRole,
  UserStatus,
} from './schemas/user';

export {
  postSchema,
  postWithRelationsSchema,
  commentSchema,
  tagSchema,
  PostStatus,
} from './schemas/post';

// Utils
export {
  successSchema,
  errorSchema,
  paginationSchema,
  listQuerySchema,
  paginatedResponseSchema,
} from './utils/schemas';
```

## Verifizierung

### Test 1: Health Check
```typescript
import { router } from '@starter-kit/api';

const result = await router.health.handler({ context });
console.log(result); // { success: true, data: { status: 'ok', ... } }
```

### Test 2: Nested Procedures
```typescript
// User procedures
await router.user.me.handler({ context });
await router.user.list.handler({ input, context });

// Post procedures
await router.post.create.handler({ input, context });
await router.post.list.handler({ input, context });

// Comment procedures
await router.comment.create.handler({ input, context });
```

### Test 3: Type Inference
```typescript
import type { AppRouter, RouterOutput } from '@starter-kit/api';

// Infer output types
type UserMeOutput = RouterOutput<AppRouter, 'user.me'>;
type PostListOutput = RouterOutput<AppRouter, 'post.list'>;

// Should have full type safety
const user: UserMeOutput = await api.user.me();
```

### Test 4: System Stats
```typescript
// Admin only
const { data: stats } = await api.system.stats();
console.log(stats); // { users: 10, posts: 25, ... }
```

## Erfolgskriterien
- [ ] Alle Procedures integriert
- [ ] Router Type Export funktioniert
- [ ] Health Check verfügbar
- [ ] System Endpoints implementiert
- [ ] Type Inference funktioniert
- [ ] Nested Structure korrekt

## Potentielle Probleme

### Problem: Circular Dependencies
**Lösung**: Saubere Import-Struktur, keine Cross-Imports zwischen Procedures

### Problem: Type Inference zu komplex
**Lösung**: Helper Types für bessere DX:
```typescript
type UserProcedures = typeof userProcedures;
type PostProcedures = typeof postProcedures;
```

## Nächste Schritte
- Weiter mit 07.06: Client SDK