# Arbeitspaket 07.03: User Procedures

## Ziel
Implementierung vollstÃ¤ndiger User Management API Procedures mit CRUD Operations, Profile Management und Admin Features.

## Kontext
- Aufbauend auf Base Procedures (07.02)
- Integration mit Clerk Authentication
- User Profile Management
- Admin User Management

## Implementierung

### Schritt 1: User Schemas
Erstelle `packages/api/src/schemas/user.ts`:

```typescript
import { z } from 'zod';

// User role enum
export const UserRole = z.enum(['USER', 'ADMIN', 'MODERATOR']);

// User status enum
export const UserStatus = z.enum(['ACTIVE', 'INACTIVE', 'SUSPENDED', 'DELETED']);

// User profile schema
export const userProfileSchema = z.object({
  id: z.string().uuid(),
  bio: z.string().nullable(),
  website: z.string().url().nullable(),
  location: z.string().nullable(),
  twitter: z.string().nullable(),
  github: z.string().nullable(),
  linkedin: z.string().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

// Base user schema
export const userSchema = z.object({
  id: z.string().uuid(),
  clerkId: z.string(),
  email: z.string().email(),
  name: z.string().nullable(),
  image: z.string().url().nullable(),
  role: UserRole.default('USER'),
  status: UserStatus.default('ACTIVE'),
  emailVerified: z.date().nullable(),
  lastLoginAt: z.date().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
  deletedAt: z.date().nullable(),
});

// User with profile
export const userWithProfileSchema = userSchema.extend({
  profile: userProfileSchema.nullable(),
});

// User with counts
export const userWithCountsSchema = userWithProfileSchema.extend({
  _count: z.object({
    posts: z.number(),
    comments: z.number(),
    followers: z.number(),
    following: z.number(),
  }).optional(),
});

// Public user info (for listings)
export const publicUserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().nullable(),
  image: z.string().url().nullable(),
  bio: z.string().nullable(),
});

// User update input schemas
export const updateProfileSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  bio: z.string().max(500).nullable().optional(),
  website: z.string().url().nullable().optional(),
  location: z.string().max(100).nullable().optional(),
  twitter: z.string().max(50).nullable().optional(),
  github: z.string().max(50).nullable().optional(),
  linkedin: z.string().max(100).nullable().optional(),
});

export const updateUserSettingsSchema = z.object({
  emailNotifications: z.boolean().optional(),
  pushNotifications: z.boolean().optional(),
  theme: z.enum(['light', 'dark', 'system']).optional(),
  language: z.string().optional(),
});
```

### Schritt 2: User Procedures Implementation
Erstelle `packages/api/src/procedures/user.ts`:

```typescript
import { z } from 'zod';
import { 
  publicProcedure,
  authedProcedure, 
  adminProcedure, 
  withRateLimit,
  withCache,
  withLogging,
} from './base';
import { createError } from '../errors/app-error';
import { createAuditLog } from '../utils/audit-log';
import {
  successSchema,
  paginationSchema,
  paginatedResponseSchema,
} from '../utils/schemas';
import {
  userSchema,
  userWithProfileSchema,
  userWithCountsSchema,
  publicUserSchema,
  updateProfileSchema,
  UserRole,
  UserStatus,
} from '../schemas/user';

export const userProcedures = {
  // Get current user with profile
  me: authedProcedure
    .use(withCache({
      key: (_, ctx) => `user:me:${ctx.userId}`,
      ttl: 300, // 5 minutes
    }))
    .output(successSchema(userWithProfileSchema))
    .handler(async ({ context }) => {
      let user = await context.db.user.findUnique({
        where: { clerkId: context.userId! },
        include: { profile: true },
      });
      
      // Create user if not exists (first login via Clerk)
      if (!user && context.user) {
        user = await context.db.user.create({
          data: {
            clerkId: context.userId!,
            email: context.user.emailAddresses[0]?.emailAddress || '',
            name: context.user.firstName 
              ? `${context.user.firstName} ${context.user.lastName || ''}`.trim()
              : null,
            image: context.user.imageUrl,
            emailVerified: context.user.emailAddresses[0]?.verification?.status === 'verified'
              ? new Date()
              : null,
            profile: {
              create: {},
            },
          },
          include: { profile: true },
        });
        
        // Log user creation
        await createAuditLog(context.db, {
          userId: user.id,
          action: 'USER_CREATED',
          entity: 'users',
          entityId: user.id,
          newValues: { source: 'clerk_webhook' },
          ip: context.ip,
          userAgent: context.userAgent,
        });
      }
      
      if (!user) {
        throw createError.notFound('User');
      }
      
      // Update last login
      await context.db.user.update({
        where: { id: user.id },
        data: { lastLoginAt: new Date() },
      });
      
      return { success: true, data: user };
    }),

  // Update current user profile
  updateProfile: authedProcedure
    .use(withRateLimit({ limit: 'strict' }))
    .use(withLogging({ includeInput: true }))
    .input(updateProfileSchema)
    .output(successSchema(userWithProfileSchema))
    .handler(async ({ input, context }) => {
      const currentUser = await context.db.user.findUnique({
        where: { clerkId: context.userId! },
        include: { profile: true },
      });
      
      if (!currentUser) {
        throw createError.notFound('User');
      }
      
      const user = await context.db.user.update({
        where: { id: currentUser.id },
        data: {
          name: input.name,
          profile: {
            upsert: {
              create: {
                bio: input.bio,
                website: input.website,
                location: input.location,
                twitter: input.twitter,
                github: input.github,
                linkedin: input.linkedin,
              },
              update: {
                bio: input.bio,
                website: input.website,
                location: input.location,
                twitter: input.twitter,
                github: input.github,
                linkedin: input.linkedin,
              },
            },
          },
        },
        include: { profile: true },
      });
      
      // Audit log
      await createAuditLog(context.db, {
        userId: currentUser.id,
        action: 'PROFILE_UPDATED',
        entity: 'users',
        entityId: currentUser.id,
        oldValues: currentUser.profile,
        newValues: input,
        ip: context.ip,
        userAgent: context.userAgent,
      });
      
      return { success: true, data: user };
    }),

  // Get public user by ID
  getById: publicProcedure
    .use(withCache({
      key: (input) => `user:${input.id}`,
      ttl: 600, // 10 minutes
    }))
    .input(z.object({
      id: z.string().uuid(),
    }))
    .output(successSchema(publicUserSchema))
    .handler(async ({ input, context }) => {
      const user = await context.db.user.findUnique({
        where: { 
          id: input.id,
          status: 'ACTIVE',
          deletedAt: null,
        },
        select: {
          id: true,
          name: true,
          image: true,
          profile: {
            select: {
              bio: true,
            },
          },
        },
      });
      
      if (!user) {
        throw createError.notFound('User');
      }
      
      return { 
        success: true, 
        data: {
          ...user,
          bio: user.profile?.bio || null,
        },
      };
    }),

  // List users (admin only)
  list: adminProcedure
    .use(withLogging())
    .input(paginationSchema.extend({
      search: z.string().optional(),
      role: UserRole.optional(),
      status: UserStatus.optional(),
      orderBy: z.enum(['createdAt', 'name', 'email', 'lastLoginAt']).default('createdAt'),
      order: z.enum(['asc', 'desc']).default('desc'),
    }))
    .output(successSchema(paginatedResponseSchema(userWithCountsSchema)))
    .handler(async ({ input, context }) => {
      const { page, limit, search, role, status, orderBy, order } = input;
      const skip = (page - 1) * limit;
      
      const where = {
        ...(search && {
          OR: [
            { name: { contains: search, mode: 'insensitive' as const } },
            { email: { contains: search, mode: 'insensitive' as const } },
          ],
        }),
        ...(role && { role }),
        ...(status && { status }),
        deletedAt: null,
      };
      
      const [users, total] = await Promise.all([
        context.db.user.findMany({
          where,
          skip,
          take: limit,
          orderBy: { [orderBy]: order },
          include: { 
            profile: true,
            _count: {
              select: {
                posts: true,
                comments: true,
                followers: true,
                following: true,
              },
            },
          },
        }),
        context.db.user.count({ where }),
      ]);
      
      const totalPages = Math.ceil(total / limit);
      
      return {
        success: true,
        data: {
          items: users,
          total,
          page,
          totalPages,
          hasMore: page < totalPages,
        },
      };
    }),

  // Get user details (admin only)
  getDetails: adminProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .output(successSchema(userWithCountsSchema.extend({
      recentActivity: z.array(z.object({
        type: z.string(),
        description: z.string(),
        timestamp: z.date(),
      })).optional(),
    })))
    .handler(async ({ input, context }) => {
      const user = await context.db.user.findUnique({
        where: { id: input.id },
        include: { 
          profile: true,
          _count: {
            select: {
              posts: true,
              comments: true,
              followers: true,
              following: true,
            },
          },
        },
      });
      
      if (!user) {
        throw createError.notFound('User');
      }
      
      // Get recent activity
      const recentPosts = await context.db.post.findMany({
        where: { authorId: user.id },
        take: 5,
        orderBy: { createdAt: 'desc' },
        select: {
          title: true,
          createdAt: true,
        },
      });
      
      const recentActivity = recentPosts.map(post => ({
        type: 'post',
        description: `Created post: ${post.title}`,
        timestamp: post.createdAt,
      }));
      
      return { 
        success: true, 
        data: {
          ...user,
          recentActivity,
        },
      };
    }),

  // Update user status (admin only)
  updateStatus: adminProcedure
    .use(withLogging({ includeInput: true }))
    .input(z.object({
      id: z.string().uuid(),
      status: UserStatus,
      reason: z.string().optional(),
    }))
    .output(successSchema(userSchema))
    .handler(async ({ input, context }) => {
      const oldUser = await context.db.user.findUnique({
        where: { id: input.id },
      });
      
      if (!oldUser) {
        throw createError.notFound('User');
      }
      
      // Prevent self-suspension
      if (oldUser.clerkId === context.userId && input.status === 'SUSPENDED') {
        throw createError.badRequest('Cannot suspend your own account');
      }
      
      const user = await context.db.user.update({
        where: { id: input.id },
        data: {
          status: input.status,
          ...(input.status === 'DELETED' && { 
            deletedAt: new Date(),
          }),
        },
      });
      
      // Audit log
      await createAuditLog(context.db, {
        userId: context.userId!,
        action: 'USER_STATUS_CHANGED',
        entity: 'users',
        entityId: user.id,
        oldValues: { status: oldUser.status },
        newValues: { status: input.status, reason: input.reason },
        ip: context.ip,
        userAgent: context.userAgent,
      });
      
      return { success: true, data: user };
    }),

  // Update user role (admin only)
  updateRole: adminProcedure
    .use(withLogging({ includeInput: true }))
    .input(z.object({
      id: z.string().uuid(),
      role: UserRole,
    }))
    .output(successSchema(userSchema))
    .handler(async ({ input, context }) => {
      const oldUser = await context.db.user.findUnique({
        where: { id: input.id },
      });
      
      if (!oldUser) {
        throw createError.notFound('User');
      }
      
      // Prevent self-demotion
      if (oldUser.clerkId === context.userId && 
          oldUser.role === 'ADMIN' && 
          input.role !== 'ADMIN') {
        throw createError.badRequest('Cannot remove your own admin role');
      }
      
      const user = await context.db.user.update({
        where: { id: input.id },
        data: { role: input.role },
      });
      
      // Update Clerk metadata
      // Note: This would require Clerk SDK setup
      // await clerkClient.users.updateUserMetadata(oldUser.clerkId, {
      //   publicMetadata: { role: input.role },
      // });
      
      // Audit log
      await createAuditLog(context.db, {
        userId: context.userId!,
        action: 'USER_ROLE_CHANGED',
        entity: 'users',
        entityId: user.id,
        oldValues: { role: oldUser.role },
        newValues: { role: input.role },
        ip: context.ip,
        userAgent: context.userAgent,
      });
      
      return { success: true, data: user };
    }),

  // Delete user (admin only - soft delete)
  delete: adminProcedure
    .input(z.object({
      id: z.string().uuid(),
      reason: z.string().min(10).max(500),
    }))
    .output(successSchema(z.object({ 
      deleted: z.boolean(),
      message: z.string(),
    })))
    .handler(async ({ input, context }) => {
      const user = await context.db.user.findUnique({
        where: { id: input.id },
      });
      
      if (!user) {
        throw createError.notFound('User');
      }
      
      // Prevent self-deletion
      if (user.clerkId === context.userId) {
        throw createError.badRequest('Cannot delete your own account');
      }
      
      // Soft delete user and cascade
      await context.db.$transaction([
        // Update user
        context.db.user.update({
          where: { id: input.id },
          data: {
            status: 'DELETED',
            deletedAt: new Date(),
            email: `deleted_${Date.now()}_${user.email}`, // Prevent email conflicts
          },
        }),
        // Soft delete posts
        context.db.post.updateMany({
          where: { authorId: input.id },
          data: { deletedAt: new Date() },
        }),
        // Soft delete comments
        context.db.comment.updateMany({
          where: { authorId: input.id },
          data: { deletedAt: new Date() },
        }),
      ]);
      
      // Audit log
      await createAuditLog(context.db, {
        userId: context.userId!,
        action: 'USER_DELETED',
        entity: 'users',
        entityId: user.id,
        newValues: { reason: input.reason },
        ip: context.ip,
        userAgent: context.userAgent,
      });
      
      return { 
        success: true, 
        data: { 
          deleted: true,
          message: 'User and associated content have been deleted',
        },
      };
    }),
};
```

## Verifizierung

### Test 1: Get Current User
```typescript
const api = createAPIClient('/api/rpc');
const { data: user } = await api.user.me();
console.log(user); // Current user with profile
```

### Test 2: Update Profile
```typescript
const { data: updated } = await api.user.updateProfile({
  name: 'John Doe',
  bio: 'Software Developer',
  website: 'https://example.com',
});
```

### Test 3: Admin User List
```typescript
// As admin user
const { data } = await api.user.list({
  page: 1,
  limit: 20,
  search: 'john',
  status: 'ACTIVE',
});
console.log(data.items); // Array of users
console.log(data.total); // Total count
```

### Test 4: User Status Management
```typescript
// Suspend user
await api.user.updateStatus({
  id: 'user-id',
  status: 'SUSPENDED',
  reason: 'Terms violation',
});

// Update role
await api.user.updateRole({
  id: 'user-id',
  role: 'MODERATOR',
});
```

## Erfolgskriterien
- [ ] User Profile CRUD funktioniert
- [ ] Admin User Management implementiert
- [ ] Soft Delete mit Cascade
- [ ] Audit Logging fÃ¼r alle Aktionen
- [ ] Caching fÃ¼r Read Operations
- [ ] Rate Limiting fÃ¼r Write Operations

## NÃ¤chste Schritte
- Weiter mit 07.04: Post Procedures