# Task 09.07: API Integration Tests - oRPC Router Testing

## Ziel
Implementierung von Integration Tests für die oRPC API Router mit Mocking der Prisma Database Layer.

## Voraussetzungen
- Task 09.01-09.06 abgeschlossen
- oRPC Router vorhanden in packages/api
- MSW Handler konfiguriert

## Implementierung

### Schritt 1: API Router Test Suite
Erstelle `packages/api/src/__tests__/router.test.ts`:

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { router } from '../router';
import { db } from '@starter-kit/db';
import { factories } from '../../../../test/factories';
import type { User, Post, Comment } from '@starter-kit/db/generated/prisma';

// Mock Prisma Client
vi.mock('@starter-kit/db', () => ({
  db: {
    user: {
      findUnique: vi.fn(),
      findFirst: vi.fn(),
      findMany: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      count: vi.fn(),
    },
    post: {
      findUnique: vi.fn(),
      findFirst: vi.fn(),
      findMany: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      count: vi.fn(),
    },
    comment: {
      findMany: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      count: vi.fn(),
    },
    profile: {
      findUnique: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
    },
    $transaction: vi.fn((callback) => callback(db)),
  },
}));

// Helper to create mock context
function createMockContext(overrides?: Partial<any>) {
  return {
    userId: 'clerk_user_123',
    sessionId: 'session_123',
    isAdmin: false,
    ...overrides,
  };
}

describe('API Router', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('Health Check', () => {
    it('returns health status', async () => {
      const result = await router.health();
      
      expect(result).toEqual({
        status: 'ok',
        timestamp: expect.any(String),
      });
    });

    it('includes timestamp in ISO format', async () => {
      const result = await router.health();
      const date = new Date(result.timestamp);
      
      expect(date.toISOString()).toBe(result.timestamp);
    });
  });

  describe('User Procedures', () => {
    describe('user.me', () => {
      it('returns current user data', async () => {
        const mockUser = factories.user.build();
        const mockProfile = factories.profile.build({ userId: mockUser.id });
        
        vi.mocked(db.user.findUnique).mockResolvedValue({
          ...mockUser,
          profile: mockProfile,
        } as any);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const result = await router.user.me({ context });
        
        expect(result).toEqual({
          success: true,
          data: expect.objectContaining({
            id: mockUser.id,
            email: mockUser.email,
            profile: expect.objectContaining({
              userId: mockUser.id,
            }),
          }),
        });
        
        expect(db.user.findUnique).toHaveBeenCalledWith({
          where: { clerkId: mockUser.clerkId },
          include: { profile: true },
        });
      });

      it('returns error when user not found', async () => {
        vi.mocked(db.user.findUnique).mockResolvedValue(null);
        
        const context = createMockContext();
        
        await expect(
          router.user.me({ context })
        ).rejects.toThrow('User not found');
      });

      it('requires authentication', async () => {
        const context = createMockContext({ userId: null });
        
        await expect(
          router.user.me({ context })
        ).rejects.toThrow('Authentication required');
      });
    });

    describe('user.create', () => {
      it('creates a new user', async () => {
        const input = {
          email: 'newuser@example.com',
          name: 'New User',
          password: 'SecurePassword123!',
        };
        
        const mockUser = factories.user.build(input);
        vi.mocked(db.user.findFirst).mockResolvedValue(null); // Email not taken
        vi.mocked(db.user.create).mockResolvedValue(mockUser as any);
        
        const context = createMockContext({ userId: null });
        const result = await router.user.create({ input, context });
        
        expect(result).toEqual({
          success: true,
          data: expect.objectContaining({
            email: input.email,
            name: input.name,
          }),
        });
        
        expect(db.user.create).toHaveBeenCalledWith({
          data: expect.objectContaining({
            email: input.email,
            name: input.name,
          }),
        });
      });

      it('validates email format', async () => {
        const input = {
          email: 'invalid-email',
          name: 'Test User',
          password: 'Password123!',
        };
        
        const context = createMockContext();
        
        await expect(
          router.user.create({ input, context })
        ).rejects.toThrow('Invalid email format');
      });

      it('checks for duplicate email', async () => {
        const existingUser = factories.user.build();
        vi.mocked(db.user.findFirst).mockResolvedValue(existingUser as any);
        
        const input = {
          email: existingUser.email,
          name: 'New User',
          password: 'Password123!',
        };
        
        const context = createMockContext();
        
        await expect(
          router.user.create({ input, context })
        ).rejects.toThrow('Email already exists');
      });

      it('validates password strength', async () => {
        const input = {
          email: 'test@example.com',
          name: 'Test User',
          password: '123', // Too weak
        };
        
        const context = createMockContext();
        
        await expect(
          router.user.create({ input, context })
        ).rejects.toThrow('Password too weak');
      });
    });

    describe('user.list', () => {
      it('returns paginated user list for admin', async () => {
        const mockUsers = factories.user.buildMany(5);
        vi.mocked(db.user.findMany).mockResolvedValue(mockUsers as any);
        vi.mocked(db.user.count).mockResolvedValue(5);
        
        const context = createMockContext({ isAdmin: true });
        const input = { page: 1, limit: 10 };
        
        const result = await router.user.list({ input, context });
        
        expect(result).toEqual({
          success: true,
          data: {
            users: mockUsers,
            total: 5,
            page: 1,
            totalPages: 1,
            hasNextPage: false,
            hasPreviousPage: false,
          },
        });
        
        expect(db.user.findMany).toHaveBeenCalledWith({
          skip: 0,
          take: 10,
          include: { profile: true },
          orderBy: { createdAt: 'desc' },
        });
      });

      it('requires admin privileges', async () => {
        const context = createMockContext({ isAdmin: false });
        const input = { page: 1, limit: 10 };
        
        await expect(
          router.user.list({ input, context })
        ).rejects.toThrow('Admin access required');
      });

      it('handles pagination correctly', async () => {
        const mockUsers = factories.user.buildMany(3);
        vi.mocked(db.user.findMany).mockResolvedValue(mockUsers as any);
        vi.mocked(db.user.count).mockResolvedValue(23);
        
        const context = createMockContext({ isAdmin: true });
        const input = { page: 2, limit: 10 };
        
        const result = await router.user.list({ input, context });
        
        expect(result.data).toMatchObject({
          page: 2,
          totalPages: 3,
          hasNextPage: true,
          hasPreviousPage: true,
        });
        
        expect(db.user.findMany).toHaveBeenCalledWith({
          skip: 10,
          take: 10,
          include: { profile: true },
          orderBy: { createdAt: 'desc' },
        });
      });
    });

    describe('user.update', () => {
      it('updates user profile', async () => {
        const mockUser = factories.user.build();
        const input = {
          name: 'Updated Name',
          bio: 'Updated bio',
        };
        
        vi.mocked(db.user.findUnique).mockResolvedValue(mockUser as any);
        vi.mocked(db.user.update).mockResolvedValue({
          ...mockUser,
          ...input,
        } as any);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const result = await router.user.update({ 
          input: { id: mockUser.id, ...input }, 
          context 
        });
        
        expect(result).toEqual({
          success: true,
          data: expect.objectContaining({
            name: input.name,
          }),
        });
      });

      it('only allows users to update their own profile', async () => {
        const context = createMockContext({ userId: 'different_user' });
        const input = { id: 'user123', name: 'Hacker' };
        
        await expect(
          router.user.update({ input, context })
        ).rejects.toThrow('Permission denied');
      });
    });
  });

  describe('Post Procedures', () => {
    describe('post.create', () => {
      it('creates a new post', async () => {
        const mockUser = factories.user.build();
        const input = {
          title: 'New Post',
          content: 'Post content',
          published: false,
        };
        
        const mockPost = factories.post.build({
          ...input,
          authorId: mockUser.id,
        });
        
        vi.mocked(db.user.findUnique).mockResolvedValue(mockUser as any);
        vi.mocked(db.post.create).mockResolvedValue(mockPost as any);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const result = await router.post.create({ input, context });
        
        expect(result).toEqual({
          success: true,
          data: expect.objectContaining({
            title: input.title,
            content: input.content,
            authorId: mockUser.id,
          }),
        });
        
        expect(db.post.create).toHaveBeenCalledWith({
          data: expect.objectContaining({
            title: input.title,
            content: input.content,
            authorId: mockUser.id,
            slug: expect.any(String),
          }),
        });
      });

      it('generates unique slug', async () => {
        const mockUser = factories.user.build();
        const existingPost = factories.post.build({ slug: 'test-post' });
        
        vi.mocked(db.user.findUnique).mockResolvedValue(mockUser as any);
        vi.mocked(db.post.findFirst)
          .mockResolvedValueOnce(existingPost as any) // First slug taken
          .mockResolvedValueOnce(null); // Second slug available
        
        const input = {
          title: 'Test Post',
          content: 'Content',
          published: false,
        };
        
        const mockPost = factories.post.build();
        vi.mocked(db.post.create).mockResolvedValue(mockPost as any);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        await router.post.create({ input, context });
        
        expect(db.post.create).toHaveBeenCalledWith({
          data: expect.objectContaining({
            slug: expect.stringMatching(/^test-post-[a-z0-9]+$/),
          }),
        });
      });

      it('requires authentication', async () => {
        const context = createMockContext({ userId: null });
        const input = { title: 'Test', content: 'Test', published: false };
        
        await expect(
          router.post.create({ input, context })
        ).rejects.toThrow('Authentication required');
      });
    });

    describe('post.list', () => {
      it('returns published posts for public', async () => {
        const publishedPosts = factories.post.buildMany(3, { published: true });
        const draftPosts = factories.post.buildMany(2, { published: false });
        
        vi.mocked(db.post.findMany).mockResolvedValue(publishedPosts as any);
        vi.mocked(db.post.count).mockResolvedValue(3);
        
        const context = createMockContext({ userId: null });
        const result = await router.post.list({ context });
        
        expect(result).toEqual({
          success: true,
          data: {
            posts: publishedPosts,
            total: 3,
            page: 1,
            totalPages: 1,
          },
        });
        
        expect(db.post.findMany).toHaveBeenCalledWith({
          where: { published: true },
          include: {
            author: true,
            comments: { take: 5 },
            _count: { select: { comments: true, likes: true } },
          },
          orderBy: { publishedAt: 'desc' },
          skip: 0,
          take: 10,
        });
      });

      it('includes drafts for authenticated users', async () => {
        const mockUser = factories.user.build();
        const posts = factories.post.buildMany(5);
        
        vi.mocked(db.post.findMany).mockResolvedValue(posts as any);
        vi.mocked(db.post.count).mockResolvedValue(5);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const input = { includeDrafts: true };
        
        const result = await router.post.list({ input, context });
        
        expect(db.post.findMany).toHaveBeenCalledWith({
          where: {
            OR: [
              { published: true },
              { authorId: mockUser.clerkId, published: false },
            ],
          },
          include: expect.any(Object),
          orderBy: expect.any(Object),
          skip: 0,
          take: 10,
        });
      });

      it('filters by category', async () => {
        const context = createMockContext();
        const input = { category: 'Tech' };
        
        await router.post.list({ input, context });
        
        expect(db.post.findMany).toHaveBeenCalledWith({
          where: expect.objectContaining({
            category: 'Tech',
          }),
          include: expect.any(Object),
          orderBy: expect.any(Object),
          skip: 0,
          take: 10,
        });
      });

      it('searches by keyword', async () => {
        const context = createMockContext();
        const input = { search: 'typescript' };
        
        await router.post.list({ input, context });
        
        expect(db.post.findMany).toHaveBeenCalledWith({
          where: {
            OR: [
              { title: { contains: 'typescript', mode: 'insensitive' } },
              { content: { contains: 'typescript', mode: 'insensitive' } },
              { tags: { has: 'typescript' } },
            ],
          },
          include: expect.any(Object),
          orderBy: expect.any(Object),
          skip: 0,
          take: 10,
        });
      });
    });

    describe('post.update', () => {
      it('updates own post', async () => {
        const mockUser = factories.user.build();
        const mockPost = factories.post.build({ authorId: mockUser.id });
        const input = {
          id: mockPost.id,
          title: 'Updated Title',
          content: 'Updated content',
        };
        
        vi.mocked(db.user.findUnique).mockResolvedValue(mockUser as any);
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        vi.mocked(db.post.update).mockResolvedValue({
          ...mockPost,
          ...input,
        } as any);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const result = await router.post.update({ input, context });
        
        expect(result).toEqual({
          success: true,
          data: expect.objectContaining({
            title: input.title,
            content: input.content,
          }),
        });
      });

      it('prevents updating posts by other users', async () => {
        const mockPost = factories.post.build({ authorId: 'other-user' });
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        
        const context = createMockContext({ userId: 'current-user' });
        const input = { id: mockPost.id, title: 'Hacked!' };
        
        await expect(
          router.post.update({ input, context })
        ).rejects.toThrow('Permission denied');
      });

      it('allows admin to update any post', async () => {
        const mockPost = factories.post.build();
        const input = { id: mockPost.id, title: 'Admin Update' };
        
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        vi.mocked(db.post.update).mockResolvedValue({
          ...mockPost,
          ...input,
        } as any);
        
        const context = createMockContext({ isAdmin: true });
        const result = await router.post.update({ input, context });
        
        expect(result.success).toBe(true);
      });
    });

    describe('post.delete', () => {
      it('soft deletes own post', async () => {
        const mockUser = factories.user.build();
        const mockPost = factories.post.build({ authorId: mockUser.id });
        
        vi.mocked(db.user.findUnique).mockResolvedValue(mockUser as any);
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        vi.mocked(db.post.update).mockResolvedValue({
          ...mockPost,
          deletedAt: new Date(),
        } as any);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const result = await router.post.delete({ 
          input: { id: mockPost.id }, 
          context 
        });
        
        expect(result).toEqual({
          success: true,
          data: { deleted: true },
        });
        
        expect(db.post.update).toHaveBeenCalledWith({
          where: { id: mockPost.id },
          data: { deletedAt: expect.any(Date) },
        });
      });

      it('prevents deleting posts by other users', async () => {
        const mockPost = factories.post.build({ authorId: 'other-user' });
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        
        const context = createMockContext({ userId: 'current-user' });
        
        await expect(
          router.post.delete({ input: { id: mockPost.id }, context })
        ).rejects.toThrow('Permission denied');
      });
    });
  });

  describe('Comment Procedures', () => {
    describe('comment.create', () => {
      it('creates a comment on a post', async () => {
        const mockUser = factories.user.build();
        const mockPost = factories.post.build({ published: true });
        const input = {
          postId: mockPost.id,
          content: 'Great post!',
        };
        
        const mockComment = factories.comment.build({
          ...input,
          authorId: mockUser.id,
        });
        
        vi.mocked(db.user.findUnique).mockResolvedValue(mockUser as any);
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        vi.mocked(db.comment.create).mockResolvedValue(mockComment as any);
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const result = await router.comment.create({ input, context });
        
        expect(result).toEqual({
          success: true,
          data: expect.objectContaining({
            content: input.content,
            postId: input.postId,
          }),
        });
      });

      it('prevents commenting on unpublished posts', async () => {
        const mockPost = factories.post.build({ published: false });
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        
        const context = createMockContext();
        const input = {
          postId: mockPost.id,
          content: 'Comment',
        };
        
        await expect(
          router.comment.create({ input, context })
        ).rejects.toThrow('Cannot comment on unpublished post');
      });

      it('creates nested comment reply', async () => {
        const mockUser = factories.user.build();
        const mockPost = factories.post.build();
        const parentComment = factories.comment.build({ postId: mockPost.id });
        
        const input = {
          postId: mockPost.id,
          parentId: parentComment.id,
          content: 'Reply to comment',
        };
        
        vi.mocked(db.user.findUnique).mockResolvedValue(mockUser as any);
        vi.mocked(db.post.findUnique).mockResolvedValue(mockPost as any);
        vi.mocked(db.comment.findUnique).mockResolvedValue(parentComment as any);
        vi.mocked(db.comment.create).mockImplementation((args: any) => 
          Promise.resolve(factories.comment.build(args.data) as any)
        );
        
        const context = createMockContext({ userId: mockUser.clerkId });
        const result = await router.comment.create({ input, context });
        
        expect(result.data).toMatchObject({
          parentId: parentComment.id,
          content: input.content,
        });
      });
    });
  });

  describe('Transaction Handling', () => {
    it('uses transactions for complex operations', async () => {
      const mockUser = factories.user.build();
      const mockProfile = factories.profile.build();
      
      vi.mocked(db.$transaction).mockImplementation(async (callback) => {
        return callback(db);
      });
      
      const context = createMockContext();
      
      // Assuming a method that uses transactions
      await router.user.createWithProfile({
        input: {
          email: 'test@example.com',
          name: 'Test User',
          bio: 'Test bio',
        },
        context,
      });
      
      expect(db.$transaction).toHaveBeenCalled();
    });
  });

  describe('Error Handling', () => {
    it('handles database errors gracefully', async () => {
      vi.mocked(db.user.findUnique).mockRejectedValue(
        new Error('Database connection failed')
      );
      
      const context = createMockContext();
      
      await expect(
        router.user.me({ context })
      ).rejects.toThrow('Database error');
    });

    it('validates input data', async () => {
      const context = createMockContext();
      const input = {
        email: '', // Empty email
        name: '',  // Empty name
        password: '',
      };
      
      await expect(
        router.user.create({ input, context })
      ).rejects.toThrow('Validation error');
    });
  });
});
```

## Verifizierung

### Test 1: Run API Tests
```bash
npm run test packages/api/src/__tests__/router.test.ts
# Alle Tests sollten grün sein
```

### Test 2: Coverage Check
```bash
npm run test:coverage -- packages/api
# Coverage sollte > 80% sein
```

### Test 3: Mock Verification
```bash
npm run test -- --reporter=verbose packages/api
# Zeigt detaillierte Mock-Calls
```

## Erfolgskriterien
- [ ] Health Check Tests
- [ ] User CRUD Operations Tests
- [ ] Post CRUD Operations Tests
- [ ] Comment Operations Tests
- [ ] Authentication Tests
- [ ] Authorization Tests (Admin, User Roles)
- [ ] Pagination Tests
- [ ] Search/Filter Tests
- [ ] Transaction Tests
- [ ] Error Handling Tests
- [ ] Input Validation Tests
- [ ] Mock Database Layer

## Wichtige Hinweise

### Mock Isolation
- Jeder Test sollte isoliert laufen
- Mocks zwischen Tests clearen
- Keine echte Datenbank verwenden

### Context Mocking
- Immer realistische Context-Objekte erstellen
- Authentication und Authorization testen

### Error Scenarios
- Nicht nur Happy Path testen
- Edge Cases und Fehler abdecken

## Potentielle Probleme

### Problem: Prisma Types nicht gefunden
**Lösung**: Prisma Client generieren
```bash
cd packages/db && npx prisma generate
```

### Problem: Context Type Mismatch
**Lösung**: Context Interface definieren
```typescript
interface ApiContext {
  userId: string | null;
  sessionId: string;
  isAdmin: boolean;
}
```

### Problem: Async Tests timeout
**Lösung**: Timeout erhöhen
```typescript
describe('Slow tests', { timeout: 10000 }, () => {
  // Tests
});
```

## Rollback Plan
Falls Tests fehlschlagen:
```typescript
describe.skip('Problematic suite', () => {
  // Skip temporarily
});
```

## Zeitschätzung
- API Router Test Suite: 20 Minuten
- Mock Setup: 5 Minuten
- Verifizierung: 5 Minuten
- **Total: 30 Minuten**

## Nächster Schritt
Nach erfolgreichen API Tests → [09.08 E2E Setup](./09.08-e2e-setup.md)